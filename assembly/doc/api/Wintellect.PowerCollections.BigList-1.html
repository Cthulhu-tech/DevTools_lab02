<!DOCTYPE html>
<!--[if IE]><![endif]-->
<html>
  
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>Class BigList&lt;T&gt;
   </title>
    <meta name="viewport" content="width=device-width">
    <meta name="title" content="Class BigList&lt;T&gt;
   ">
    <meta name="generator" content="docfx 2.59.4.0">
    
    <link rel="shortcut icon" href="../favicon.ico">
    <link rel="stylesheet" href="../styles/docfx.vendor.css">
    <link rel="stylesheet" href="../styles/docfx.css">
    <link rel="stylesheet" href="../styles/main.css">
    <meta property="docfx:navrel" content="../toc">
    <meta property="docfx:tocrel" content="toc">
    
    
    
  </head>
  <body data-spy="scroll" data-target="#affix" data-offset="120">
    <div id="wrapper">
      <header>
        
        <nav id="autocollapse" class="navbar navbar-inverse ng-scope" role="navigation">
          <div class="container">
            <div class="navbar-header">
              <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#navbar">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
              </button>
              
              <a class="navbar-brand" href="../index.html">
                <img id="logo" class="svg" src="../logo.svg" alt="">
              </a>
            </div>
            <div class="collapse navbar-collapse" id="navbar">
              <form class="navbar-form navbar-right" role="search" id="search">
                <div class="form-group">
                  <input type="text" class="form-control" id="search-query" placeholder="Search" autocomplete="off">
                </div>
              </form>
                
                <ul class="nav level1 navbar-nav">
                      <li>
                          <a href=".././api/Wintellect.PowerCollections.html" title="Wintellect">Wintellect</a>
                      </li>
                </ul>    </div>
          </div>
        </nav>
        
        <div class="subnav navbar navbar-default">
          <div class="container hide-when-search" id="breadcrumb">
            <ul class="breadcrumb">
              <li></li>
            </ul>
          </div>
        </div>
      </header>
      <div role="main" class="container body-content hide-when-search">
        <div class="sidenav hide-when-search">
          <a class="btn toc-toggle collapse" data-toggle="collapse" href="#sidetoggle" aria-expanded="false" aria-controls="sidetoggle">Show / Hide Table of Contents</a>
          <div class="sidetoggle collapse" id="sidetoggle">
            <div>
              <div class="sidefilter">
                <form class="toc-filter">
                  <span class="glyphicon glyphicon-filter filter-icon"></span>
                  <input type="text" id="toc_filter_input" placeholder="Enter here to filter..." onkeypress="if(event.keyCode==13) {return false;}">
                </form>
              </div>
              <div class="sidetoc">
                <div class="toc" id="toc">
                  
                  <ul class="nav level1">
                    <li class="">
                      <span class="expand-stub"></span>
                      <a href="Wintellect.PowerCollections.html" title="Wintellect.PowerCollections" class="">Wintellect.PowerCollections</a>
                        
                        <ul class="nav level2">
                          <li class="">
                            <a href="Wintellect.PowerCollections.Algorithms.html" title="Algorithms" class="">Algorithms</a>
                          </li>
                          <li class="">
                            <a href="Wintellect.PowerCollections.Bag-1.html" title="Bag&lt;T&gt;" class="">Bag&lt;T&gt;</a>
                          </li>
                          <li class="active">
                            <a href="Wintellect.PowerCollections.BigList-1.html" title="BigList&lt;T&gt;" class="active">BigList&lt;T&gt;</a>
                          </li>
                          <li class="">
                            <a href="Wintellect.PowerCollections.BinaryPredicate-1.html" title="BinaryPredicate&lt;T&gt;" class="">BinaryPredicate&lt;T&gt;</a>
                          </li>
                          <li class="">
                            <a href="Wintellect.PowerCollections.BinaryPredicate-1.html" title="BinaryPredicate&lt;T&gt;" class="">BinaryPredicate&lt;T&gt;</a>
                          </li>
                          <li class="">
                            <a href="Wintellect.PowerCollections.CollectionBase-1.html" title="CollectionBase&lt;T&gt;" class="">CollectionBase&lt;T&gt;</a>
                          </li>
                          <li class="">
                            <a href="Wintellect.PowerCollections.Deque-1.html" title="Deque&lt;T&gt;" class="">Deque&lt;T&gt;</a>
                          </li>
                          <li class="">
                            <a href="Wintellect.PowerCollections.DictionaryBase-2.html" title="DictionaryBase&lt;TKey, TValue&gt;" class="">DictionaryBase&lt;TKey, TValue&gt;</a>
                          </li>
                          <li class="">
                            <a href="Wintellect.PowerCollections.ListBase-1.html" title="ListBase&lt;T&gt;" class="">ListBase&lt;T&gt;</a>
                          </li>
                          <li class="">
                            <a href="Wintellect.PowerCollections.MultiDictionary-2.html" title="MultiDictionary&lt;TKey, TValue&gt;" class="">MultiDictionary&lt;TKey, TValue&gt;</a>
                          </li>
                          <li class="">
                            <a href="Wintellect.PowerCollections.MultiDictionaryBase-2.html" title="MultiDictionaryBase&lt;TKey, TValue&gt;" class="">MultiDictionaryBase&lt;TKey, TValue&gt;</a>
                          </li>
                          <li class="">
                            <a href="Wintellect.PowerCollections.OrderedBag-1.html" title="OrderedBag&lt;T&gt;" class="">OrderedBag&lt;T&gt;</a>
                          </li>
                          <li class="">
                            <a href="Wintellect.PowerCollections.OrderedBag-1.View.html" title="OrderedBag&lt;T&gt;.View" class="">OrderedBag&lt;T&gt;.View</a>
                          </li>
                          <li class="">
                            <a href="Wintellect.PowerCollections.OrderedDictionary-2.html" title="OrderedDictionary&lt;TKey, TValue&gt;" class="">OrderedDictionary&lt;TKey, TValue&gt;</a>
                          </li>
                          <li class="">
                            <a href="Wintellect.PowerCollections.OrderedDictionary-2.View.html" title="OrderedDictionary&lt;TKey, TValue&gt;.View" class="">OrderedDictionary&lt;TKey, TValue&gt;.View</a>
                          </li>
                          <li class="">
                            <a href="Wintellect.PowerCollections.OrderedMultiDictionary-2.html" title="OrderedMultiDictionary&lt;TKey, TValue&gt;" class="">OrderedMultiDictionary&lt;TKey, TValue&gt;</a>
                          </li>
                          <li class="">
                            <a href="Wintellect.PowerCollections.OrderedMultiDictionary-2.View.html" title="OrderedMultiDictionary&lt;TKey, TValue&gt;.View" class="">OrderedMultiDictionary&lt;TKey, TValue&gt;.View</a>
                          </li>
                          <li class="">
                            <a href="Wintellect.PowerCollections.OrderedSet-1.html" title="OrderedSet&lt;T&gt;" class="">OrderedSet&lt;T&gt;</a>
                          </li>
                          <li class="">
                            <a href="Wintellect.PowerCollections.OrderedSet-1.View.html" title="OrderedSet&lt;T&gt;.View" class="">OrderedSet&lt;T&gt;.View</a>
                          </li>
                          <li class="">
                            <a href="Wintellect.PowerCollections.Pair-2.html" title="Pair&lt;TFirst, TSecond&gt;" class="">Pair&lt;TFirst, TSecond&gt;</a>
                          </li>
                          <li class="">
                            <a href="Wintellect.PowerCollections.ReadOnlyCollectionBase-1.html" title="ReadOnlyCollectionBase&lt;T&gt;" class="">ReadOnlyCollectionBase&lt;T&gt;</a>
                          </li>
                          <li class="">
                            <a href="Wintellect.PowerCollections.ReadOnlyDictionaryBase-2.html" title="ReadOnlyDictionaryBase&lt;TKey, TValue&gt;" class="">ReadOnlyDictionaryBase&lt;TKey, TValue&gt;</a>
                          </li>
                          <li class="">
                            <a href="Wintellect.PowerCollections.ReadOnlyListBase-1.html" title="ReadOnlyListBase&lt;T&gt;" class="">ReadOnlyListBase&lt;T&gt;</a>
                          </li>
                          <li class="">
                            <a href="Wintellect.PowerCollections.ReadOnlyMultiDictionaryBase-2.html" title="ReadOnlyMultiDictionaryBase&lt;TKey, TValue&gt;" class="">ReadOnlyMultiDictionaryBase&lt;TKey, TValue&gt;</a>
                          </li>
                          <li class="">
                            <a href="Wintellect.PowerCollections.Set-1.html" title="Set&lt;T&gt;" class="">Set&lt;T&gt;</a>
                          </li>
                          <li class="">
                            <a href="Wintellect.PowerCollections.Stack-1.html" title="Stack&lt;T&gt;" class="">Stack&lt;T&gt;</a>
                          </li>
                          <li class="">
                            <a href="Wintellect.PowerCollections.Triple-3.html" title="Triple&lt;TFirst, TSecond, TThird&gt;" class="">Triple&lt;TFirst, TSecond, TThird&gt;</a>
                          </li>
                        </ul>  </li>
                  </ul>        </div>
              </div>
            </div>
          </div>
        </div>
        <div class="article row grid-right">
          <div class="col-md-10">
            <article class="content wrap" id="_content" data-uid="Wintellect.PowerCollections.BigList`1">
  
  
  <h1 id="Wintellect_PowerCollections_BigList_1" data-uid="Wintellect.PowerCollections.BigList`1" class="text-break">Class BigList&lt;T&gt;
  </h1>
  <div class="markdown level0 summary"><p>BigList&lt;T&gt; provides a list of items, in order, with indices of the items ranging from 0 to one less
than the count of items in the collection. BigList&lt;T&gt; is optimized for efficient operations on large (&gt;100 items)
lists, especially for insertions, deletions, copies, and concatinations.</p>
</div>
  <div class="markdown level0 conceptual"></div>
  <div class="inheritance">
    <h5>Inheritance</h5>
    <div class="level0"><span class="xref">System.Object</span></div>
    <div class="level1"><a class="xref" href="Wintellect.PowerCollections.CollectionBase-1.html">CollectionBase</a>&lt;T&gt;</div>
    <div class="level2"><a class="xref" href="Wintellect.PowerCollections.ListBase-1.html">ListBase</a>&lt;T&gt;</div>
    <div class="level3"><span class="xref">BigList&lt;T&gt;</span></div>
  </div>
  <div class="implements">
    <h5>Implements</h5>
    <div><span class="xref">System.Collections.Generic.IList</span>&lt;T&gt;</div>
    <div><span class="xref">System.Collections.Generic.ICollection</span>&lt;T&gt;</div>
    <div><span class="xref">System.Collections.Generic.IEnumerable</span>&lt;T&gt;</div>
    <div><span class="xref">System.Collections.IList</span></div>
    <div><span class="xref">System.Collections.ICollection</span></div>
    <div><span class="xref">System.Collections.IEnumerable</span></div>
    <div><span class="xref">System.ICloneable</span></div>
  </div>
  <div class="inheritedMembers">
    <h5>Inherited Members</h5>
    <div>
      <a class="xref" href="Wintellect.PowerCollections.ListBase-1.html#Wintellect_PowerCollections_ListBase_1_Contains__0_">ListBase&lt;T&gt;.Contains(T)</a>
    </div>
    <div>
      <a class="xref" href="Wintellect.PowerCollections.ListBase-1.html#Wintellect_PowerCollections_ListBase_1_Remove__0_">ListBase&lt;T&gt;.Remove(T)</a>
    </div>
    <div>
      <a class="xref" href="Wintellect.PowerCollections.ListBase-1.html#Wintellect_PowerCollections_ListBase_1_CopyTo__0___">ListBase&lt;T&gt;.CopyTo(T[])</a>
    </div>
    <div>
      <a class="xref" href="Wintellect.PowerCollections.ListBase-1.html#Wintellect_PowerCollections_ListBase_1_CopyTo_System_Int32__0___System_Int32_System_Int32_">ListBase&lt;T&gt;.CopyTo(Int32, T[], Int32, Int32)</a>
    </div>
    <div>
      <a class="xref" href="Wintellect.PowerCollections.ListBase-1.html#Wintellect_PowerCollections_ListBase_1_AsReadOnly">ListBase&lt;T&gt;.AsReadOnly()</a>
    </div>
    <div>
      <a class="xref" href="Wintellect.PowerCollections.ListBase-1.html#Wintellect_PowerCollections_ListBase_1_Find_System_Predicate__0__">ListBase&lt;T&gt;.Find(Predicate&lt;T&gt;)</a>
    </div>
    <div>
      <a class="xref" href="Wintellect.PowerCollections.ListBase-1.html#Wintellect_PowerCollections_ListBase_1_TryFind_System_Predicate__0___0__">ListBase&lt;T&gt;.TryFind(Predicate&lt;T&gt;, T)</a>
    </div>
    <div>
      <a class="xref" href="Wintellect.PowerCollections.ListBase-1.html#Wintellect_PowerCollections_ListBase_1_FindLast_System_Predicate__0__">ListBase&lt;T&gt;.FindLast(Predicate&lt;T&gt;)</a>
    </div>
    <div>
      <a class="xref" href="Wintellect.PowerCollections.ListBase-1.html#Wintellect_PowerCollections_ListBase_1_TryFindLast_System_Predicate__0___0__">ListBase&lt;T&gt;.TryFindLast(Predicate&lt;T&gt;, T)</a>
    </div>
    <div>
      <a class="xref" href="Wintellect.PowerCollections.ListBase-1.html#Wintellect_PowerCollections_ListBase_1_FindIndex_System_Predicate__0__">ListBase&lt;T&gt;.FindIndex(Predicate&lt;T&gt;)</a>
    </div>
    <div>
      <a class="xref" href="Wintellect.PowerCollections.ListBase-1.html#Wintellect_PowerCollections_ListBase_1_FindIndex_System_Int32_System_Predicate__0__">ListBase&lt;T&gt;.FindIndex(Int32, Predicate&lt;T&gt;)</a>
    </div>
    <div>
      <a class="xref" href="Wintellect.PowerCollections.ListBase-1.html#Wintellect_PowerCollections_ListBase_1_FindIndex_System_Int32_System_Int32_System_Predicate__0__">ListBase&lt;T&gt;.FindIndex(Int32, Int32, Predicate&lt;T&gt;)</a>
    </div>
    <div>
      <a class="xref" href="Wintellect.PowerCollections.ListBase-1.html#Wintellect_PowerCollections_ListBase_1_FindLastIndex_System_Predicate__0__">ListBase&lt;T&gt;.FindLastIndex(Predicate&lt;T&gt;)</a>
    </div>
    <div>
      <a class="xref" href="Wintellect.PowerCollections.ListBase-1.html#Wintellect_PowerCollections_ListBase_1_FindLastIndex_System_Int32_System_Predicate__0__">ListBase&lt;T&gt;.FindLastIndex(Int32, Predicate&lt;T&gt;)</a>
    </div>
    <div>
      <a class="xref" href="Wintellect.PowerCollections.ListBase-1.html#Wintellect_PowerCollections_ListBase_1_FindLastIndex_System_Int32_System_Int32_System_Predicate__0__">ListBase&lt;T&gt;.FindLastIndex(Int32, Int32, Predicate&lt;T&gt;)</a>
    </div>
    <div>
      <a class="xref" href="Wintellect.PowerCollections.ListBase-1.html#Wintellect_PowerCollections_ListBase_1_IndexOf__0_">ListBase&lt;T&gt;.IndexOf(T)</a>
    </div>
    <div>
      <a class="xref" href="Wintellect.PowerCollections.ListBase-1.html#Wintellect_PowerCollections_ListBase_1_IndexOf__0_System_Int32_">ListBase&lt;T&gt;.IndexOf(T, Int32)</a>
    </div>
    <div>
      <a class="xref" href="Wintellect.PowerCollections.ListBase-1.html#Wintellect_PowerCollections_ListBase_1_IndexOf__0_System_Int32_System_Int32_">ListBase&lt;T&gt;.IndexOf(T, Int32, Int32)</a>
    </div>
    <div>
      <a class="xref" href="Wintellect.PowerCollections.ListBase-1.html#Wintellect_PowerCollections_ListBase_1_LastIndexOf__0_">ListBase&lt;T&gt;.LastIndexOf(T)</a>
    </div>
    <div>
      <a class="xref" href="Wintellect.PowerCollections.ListBase-1.html#Wintellect_PowerCollections_ListBase_1_LastIndexOf__0_System_Int32_">ListBase&lt;T&gt;.LastIndexOf(T, Int32)</a>
    </div>
    <div>
      <a class="xref" href="Wintellect.PowerCollections.ListBase-1.html#Wintellect_PowerCollections_ListBase_1_LastIndexOf__0_System_Int32_System_Int32_">ListBase&lt;T&gt;.LastIndexOf(T, Int32, Int32)</a>
    </div>
    <div>
      <a class="xref" href="Wintellect.PowerCollections.ListBase-1.html#Wintellect_PowerCollections_ListBase_1_System_Collections_IList_Add_System_Object_">ListBase&lt;T&gt;.IList.Add(Object)</a>
    </div>
    <div>
      <a class="xref" href="Wintellect.PowerCollections.ListBase-1.html#Wintellect_PowerCollections_ListBase_1_System_Collections_IList_Clear">ListBase&lt;T&gt;.IList.Clear()</a>
    </div>
    <div>
      <a class="xref" href="Wintellect.PowerCollections.ListBase-1.html#Wintellect_PowerCollections_ListBase_1_System_Collections_IList_Contains_System_Object_">ListBase&lt;T&gt;.IList.Contains(Object)</a>
    </div>
    <div>
      <a class="xref" href="Wintellect.PowerCollections.ListBase-1.html#Wintellect_PowerCollections_ListBase_1_System_Collections_IList_IndexOf_System_Object_">ListBase&lt;T&gt;.IList.IndexOf(Object)</a>
    </div>
    <div>
      <a class="xref" href="Wintellect.PowerCollections.ListBase-1.html#Wintellect_PowerCollections_ListBase_1_System_Collections_IList_Insert_System_Int32_System_Object_">ListBase&lt;T&gt;.IList.Insert(Int32, Object)</a>
    </div>
    <div>
      <a class="xref" href="Wintellect.PowerCollections.ListBase-1.html#Wintellect_PowerCollections_ListBase_1_System_Collections_IList_IsFixedSize">ListBase&lt;T&gt;.IList.IsFixedSize</a>
    </div>
    <div>
      <a class="xref" href="Wintellect.PowerCollections.ListBase-1.html#Wintellect_PowerCollections_ListBase_1_System_Collections_IList_IsReadOnly">ListBase&lt;T&gt;.IList.IsReadOnly</a>
    </div>
    <div>
      <a class="xref" href="Wintellect.PowerCollections.ListBase-1.html#Wintellect_PowerCollections_ListBase_1_System_Collections_IList_Remove_System_Object_">ListBase&lt;T&gt;.IList.Remove(Object)</a>
    </div>
    <div>
      <a class="xref" href="Wintellect.PowerCollections.ListBase-1.html#Wintellect_PowerCollections_ListBase_1_System_Collections_IList_RemoveAt_System_Int32_">ListBase&lt;T&gt;.IList.RemoveAt(Int32)</a>
    </div>
    <div>
      <a class="xref" href="Wintellect.PowerCollections.ListBase-1.html#Wintellect_PowerCollections_ListBase_1_System_Collections_IList_Item_System_Int32_">ListBase&lt;T&gt;.IList.Item[Int32]</a>
    </div>
    <div>
      <a class="xref" href="Wintellect.PowerCollections.CollectionBase-1.html#Wintellect_PowerCollections_CollectionBase_1_ToString">CollectionBase&lt;T&gt;.ToString()</a>
    </div>
    <div>
      <a class="xref" href="Wintellect.PowerCollections.CollectionBase-1.html#Wintellect_PowerCollections_CollectionBase_1_CopyTo__0___System_Int32_">CollectionBase&lt;T&gt;.CopyTo(T[], Int32)</a>
    </div>
    <div>
      <a class="xref" href="Wintellect.PowerCollections.CollectionBase-1.html#Wintellect_PowerCollections_CollectionBase_1_ToArray">CollectionBase&lt;T&gt;.ToArray()</a>
    </div>
    <div>
      <a class="xref" href="Wintellect.PowerCollections.CollectionBase-1.html#Wintellect_PowerCollections_CollectionBase_1_System_Collections_Generic_ICollection_T__IsReadOnly">CollectionBase&lt;T&gt;.ICollection&lt;T&gt;.IsReadOnly</a>
    </div>
    <div>
      <a class="xref" href="Wintellect.PowerCollections.CollectionBase-1.html#Wintellect_PowerCollections_CollectionBase_1_Exists_System_Predicate__0__">CollectionBase&lt;T&gt;.Exists(Predicate&lt;T&gt;)</a>
    </div>
    <div>
      <a class="xref" href="Wintellect.PowerCollections.CollectionBase-1.html#Wintellect_PowerCollections_CollectionBase_1_TrueForAll_System_Predicate__0__">CollectionBase&lt;T&gt;.TrueForAll(Predicate&lt;T&gt;)</a>
    </div>
    <div>
      <a class="xref" href="Wintellect.PowerCollections.CollectionBase-1.html#Wintellect_PowerCollections_CollectionBase_1_CountWhere_System_Predicate__0__">CollectionBase&lt;T&gt;.CountWhere(Predicate&lt;T&gt;)</a>
    </div>
    <div>
      <a class="xref" href="Wintellect.PowerCollections.CollectionBase-1.html#Wintellect_PowerCollections_CollectionBase_1_FindAll_System_Predicate__0__">CollectionBase&lt;T&gt;.FindAll(Predicate&lt;T&gt;)</a>
    </div>
    <div>
      <a class="xref" href="Wintellect.PowerCollections.CollectionBase-1.html#Wintellect_PowerCollections_CollectionBase_1_RemoveAll_System_Predicate__0__">CollectionBase&lt;T&gt;.RemoveAll(Predicate&lt;T&gt;)</a>
    </div>
    <div>
      <a class="xref" href="Wintellect.PowerCollections.CollectionBase-1.html#Wintellect_PowerCollections_CollectionBase_1_ForEach_System_Action__0__">CollectionBase&lt;T&gt;.ForEach(Action&lt;T&gt;)</a>
    </div>
    <div>
      <a class="xref" href="Wintellect.PowerCollections.CollectionBase-1.html#Wintellect_PowerCollections_CollectionBase_1_ConvertAll__1_System_Converter__0___0__">CollectionBase&lt;T&gt;.ConvertAll&lt;TOutput&gt;(Converter&lt;T, TOutput&gt;)</a>
    </div>
    <div>
      <a class="xref" href="Wintellect.PowerCollections.CollectionBase-1.html#Wintellect_PowerCollections_CollectionBase_1_System_Collections_ICollection_CopyTo_System_Array_System_Int32_">CollectionBase&lt;T&gt;.ICollection.CopyTo(Array, Int32)</a>
    </div>
    <div>
      <a class="xref" href="Wintellect.PowerCollections.CollectionBase-1.html#Wintellect_PowerCollections_CollectionBase_1_System_Collections_ICollection_IsSynchronized">CollectionBase&lt;T&gt;.ICollection.IsSynchronized</a>
    </div>
    <div>
      <a class="xref" href="Wintellect.PowerCollections.CollectionBase-1.html#Wintellect_PowerCollections_CollectionBase_1_System_Collections_ICollection_SyncRoot">CollectionBase&lt;T&gt;.ICollection.SyncRoot</a>
    </div>
    <div>
      <a class="xref" href="Wintellect.PowerCollections.CollectionBase-1.html#Wintellect_PowerCollections_CollectionBase_1_System_Collections_IEnumerable_GetEnumerator">CollectionBase&lt;T&gt;.IEnumerable.GetEnumerator()</a>
    </div>
    <div>
      <span class="xref">System.Object.Equals(System.Object)</span>
    </div>
    <div>
      <span class="xref">System.Object.Equals(System.Object, System.Object)</span>
    </div>
    <div>
      <span class="xref">System.Object.ReferenceEquals(System.Object, System.Object)</span>
    </div>
    <div>
      <span class="xref">System.Object.GetHashCode()</span>
    </div>
    <div>
      <span class="xref">System.Object.GetType()</span>
    </div>
    <div>
      <span class="xref">System.Object.MemberwiseClone()</span>
    </div>
  </div>
  <h6><strong>Namespace</strong>: <a class="xref" href="Wintellect.PowerCollections.html">Wintellect.PowerCollections</a></h6>
  <h6><strong>Assembly</strong>: cs.temp.dll.dll</h6>
  <h5 id="Wintellect_PowerCollections_BigList_1_syntax">Syntax</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Serializable]
[Serializable]
public class BigList&lt;T&gt; : ListBase&lt;T&gt;, IList&lt;T&gt;, ICollection&lt;T&gt;, IEnumerable&lt;T&gt;, IList, ICollection, IEnumerable, ICloneable</code></pre>
  </div>
  <h5 class="typeParameters">Type Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="parametername">T</span></td>
        <td><p>The type of items to store in the BigList.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="Wintellect_PowerCollections_BigList_1_remarks"><strong>Remarks</strong></h5>
  <div class="markdown level0 remarks"><p>BigList&lt;T> class is similar in functionality to the standard List&lt;T> class. Both classes
provide a collection that stores an set of items in order, with indices of the items ranging from 0 to one less
than the count of items in the collection. Both classes provide the ability to add and remove items from any index,
and the get or set the item at any index.</p> 
<p>BigList&lt;T> differs significantly from List&lt;T> in the performance of various operations, 
especially when the lists become large (several hundred items or more). With List&lt;T>, inserting or removing
elements from anywhere in a large list except the end is very inefficient -- every item after the point of inserting
or deletion has to be moved in the list. The BigList&lt;T> class, however, allows for fast insertions
and deletions anywhere in the list. Furthermore, BigList&lt;T> allows copies of a list, sub-parts
of a list, and concatinations of two lists to be very fast. When a copy is made of part or all of a BigList,
two lists shared storage for the parts of the lists that are the same. Only when one of the lists is changed is additional
memory allocated to store the distinct parts of the lists.</p>
<p>Of course, there is a small price to pay for this extra flexibility. Although still quite efficient, using an 
index to get or change one element of a BigList, while still reasonably efficient, is significantly slower than using
a plain List. Because of this, if you want to process every element of a BigList, using a foreach loop is a lot
more efficient than using a for loop and indexing the list.</p>
<p>In general, use a List when the only operations you are using are Add (to the end), foreach,
or indexing, or you are very sure the list will always remain small (less than 100 items). For large (>100 items) lists
that do insertions, removals, copies, concatinations, or sub-ranges, BigList will be more efficient than List. 
In almost all cases, BigList is more efficient and easier to use than LinkedList.</p>
</div>
  <h3 id="constructors">Constructors
  </h3>
  
  
  <a id="Wintellect_PowerCollections_BigList_1__ctor_" data-uid="Wintellect.PowerCollections.BigList`1.#ctor*"></a>
  <h4 id="Wintellect_PowerCollections_BigList_1__ctor" data-uid="Wintellect.PowerCollections.BigList`1.#ctor">BigList()</h4>
  <div class="markdown level1 summary"><p>Creates a new BigList. The BigList is initially empty.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public BigList()</code></pre>
  </div>
  <h5 id="Wintellect_PowerCollections_BigList_1__ctor_remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>Creating a empty BigList takes constant time and consumes a very small amount of memory.</p>
</div>
  
  
  <a id="Wintellect_PowerCollections_BigList_1__ctor_" data-uid="Wintellect.PowerCollections.BigList`1.#ctor*"></a>
  <h4 id="Wintellect_PowerCollections_BigList_1__ctor" data-uid="Wintellect.PowerCollections.BigList`1.#ctor">BigList()</h4>
  <div class="markdown level1 summary"><p>Creates a new BigList. The BigList is initially empty.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public BigList()</code></pre>
  </div>
  <h5 id="Wintellect_PowerCollections_BigList_1__ctor_remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>Creating a empty BigList takes constant time and consumes a very small amount of memory.</p>
</div>
  
  
  <a id="Wintellect_PowerCollections_BigList_1__ctor_" data-uid="Wintellect.PowerCollections.BigList`1.#ctor*"></a>
  <h4 id="Wintellect_PowerCollections_BigList_1__ctor_System_Collections_Generic_IEnumerable__0__" data-uid="Wintellect.PowerCollections.BigList`1.#ctor(System.Collections.Generic.IEnumerable{`0})">BigList(IEnumerable&lt;T&gt;)</h4>
  <div class="markdown level1 summary"><p>Creates a new BigList initialized with the items from <code data-dev-comment-type="paramref" class="paramref">collection</code>, in order.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public BigList(IEnumerable&lt;T&gt; collection)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Collections.Generic.IEnumerable</span>&lt;T&gt;</td>
        <td><span class="parametername">collection</span></td>
        <td><p>The collection used to initialize the BigList.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="Wintellect_PowerCollections_BigList_1__ctor_System_Collections_Generic_IEnumerable__0___remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>Initializing the tree list with the elements of collection takes time O(N), where N is the number of
items in <code data-dev-comment-type="paramref" class="paramref">collection</code>.</p>
</div>
  <h5 class="exceptions">Exceptions</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Condition</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.ArgumentNullException</span></td>
        <td><p><code data-dev-comment-type="paramref" class="paramref">collection</code> is null.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Wintellect_PowerCollections_BigList_1__ctor_" data-uid="Wintellect.PowerCollections.BigList`1.#ctor*"></a>
  <h4 id="Wintellect_PowerCollections_BigList_1__ctor_System_Collections_Generic_IEnumerable__0__" data-uid="Wintellect.PowerCollections.BigList`1.#ctor(System.Collections.Generic.IEnumerable{`0})">BigList(IEnumerable&lt;T&gt;)</h4>
  <div class="markdown level1 summary"><p>Creates a new BigList initialized with the items from <code data-dev-comment-type="paramref" class="paramref">collection</code>, in order.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public BigList(IEnumerable&lt;T&gt; collection)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Collections.Generic.IEnumerable</span>&lt;T&gt;</td>
        <td><span class="parametername">collection</span></td>
        <td><p>The collection used to initialize the BigList.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="Wintellect_PowerCollections_BigList_1__ctor_System_Collections_Generic_IEnumerable__0___remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>Initializing the tree list with the elements of collection takes time O(N), where N is the number of
items in <code data-dev-comment-type="paramref" class="paramref">collection</code>.</p>
</div>
  <h5 class="exceptions">Exceptions</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Condition</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.ArgumentNullException</span></td>
        <td><p><code data-dev-comment-type="paramref" class="paramref">collection</code> is null.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Wintellect_PowerCollections_BigList_1__ctor_" data-uid="Wintellect.PowerCollections.BigList`1.#ctor*"></a>
  <h4 id="Wintellect_PowerCollections_BigList_1__ctor_System_Collections_Generic_IEnumerable__0__System_Int32_" data-uid="Wintellect.PowerCollections.BigList`1.#ctor(System.Collections.Generic.IEnumerable{`0},System.Int32)">BigList(IEnumerable&lt;T&gt;, Int32)</h4>
  <div class="markdown level1 summary"><p>Creates a new BigList initialized with a given number of copies of the items from <code data-dev-comment-type="paramref" class="paramref">collection</code>, in order.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public BigList(IEnumerable&lt;T&gt; collection, int copies)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Collections.Generic.IEnumerable</span>&lt;T&gt;</td>
        <td><span class="parametername">collection</span></td>
        <td><p>The collection used to initialize the BigList.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Int32</span></td>
        <td><span class="parametername">copies</span></td>
        <td><p>Number of copies of the collection to use.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="Wintellect_PowerCollections_BigList_1__ctor_System_Collections_Generic_IEnumerable__0__System_Int32__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>Initializing the tree list with the elements of collection takes time O(N + log K), where N is the number of
items in <code data-dev-comment-type="paramref" class="paramref">collection</code>, and K is the number of copies.</p>
</div>
  <h5 class="exceptions">Exceptions</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Condition</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.ArgumentOutOfRangeException</span></td>
        <td><p><code data-dev-comment-type="paramref" class="paramref">copies</code> is negative.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.ArgumentNullException</span></td>
        <td><p><code data-dev-comment-type="paramref" class="paramref">collection</code> is null.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Wintellect_PowerCollections_BigList_1__ctor_" data-uid="Wintellect.PowerCollections.BigList`1.#ctor*"></a>
  <h4 id="Wintellect_PowerCollections_BigList_1__ctor_System_Collections_Generic_IEnumerable__0__System_Int32_" data-uid="Wintellect.PowerCollections.BigList`1.#ctor(System.Collections.Generic.IEnumerable{`0},System.Int32)">BigList(IEnumerable&lt;T&gt;, Int32)</h4>
  <div class="markdown level1 summary"><p>Creates a new BigList initialized with a given number of copies of the items from <code data-dev-comment-type="paramref" class="paramref">collection</code>, in order.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public BigList(IEnumerable&lt;T&gt; collection, int copies)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Collections.Generic.IEnumerable</span>&lt;T&gt;</td>
        <td><span class="parametername">collection</span></td>
        <td><p>The collection used to initialize the BigList.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Int32</span></td>
        <td><span class="parametername">copies</span></td>
        <td><p>Number of copies of the collection to use.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="Wintellect_PowerCollections_BigList_1__ctor_System_Collections_Generic_IEnumerable__0__System_Int32__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>Initializing the tree list with the elements of collection takes time O(N + log K), where N is the number of
items in <code data-dev-comment-type="paramref" class="paramref">collection</code>, and K is the number of copies.</p>
</div>
  <h5 class="exceptions">Exceptions</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Condition</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.ArgumentOutOfRangeException</span></td>
        <td><p><code data-dev-comment-type="paramref" class="paramref">copies</code> is negative.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.ArgumentNullException</span></td>
        <td><p><code data-dev-comment-type="paramref" class="paramref">collection</code> is null.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Wintellect_PowerCollections_BigList_1__ctor_" data-uid="Wintellect.PowerCollections.BigList`1.#ctor*"></a>
  <h4 id="Wintellect_PowerCollections_BigList_1__ctor_Wintellect_PowerCollections_BigList__0__" data-uid="Wintellect.PowerCollections.BigList`1.#ctor(Wintellect.PowerCollections.BigList{`0})">BigList(BigList&lt;T&gt;)</h4>
  <div class="markdown level1 summary"><p>Creates a new BigList that is a copy of <code data-dev-comment-type="paramref" class="paramref">list</code>.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public BigList(BigList&lt;T&gt; list)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Wintellect.PowerCollections.BigList-1.html">BigList</a>&lt;T&gt;</td>
        <td><span class="parametername">list</span></td>
        <td><p>The BigList to copy.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="Wintellect_PowerCollections_BigList_1__ctor_Wintellect_PowerCollections_BigList__0___remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>Copying a BigList takes constant time, and little
additional memory, since the storage for the items of the two lists is shared. However, changing
either list will take additional time and memory. Portions of the list are copied when they are changed.</p>
</div>
  <h5 class="exceptions">Exceptions</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Condition</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.ArgumentNullException</span></td>
        <td><p><code data-dev-comment-type="paramref" class="paramref">list</code> is null.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Wintellect_PowerCollections_BigList_1__ctor_" data-uid="Wintellect.PowerCollections.BigList`1.#ctor*"></a>
  <h4 id="Wintellect_PowerCollections_BigList_1__ctor_Wintellect_PowerCollections_BigList__0__" data-uid="Wintellect.PowerCollections.BigList`1.#ctor(Wintellect.PowerCollections.BigList{`0})">BigList(BigList&lt;T&gt;)</h4>
  <div class="markdown level1 summary"><p>Creates a new BigList that is a copy of <code data-dev-comment-type="paramref" class="paramref">list</code>.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public BigList(BigList&lt;T&gt; list)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Wintellect.PowerCollections.BigList-1.html">BigList</a>&lt;T&gt;</td>
        <td><span class="parametername">list</span></td>
        <td><p>The BigList to copy.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="Wintellect_PowerCollections_BigList_1__ctor_Wintellect_PowerCollections_BigList__0___remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>Copying a BigList takes constant time, and little
additional memory, since the storage for the items of the two lists is shared. However, changing
either list will take additional time and memory. Portions of the list are copied when they are changed.</p>
</div>
  <h5 class="exceptions">Exceptions</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Condition</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.ArgumentNullException</span></td>
        <td><p><code data-dev-comment-type="paramref" class="paramref">list</code> is null.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Wintellect_PowerCollections_BigList_1__ctor_" data-uid="Wintellect.PowerCollections.BigList`1.#ctor*"></a>
  <h4 id="Wintellect_PowerCollections_BigList_1__ctor_Wintellect_PowerCollections_BigList__0__System_Int32_" data-uid="Wintellect.PowerCollections.BigList`1.#ctor(Wintellect.PowerCollections.BigList{`0},System.Int32)">BigList(BigList&lt;T&gt;, Int32)</h4>
  <div class="markdown level1 summary"><p>Creates a new BigList that is several copies of <code data-dev-comment-type="paramref" class="paramref">list</code>.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public BigList(BigList&lt;T&gt; list, int copies)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Wintellect.PowerCollections.BigList-1.html">BigList</a>&lt;T&gt;</td>
        <td><span class="parametername">list</span></td>
        <td><p>The BigList to copy.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Int32</span></td>
        <td><span class="parametername">copies</span></td>
        <td><p>Number of copies of the collection to use.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="Wintellect_PowerCollections_BigList_1__ctor_Wintellect_PowerCollections_BigList__0__System_Int32__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>Creating K copies of a BigList takes time O(log K), and O(log K)
additional memory, since the storage for the items of the two lists is shared. However, changing
either list will take additional time and memory. Portions of the list are copied when they are changed.</p>
</div>
  <h5 class="exceptions">Exceptions</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Condition</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.ArgumentNullException</span></td>
        <td><p><code data-dev-comment-type="paramref" class="paramref">list</code> is null.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Wintellect_PowerCollections_BigList_1__ctor_" data-uid="Wintellect.PowerCollections.BigList`1.#ctor*"></a>
  <h4 id="Wintellect_PowerCollections_BigList_1__ctor_Wintellect_PowerCollections_BigList__0__System_Int32_" data-uid="Wintellect.PowerCollections.BigList`1.#ctor(Wintellect.PowerCollections.BigList{`0},System.Int32)">BigList(BigList&lt;T&gt;, Int32)</h4>
  <div class="markdown level1 summary"><p>Creates a new BigList that is several copies of <code data-dev-comment-type="paramref" class="paramref">list</code>.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public BigList(BigList&lt;T&gt; list, int copies)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Wintellect.PowerCollections.BigList-1.html">BigList</a>&lt;T&gt;</td>
        <td><span class="parametername">list</span></td>
        <td><p>The BigList to copy.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Int32</span></td>
        <td><span class="parametername">copies</span></td>
        <td><p>Number of copies of the collection to use.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="Wintellect_PowerCollections_BigList_1__ctor_Wintellect_PowerCollections_BigList__0__System_Int32__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>Creating K copies of a BigList takes time O(log K), and O(log K)
additional memory, since the storage for the items of the two lists is shared. However, changing
either list will take additional time and memory. Portions of the list are copied when they are changed.</p>
</div>
  <h5 class="exceptions">Exceptions</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Condition</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.ArgumentNullException</span></td>
        <td><p><code data-dev-comment-type="paramref" class="paramref">list</code> is null.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h3 id="properties">Properties
  </h3>
  
  
  <a id="Wintellect_PowerCollections_BigList_1_Count_" data-uid="Wintellect.PowerCollections.BigList`1.Count*"></a>
  <h4 id="Wintellect_PowerCollections_BigList_1_Count" data-uid="Wintellect.PowerCollections.BigList`1.Count">Count</h4>
  <div class="markdown level1 summary"><p>Gets the number of items stored in the BigList. The indices of the items
range from 0 to Count-1.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public sealed override int Count { get; }</code></pre>
  </div>
  <h5 class="propertyValue">Property Value</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Int32</span></td>
        <td><p>The number of items in the BigList.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="overrides">Overrides</h5>
  <div><span class="xref">Wintellect.PowerCollections.ListBase&lt;T&gt;.Count</span></div>
  <h5 id="Wintellect_PowerCollections_BigList_1_Count_remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>Getting the number of items in the BigList takes constant time.</p>
</div>
  
  
  <a id="Wintellect_PowerCollections_BigList_1_Count_" data-uid="Wintellect.PowerCollections.BigList`1.Count*"></a>
  <h4 id="Wintellect_PowerCollections_BigList_1_Count" data-uid="Wintellect.PowerCollections.BigList`1.Count">Count</h4>
  <div class="markdown level1 summary"><p>Gets the number of items stored in the BigList. The indices of the items
range from 0 to Count-1.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public sealed override int Count { get; }</code></pre>
  </div>
  <h5 class="propertyValue">Property Value</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Int32</span></td>
        <td><p>The number of items in the BigList.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="overrides">Overrides</h5>
  <div><span class="xref">Wintellect.PowerCollections.ListBase&lt;T&gt;.Count</span></div>
  <h5 id="Wintellect_PowerCollections_BigList_1_Count_remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>Getting the number of items in the BigList takes constant time.</p>
</div>
  
  
  <a id="Wintellect_PowerCollections_BigList_1_Item_" data-uid="Wintellect.PowerCollections.BigList`1.Item*"></a>
  <h4 id="Wintellect_PowerCollections_BigList_1_Item_System_Int32_" data-uid="Wintellect.PowerCollections.BigList`1.Item(System.Int32)">Item[Int32]</h4>
  <div class="markdown level1 summary"><p>Gets or sets an item in the list, by index.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public sealed override T this[int index] { get; set; }</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Int32</span></td>
        <td><span class="parametername">index</span></td>
        <td><p>The index of the item to get or set. The first item in the list
has index 0, the last item has index Count-1.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="propertyValue">Property Value</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">T</span></td>
        <td><p>The value of the item at the given index.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="overrides">Overrides</h5>
  <div><span class="xref">Wintellect.PowerCollections.ListBase&lt;T&gt;.Item[System.Int32]</span></div>
  <h5 id="Wintellect_PowerCollections_BigList_1_Item_System_Int32__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p> Gettingor setting an item takes time O(log N), where N is the number of items
    in the list.</p>
<p>To process each of the items in the list, using GetEnumerator() or a foreach loop is more efficient
that accessing each of the elements by index.</p>
</div>
  <h5 class="exceptions">Exceptions</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Condition</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.ArgumentOutOfRangeException</span></td>
        <td><p><code data-dev-comment-type="paramref" class="paramref">index</code> is less than zero or
greater than or equal to Count.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Wintellect_PowerCollections_BigList_1_Item_" data-uid="Wintellect.PowerCollections.BigList`1.Item*"></a>
  <h4 id="Wintellect_PowerCollections_BigList_1_Item_System_Int32_" data-uid="Wintellect.PowerCollections.BigList`1.Item(System.Int32)">Item[Int32]</h4>
  <div class="markdown level1 summary"><p>Gets or sets an item in the list, by index.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public sealed override T this[int index] { get; set; }</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Int32</span></td>
        <td><span class="parametername">index</span></td>
        <td><p>The index of the item to get or set. The first item in the list
has index 0, the last item has index Count-1.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="propertyValue">Property Value</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">T</span></td>
        <td><p>The value of the item at the given index.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="overrides">Overrides</h5>
  <div><span class="xref">Wintellect.PowerCollections.ListBase&lt;T&gt;.Item[System.Int32]</span></div>
  <h5 id="Wintellect_PowerCollections_BigList_1_Item_System_Int32__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p> Gettingor setting an item takes time O(log N), where N is the number of items
    in the list.</p>
<p>To process each of the items in the list, using GetEnumerator() or a foreach loop is more efficient
that accessing each of the elements by index.</p>
</div>
  <h5 class="exceptions">Exceptions</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Condition</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.ArgumentOutOfRangeException</span></td>
        <td><p><code data-dev-comment-type="paramref" class="paramref">index</code> is less than zero or
greater than or equal to Count.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h3 id="methods">Methods
  </h3>
  
  
  <a id="Wintellect_PowerCollections_BigList_1_Add_" data-uid="Wintellect.PowerCollections.BigList`1.Add*"></a>
  <h4 id="Wintellect_PowerCollections_BigList_1_Add__0_" data-uid="Wintellect.PowerCollections.BigList`1.Add(`0)">Add(T)</h4>
  <div class="markdown level1 summary"><p>Adds an item to the end of the BigList. The indices of all existing items
in the Deque are unchanged.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public sealed override void Add(T item)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">T</span></td>
        <td><span class="parametername">item</span></td>
        <td><p>The item to add.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="overrides">Overrides</h5>
  <div><span class="xref">Wintellect.PowerCollections.ListBase&lt;T&gt;.Add(T)</span></div>
  <h5 id="Wintellect_PowerCollections_BigList_1_Add__0__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>Adding an item takes, on average, constant time.</p>
</div>
  
  
  <a id="Wintellect_PowerCollections_BigList_1_Add_" data-uid="Wintellect.PowerCollections.BigList`1.Add*"></a>
  <h4 id="Wintellect_PowerCollections_BigList_1_Add__0_" data-uid="Wintellect.PowerCollections.BigList`1.Add(`0)">Add(T)</h4>
  <div class="markdown level1 summary"><p>Adds an item to the end of the BigList. The indices of all existing items
in the Deque are unchanged.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public sealed override void Add(T item)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">T</span></td>
        <td><span class="parametername">item</span></td>
        <td><p>The item to add.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="overrides">Overrides</h5>
  <div><span class="xref">Wintellect.PowerCollections.ListBase&lt;T&gt;.Add(T)</span></div>
  <h5 id="Wintellect_PowerCollections_BigList_1_Add__0__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>Adding an item takes, on average, constant time.</p>
</div>
  
  
  <a id="Wintellect_PowerCollections_BigList_1_AddRange_" data-uid="Wintellect.PowerCollections.BigList`1.AddRange*"></a>
  <h4 id="Wintellect_PowerCollections_BigList_1_AddRange_System_Collections_Generic_IEnumerable__0__" data-uid="Wintellect.PowerCollections.BigList`1.AddRange(System.Collections.Generic.IEnumerable{`0})">AddRange(IEnumerable&lt;T&gt;)</h4>
  <div class="markdown level1 summary"><p>Adds a collection of items to the end of BigList. The indices of all existing items
are unchanged. The last item in the added collection becomes the
last item in the BigList.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public void AddRange(IEnumerable&lt;T&gt; collection)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Collections.Generic.IEnumerable</span>&lt;T&gt;</td>
        <td><span class="parametername">collection</span></td>
        <td><p>The collection of items to add.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="Wintellect_PowerCollections_BigList_1_AddRange_System_Collections_Generic_IEnumerable__0___remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>This method takes time O(M + log N), where M is the number of items in the
<code data-dev-comment-type="paramref" class="paramref">collection</code>, and N is the size of the BigList.</p>
</div>
  <h5 class="exceptions">Exceptions</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Condition</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.ArgumentNullException</span></td>
        <td><p><code data-dev-comment-type="paramref" class="paramref">collection</code> is null.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Wintellect_PowerCollections_BigList_1_AddRange_" data-uid="Wintellect.PowerCollections.BigList`1.AddRange*"></a>
  <h4 id="Wintellect_PowerCollections_BigList_1_AddRange_System_Collections_Generic_IEnumerable__0__" data-uid="Wintellect.PowerCollections.BigList`1.AddRange(System.Collections.Generic.IEnumerable{`0})">AddRange(IEnumerable&lt;T&gt;)</h4>
  <div class="markdown level1 summary"><p>Adds a collection of items to the end of BigList. The indices of all existing items
are unchanged. The last item in the added collection becomes the
last item in the BigList.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public void AddRange(IEnumerable&lt;T&gt; collection)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Collections.Generic.IEnumerable</span>&lt;T&gt;</td>
        <td><span class="parametername">collection</span></td>
        <td><p>The collection of items to add.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="Wintellect_PowerCollections_BigList_1_AddRange_System_Collections_Generic_IEnumerable__0___remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>This method takes time O(M + log N), where M is the number of items in the
<code data-dev-comment-type="paramref" class="paramref">collection</code>, and N is the size of the BigList.</p>
</div>
  <h5 class="exceptions">Exceptions</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Condition</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.ArgumentNullException</span></td>
        <td><p><code data-dev-comment-type="paramref" class="paramref">collection</code> is null.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Wintellect_PowerCollections_BigList_1_AddRange_" data-uid="Wintellect.PowerCollections.BigList`1.AddRange*"></a>
  <h4 id="Wintellect_PowerCollections_BigList_1_AddRange_Wintellect_PowerCollections_BigList__0__" data-uid="Wintellect.PowerCollections.BigList`1.AddRange(Wintellect.PowerCollections.BigList{`0})">AddRange(BigList&lt;T&gt;)</h4>
  <div class="markdown level1 summary"><p>Adds a BigList of items to the end of BigList. The indices of all existing items
are unchanged. The last item in <code data-dev-comment-type="paramref" class="paramref">list</code> becomes the
last item in this list. The added list <code data-dev-comment-type="paramref" class="paramref">list</code> is unchanged.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public void AddRange(BigList&lt;T&gt; list)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Wintellect.PowerCollections.BigList-1.html">BigList</a>&lt;T&gt;</td>
        <td><span class="parametername">list</span></td>
        <td><p>The list of items to add.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="Wintellect_PowerCollections_BigList_1_AddRange_Wintellect_PowerCollections_BigList__0___remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>This method takes, on average, constant time, regardless of the size
of either list. Although conceptually all of the items in <code data-dev-comment-type="paramref" class="paramref">list</code> are
copied, storage is shared between the two lists until changes are made to the
shared sections.</p>
</div>
  <h5 class="exceptions">Exceptions</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Condition</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.ArgumentNullException</span></td>
        <td><p><code data-dev-comment-type="paramref" class="paramref">list</code> is null.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Wintellect_PowerCollections_BigList_1_AddRange_" data-uid="Wintellect.PowerCollections.BigList`1.AddRange*"></a>
  <h4 id="Wintellect_PowerCollections_BigList_1_AddRange_Wintellect_PowerCollections_BigList__0__" data-uid="Wintellect.PowerCollections.BigList`1.AddRange(Wintellect.PowerCollections.BigList{`0})">AddRange(BigList&lt;T&gt;)</h4>
  <div class="markdown level1 summary"><p>Adds a BigList of items to the end of BigList. The indices of all existing items
are unchanged. The last item in <code data-dev-comment-type="paramref" class="paramref">list</code> becomes the
last item in this list. The added list <code data-dev-comment-type="paramref" class="paramref">list</code> is unchanged.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public void AddRange(BigList&lt;T&gt; list)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Wintellect.PowerCollections.BigList-1.html">BigList</a>&lt;T&gt;</td>
        <td><span class="parametername">list</span></td>
        <td><p>The list of items to add.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="Wintellect_PowerCollections_BigList_1_AddRange_Wintellect_PowerCollections_BigList__0___remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>This method takes, on average, constant time, regardless of the size
of either list. Although conceptually all of the items in <code data-dev-comment-type="paramref" class="paramref">list</code> are
copied, storage is shared between the two lists until changes are made to the
shared sections.</p>
</div>
  <h5 class="exceptions">Exceptions</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Condition</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.ArgumentNullException</span></td>
        <td><p><code data-dev-comment-type="paramref" class="paramref">list</code> is null.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Wintellect_PowerCollections_BigList_1_AddRangeToFront_" data-uid="Wintellect.PowerCollections.BigList`1.AddRangeToFront*"></a>
  <h4 id="Wintellect_PowerCollections_BigList_1_AddRangeToFront_System_Collections_Generic_IEnumerable__0__" data-uid="Wintellect.PowerCollections.BigList`1.AddRangeToFront(System.Collections.Generic.IEnumerable{`0})">AddRangeToFront(IEnumerable&lt;T&gt;)</h4>
  <div class="markdown level1 summary"><p>Adds a collection of items to the front of BigList. The indices of all existing items
in the are increased by the number of items in <code data-dev-comment-type="paramref" class="paramref">collection</code>.
The first item in the added collection becomes the first item in the BigList.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public void AddRangeToFront(IEnumerable&lt;T&gt; collection)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Collections.Generic.IEnumerable</span>&lt;T&gt;</td>
        <td><span class="parametername">collection</span></td>
        <td><p>The collection of items to add.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="Wintellect_PowerCollections_BigList_1_AddRangeToFront_System_Collections_Generic_IEnumerable__0___remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>This method takes time O(M + log N), where M is the number of items in the
<code data-dev-comment-type="paramref" class="paramref">collection</code>, and N is the size of the BigList.</p>
</div>
  <h5 class="exceptions">Exceptions</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Condition</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.ArgumentNullException</span></td>
        <td><p><code data-dev-comment-type="paramref" class="paramref">collection</code> is null.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Wintellect_PowerCollections_BigList_1_AddRangeToFront_" data-uid="Wintellect.PowerCollections.BigList`1.AddRangeToFront*"></a>
  <h4 id="Wintellect_PowerCollections_BigList_1_AddRangeToFront_System_Collections_Generic_IEnumerable__0__" data-uid="Wintellect.PowerCollections.BigList`1.AddRangeToFront(System.Collections.Generic.IEnumerable{`0})">AddRangeToFront(IEnumerable&lt;T&gt;)</h4>
  <div class="markdown level1 summary"><p>Adds a collection of items to the front of BigList. The indices of all existing items
in the are increased by the number of items in <code data-dev-comment-type="paramref" class="paramref">collection</code>.
The first item in the added collection becomes the first item in the BigList.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public void AddRangeToFront(IEnumerable&lt;T&gt; collection)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Collections.Generic.IEnumerable</span>&lt;T&gt;</td>
        <td><span class="parametername">collection</span></td>
        <td><p>The collection of items to add.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="Wintellect_PowerCollections_BigList_1_AddRangeToFront_System_Collections_Generic_IEnumerable__0___remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>This method takes time O(M + log N), where M is the number of items in the
<code data-dev-comment-type="paramref" class="paramref">collection</code>, and N is the size of the BigList.</p>
</div>
  <h5 class="exceptions">Exceptions</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Condition</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.ArgumentNullException</span></td>
        <td><p><code data-dev-comment-type="paramref" class="paramref">collection</code> is null.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Wintellect_PowerCollections_BigList_1_AddRangeToFront_" data-uid="Wintellect.PowerCollections.BigList`1.AddRangeToFront*"></a>
  <h4 id="Wintellect_PowerCollections_BigList_1_AddRangeToFront_Wintellect_PowerCollections_BigList__0__" data-uid="Wintellect.PowerCollections.BigList`1.AddRangeToFront(Wintellect.PowerCollections.BigList{`0})">AddRangeToFront(BigList&lt;T&gt;)</h4>
  <div class="markdown level1 summary"><p>Adds a BigList of items to the front of BigList. The indices of all existing items
are increased by the number of items in <code data-dev-comment-type="paramref" class="paramref">list</code>. The first item in <code data-dev-comment-type="paramref" class="paramref">list</code>
becomes the first item in this list. The added list <code data-dev-comment-type="paramref" class="paramref">list</code> is unchanged.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public void AddRangeToFront(BigList&lt;T&gt; list)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Wintellect.PowerCollections.BigList-1.html">BigList</a>&lt;T&gt;</td>
        <td><span class="parametername">list</span></td>
        <td><p>The list of items to add.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="Wintellect_PowerCollections_BigList_1_AddRangeToFront_Wintellect_PowerCollections_BigList__0___remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>This method takes, on average, constant time, regardless of the size
of either list. Although conceptually all of the items in <code data-dev-comment-type="paramref" class="paramref">list</code> are
copied, storage is shared between the two lists until changes are made to the
shared sections.</p>
</div>
  <h5 class="exceptions">Exceptions</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Condition</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.ArgumentNullException</span></td>
        <td><p><code data-dev-comment-type="paramref" class="paramref">list</code> is null.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Wintellect_PowerCollections_BigList_1_AddRangeToFront_" data-uid="Wintellect.PowerCollections.BigList`1.AddRangeToFront*"></a>
  <h4 id="Wintellect_PowerCollections_BigList_1_AddRangeToFront_Wintellect_PowerCollections_BigList__0__" data-uid="Wintellect.PowerCollections.BigList`1.AddRangeToFront(Wintellect.PowerCollections.BigList{`0})">AddRangeToFront(BigList&lt;T&gt;)</h4>
  <div class="markdown level1 summary"><p>Adds a BigList of items to the front of BigList. The indices of all existing items
are increased by the number of items in <code data-dev-comment-type="paramref" class="paramref">list</code>. The first item in <code data-dev-comment-type="paramref" class="paramref">list</code>
becomes the first item in this list. The added list <code data-dev-comment-type="paramref" class="paramref">list</code> is unchanged.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public void AddRangeToFront(BigList&lt;T&gt; list)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Wintellect.PowerCollections.BigList-1.html">BigList</a>&lt;T&gt;</td>
        <td><span class="parametername">list</span></td>
        <td><p>The list of items to add.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="Wintellect_PowerCollections_BigList_1_AddRangeToFront_Wintellect_PowerCollections_BigList__0___remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>This method takes, on average, constant time, regardless of the size
of either list. Although conceptually all of the items in <code data-dev-comment-type="paramref" class="paramref">list</code> are
copied, storage is shared between the two lists until changes are made to the
shared sections.</p>
</div>
  <h5 class="exceptions">Exceptions</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Condition</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.ArgumentNullException</span></td>
        <td><p><code data-dev-comment-type="paramref" class="paramref">list</code> is null.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Wintellect_PowerCollections_BigList_1_AddToFront_" data-uid="Wintellect.PowerCollections.BigList`1.AddToFront*"></a>
  <h4 id="Wintellect_PowerCollections_BigList_1_AddToFront__0_" data-uid="Wintellect.PowerCollections.BigList`1.AddToFront(`0)">AddToFront(T)</h4>
  <div class="markdown level1 summary"><p>Adds an item to the beginning of the BigList. The indices of all existing items
in the Deque are increased by one, and the new item has index zero.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public void AddToFront(T item)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">T</span></td>
        <td><span class="parametername">item</span></td>
        <td><p>The item to add.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="Wintellect_PowerCollections_BigList_1_AddToFront__0__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>Adding an item takes, on average, constant time.</p>
</div>
  
  
  <a id="Wintellect_PowerCollections_BigList_1_AddToFront_" data-uid="Wintellect.PowerCollections.BigList`1.AddToFront*"></a>
  <h4 id="Wintellect_PowerCollections_BigList_1_AddToFront__0_" data-uid="Wintellect.PowerCollections.BigList`1.AddToFront(`0)">AddToFront(T)</h4>
  <div class="markdown level1 summary"><p>Adds an item to the beginning of the BigList. The indices of all existing items
in the Deque are increased by one, and the new item has index zero.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public void AddToFront(T item)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">T</span></td>
        <td><span class="parametername">item</span></td>
        <td><p>The item to add.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="Wintellect_PowerCollections_BigList_1_AddToFront__0__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>Adding an item takes, on average, constant time.</p>
</div>
  
  
  <a id="Wintellect_PowerCollections_BigList_1_BinarySearch_" data-uid="Wintellect.PowerCollections.BigList`1.BinarySearch*"></a>
  <h4 id="Wintellect_PowerCollections_BigList_1_BinarySearch__0_" data-uid="Wintellect.PowerCollections.BigList`1.BinarySearch(`0)">BinarySearch(T)</h4>
  <div class="markdown level1 summary"><p>Searches a sorted list for an item via binary search. The list must be sorted
in the order defined by the default ordering of the item type; otherwise,
incorrect results will be returned.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public int BinarySearch(T item)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">T</span></td>
        <td><span class="parametername">item</span></td>
        <td><p>The item to search for.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Int32</span></td>
        <td><p>Returns the index of the first occurence of <code data-dev-comment-type="paramref" class="paramref">item</code> in the list. If the item does not occur
in the list, the bitwise complement of the first item larger than <code data-dev-comment-type="paramref" class="paramref">item</code> in the list is returned. If no item is
larger than <code data-dev-comment-type="paramref" class="paramref">item</code>, the bitwise complement of Count is returned.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="exceptions">Exceptions</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Condition</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.InvalidOperationException</span></td>
        <td><p>The type T does not implement either the IComparable or
IComparable&lt;T&gt; interfaces.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Wintellect_PowerCollections_BigList_1_BinarySearch_" data-uid="Wintellect.PowerCollections.BigList`1.BinarySearch*"></a>
  <h4 id="Wintellect_PowerCollections_BigList_1_BinarySearch__0_" data-uid="Wintellect.PowerCollections.BigList`1.BinarySearch(`0)">BinarySearch(T)</h4>
  <div class="markdown level1 summary"><p>Searches a sorted list for an item via binary search. The list must be sorted
in the order defined by the default ordering of the item type; otherwise,
incorrect results will be returned.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public int BinarySearch(T item)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">T</span></td>
        <td><span class="parametername">item</span></td>
        <td><p>The item to search for.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Int32</span></td>
        <td><p>Returns the index of the first occurence of <code data-dev-comment-type="paramref" class="paramref">item</code> in the list. If the item does not occur
in the list, the bitwise complement of the first item larger than <code data-dev-comment-type="paramref" class="paramref">item</code> in the list is returned. If no item is
larger than <code data-dev-comment-type="paramref" class="paramref">item</code>, the bitwise complement of Count is returned.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="exceptions">Exceptions</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Condition</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.InvalidOperationException</span></td>
        <td><p>The type T does not implement either the IComparable or
IComparable&lt;T&gt; interfaces.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Wintellect_PowerCollections_BigList_1_BinarySearch_" data-uid="Wintellect.PowerCollections.BigList`1.BinarySearch*"></a>
  <h4 id="Wintellect_PowerCollections_BigList_1_BinarySearch__0_System_Collections_Generic_IComparer__0__" data-uid="Wintellect.PowerCollections.BigList`1.BinarySearch(`0,System.Collections.Generic.IComparer{`0})">BinarySearch(T, IComparer&lt;T&gt;)</h4>
  <div class="markdown level1 summary"><p>Searches a sorted list for an item via binary search. The list must be sorted
by the ordering defined by the passed IComparer&lt;T&gt; interface; otherwise,
incorrect results will be returned.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public int BinarySearch(T item, IComparer&lt;T&gt; comparer)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">T</span></td>
        <td><span class="parametername">item</span></td>
        <td><p>The item to search for.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Collections.Generic.IComparer</span>&lt;T&gt;</td>
        <td><span class="parametername">comparer</span></td>
        <td><p>The IComparer&lt;T&gt; interface used to sort the list.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Int32</span></td>
        <td><p>Returns the index of the first occurence of <code data-dev-comment-type="paramref" class="paramref">item</code> in the list. If the item does not occur
in the list, the bitwise complement of the first item larger than <code data-dev-comment-type="paramref" class="paramref">item</code> in the list is returned. If no item is
larger than <code data-dev-comment-type="paramref" class="paramref">item</code>, the bitwise complement of Count is returned.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Wintellect_PowerCollections_BigList_1_BinarySearch_" data-uid="Wintellect.PowerCollections.BigList`1.BinarySearch*"></a>
  <h4 id="Wintellect_PowerCollections_BigList_1_BinarySearch__0_System_Collections_Generic_IComparer__0__" data-uid="Wintellect.PowerCollections.BigList`1.BinarySearch(`0,System.Collections.Generic.IComparer{`0})">BinarySearch(T, IComparer&lt;T&gt;)</h4>
  <div class="markdown level1 summary"><p>Searches a sorted list for an item via binary search. The list must be sorted
by the ordering defined by the passed IComparer&lt;T&gt; interface; otherwise,
incorrect results will be returned.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public int BinarySearch(T item, IComparer&lt;T&gt; comparer)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">T</span></td>
        <td><span class="parametername">item</span></td>
        <td><p>The item to search for.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Collections.Generic.IComparer</span>&lt;T&gt;</td>
        <td><span class="parametername">comparer</span></td>
        <td><p>The IComparer&lt;T&gt; interface used to sort the list.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Int32</span></td>
        <td><p>Returns the index of the first occurence of <code data-dev-comment-type="paramref" class="paramref">item</code> in the list. If the item does not occur
in the list, the bitwise complement of the first item larger than <code data-dev-comment-type="paramref" class="paramref">item</code> in the list is returned. If no item is
larger than <code data-dev-comment-type="paramref" class="paramref">item</code>, the bitwise complement of Count is returned.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Wintellect_PowerCollections_BigList_1_BinarySearch_" data-uid="Wintellect.PowerCollections.BigList`1.BinarySearch*"></a>
  <h4 id="Wintellect_PowerCollections_BigList_1_BinarySearch__0_System_Comparison__0__" data-uid="Wintellect.PowerCollections.BigList`1.BinarySearch(`0,System.Comparison{`0})">BinarySearch(T, Comparison&lt;T&gt;)</h4>
  <div class="markdown level1 summary"><p>Searches a sorted list for an item via binary search. The list must be sorted
by the ordering defined by the passed Comparison&lt;T&gt; delegate; otherwise,
incorrect results will be returned.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public int BinarySearch(T item, Comparison&lt;T&gt; comparison)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">T</span></td>
        <td><span class="parametername">item</span></td>
        <td><p>The item to search for.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Comparison</span>&lt;T&gt;</td>
        <td><span class="parametername">comparison</span></td>
        <td><p>The comparison delegate used to sort the list.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Int32</span></td>
        <td><p>Returns the index of the first occurence of <code data-dev-comment-type="paramref" class="paramref">item</code> in the list. If the item does not occur
in the list, the bitwise complement of the first item larger than <code data-dev-comment-type="paramref" class="paramref">item</code> in the list is returned. If no item is
larger than <code data-dev-comment-type="paramref" class="paramref">item</code>, the bitwise complement of Count is returned.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Wintellect_PowerCollections_BigList_1_BinarySearch_" data-uid="Wintellect.PowerCollections.BigList`1.BinarySearch*"></a>
  <h4 id="Wintellect_PowerCollections_BigList_1_BinarySearch__0_System_Comparison__0__" data-uid="Wintellect.PowerCollections.BigList`1.BinarySearch(`0,System.Comparison{`0})">BinarySearch(T, Comparison&lt;T&gt;)</h4>
  <div class="markdown level1 summary"><p>Searches a sorted list for an item via binary search. The list must be sorted
by the ordering defined by the passed Comparison&lt;T&gt; delegate; otherwise,
incorrect results will be returned.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public int BinarySearch(T item, Comparison&lt;T&gt; comparison)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">T</span></td>
        <td><span class="parametername">item</span></td>
        <td><p>The item to search for.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Comparison</span>&lt;T&gt;</td>
        <td><span class="parametername">comparison</span></td>
        <td><p>The comparison delegate used to sort the list.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Int32</span></td>
        <td><p>Returns the index of the first occurence of <code data-dev-comment-type="paramref" class="paramref">item</code> in the list. If the item does not occur
in the list, the bitwise complement of the first item larger than <code data-dev-comment-type="paramref" class="paramref">item</code> in the list is returned. If no item is
larger than <code data-dev-comment-type="paramref" class="paramref">item</code>, the bitwise complement of Count is returned.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Wintellect_PowerCollections_BigList_1_Clear_" data-uid="Wintellect.PowerCollections.BigList`1.Clear*"></a>
  <h4 id="Wintellect_PowerCollections_BigList_1_Clear" data-uid="Wintellect.PowerCollections.BigList`1.Clear">Clear()</h4>
  <div class="markdown level1 summary"><p>Removes all of the items from the BigList.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public sealed override void Clear()</code></pre>
  </div>
  <h5 class="overrides">Overrides</h5>
  <div><span class="xref">Wintellect.PowerCollections.ListBase&lt;T&gt;.Clear()</span></div>
  <h5 id="Wintellect_PowerCollections_BigList_1_Clear_remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>Clearing a BigList takes constant time.</p>
</div>
  
  
  <a id="Wintellect_PowerCollections_BigList_1_Clear_" data-uid="Wintellect.PowerCollections.BigList`1.Clear*"></a>
  <h4 id="Wintellect_PowerCollections_BigList_1_Clear" data-uid="Wintellect.PowerCollections.BigList`1.Clear">Clear()</h4>
  <div class="markdown level1 summary"><p>Removes all of the items from the BigList.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public sealed override void Clear()</code></pre>
  </div>
  <h5 class="overrides">Overrides</h5>
  <div><span class="xref">Wintellect.PowerCollections.ListBase&lt;T&gt;.Clear()</span></div>
  <h5 id="Wintellect_PowerCollections_BigList_1_Clear_remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>Clearing a BigList takes constant time.</p>
</div>
  
  
  <a id="Wintellect_PowerCollections_BigList_1_Clone_" data-uid="Wintellect.PowerCollections.BigList`1.Clone*"></a>
  <h4 id="Wintellect_PowerCollections_BigList_1_Clone" data-uid="Wintellect.PowerCollections.BigList`1.Clone">Clone()</h4>
  <div class="markdown level1 summary"><p>Creates a new BigList that is a copy of this list.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public BigList&lt;T&gt; Clone()</code></pre>
  </div>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Wintellect.PowerCollections.BigList-1.html">BigList</a>&lt;T&gt;</td>
        <td><p>A copy of the current list</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="Wintellect_PowerCollections_BigList_1_Clone_remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>Copying a BigList takes constant time, and little
additional memory, since the storage for the items of the two lists is shared. However, changing
either list will take additional time and memory. Portions of the list are copied when they are changed.</p>
</div>
  
  
  <a id="Wintellect_PowerCollections_BigList_1_Clone_" data-uid="Wintellect.PowerCollections.BigList`1.Clone*"></a>
  <h4 id="Wintellect_PowerCollections_BigList_1_Clone" data-uid="Wintellect.PowerCollections.BigList`1.Clone">Clone()</h4>
  <div class="markdown level1 summary"><p>Creates a new BigList that is a copy of this list.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public BigList&lt;T&gt; Clone()</code></pre>
  </div>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Wintellect.PowerCollections.BigList-1.html">BigList</a>&lt;T&gt;</td>
        <td><p>A copy of the current list</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="Wintellect_PowerCollections_BigList_1_Clone_remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>Copying a BigList takes constant time, and little
additional memory, since the storage for the items of the two lists is shared. However, changing
either list will take additional time and memory. Portions of the list are copied when they are changed.</p>
</div>
  
  
  <a id="Wintellect_PowerCollections_BigList_1_CloneContents_" data-uid="Wintellect.PowerCollections.BigList`1.CloneContents*"></a>
  <h4 id="Wintellect_PowerCollections_BigList_1_CloneContents" data-uid="Wintellect.PowerCollections.BigList`1.CloneContents">CloneContents()</h4>
  <div class="markdown level1 summary"><p>Makes a deep clone of this BigList. A new BigList is created with a clone of
each element of this set, by calling ICloneable.Clone on each element. If T is
a value type, then this method is the same as Clone.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public BigList&lt;T&gt; CloneContents()</code></pre>
  </div>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Wintellect.PowerCollections.BigList-1.html">BigList</a>&lt;T&gt;</td>
        <td><p>The cloned set.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="Wintellect_PowerCollections_BigList_1_CloneContents_remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>If T is a reference type, it must implement
    ICloneable. Otherwise, an InvalidOperationException is thrown.</p>
<p>If T is a reference type, cloning the list takes time approximate O(N), where N is the number of items in the list.</p>
</div>
  <h5 class="exceptions">Exceptions</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Condition</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.InvalidOperationException</span></td>
        <td><p>T is a reference type that does not implement ICloneable.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Wintellect_PowerCollections_BigList_1_CloneContents_" data-uid="Wintellect.PowerCollections.BigList`1.CloneContents*"></a>
  <h4 id="Wintellect_PowerCollections_BigList_1_CloneContents" data-uid="Wintellect.PowerCollections.BigList`1.CloneContents">CloneContents()</h4>
  <div class="markdown level1 summary"><p>Makes a deep clone of this BigList. A new BigList is created with a clone of
each element of this set, by calling ICloneable.Clone on each element. If T is
a value type, then this method is the same as Clone.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public BigList&lt;T&gt; CloneContents()</code></pre>
  </div>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Wintellect.PowerCollections.BigList-1.html">BigList</a>&lt;T&gt;</td>
        <td><p>The cloned set.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="Wintellect_PowerCollections_BigList_1_CloneContents_remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>If T is a reference type, it must implement
    ICloneable. Otherwise, an InvalidOperationException is thrown.</p>
<p>If T is a reference type, cloning the list takes time approximate O(N), where N is the number of items in the list.</p>
</div>
  <h5 class="exceptions">Exceptions</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Condition</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.InvalidOperationException</span></td>
        <td><p>T is a reference type that does not implement ICloneable.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Wintellect_PowerCollections_BigList_1_ConvertAll_" data-uid="Wintellect.PowerCollections.BigList`1.ConvertAll*"></a>
  <h4 id="Wintellect_PowerCollections_BigList_1_ConvertAll__1_System_Converter__0___0__" data-uid="Wintellect.PowerCollections.BigList`1.ConvertAll``1(System.Converter{`0,``0})">ConvertAll&lt;TDest&gt;(Converter&lt;T, TDest&gt;)</h4>
  <div class="markdown level1 summary"><p>Convert the list to a new list by applying a delegate to each item in the collection. The resulting list
contains the result of applying <code data-dev-comment-type="paramref" class="paramref">converter</code> to each item in the list, in
order. The current list is unchanged.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public BigList&lt;TDest&gt; ConvertAll&lt;TDest&gt;(Converter&lt;T, TDest&gt; converter)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Converter</span>&lt;T, TDest&gt;</td>
        <td><span class="parametername">converter</span></td>
        <td><p>A delegate to the method to call, passing each item in <type name="BigList&lt;T>"></type>.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Wintellect.PowerCollections.BigList-1.html">BigList</a>&lt;TDest&gt;</td>
        <td><p>The resulting BigList from applying <code data-dev-comment-type="paramref" class="paramref">converter</code> to each item in this list.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="typeParameters">Type Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="parametername">TDest</span></td>
        <td><p>The type each item is being converted to.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="exceptions">Exceptions</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Condition</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.ArgumentNullException</span></td>
        <td><p><code data-dev-comment-type="paramref" class="paramref">converter</code> is null.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Wintellect_PowerCollections_BigList_1_ConvertAll_" data-uid="Wintellect.PowerCollections.BigList`1.ConvertAll*"></a>
  <h4 id="Wintellect_PowerCollections_BigList_1_ConvertAll__1_System_Converter__0___0__" data-uid="Wintellect.PowerCollections.BigList`1.ConvertAll``1(System.Converter{`0,``0})">ConvertAll&lt;TDest&gt;(Converter&lt;T, TDest&gt;)</h4>
  <div class="markdown level1 summary"><p>Convert the list to a new list by applying a delegate to each item in the collection. The resulting list
contains the result of applying <code data-dev-comment-type="paramref" class="paramref">converter</code> to each item in the list, in
order. The current list is unchanged.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public BigList&lt;TDest&gt; ConvertAll&lt;TDest&gt;(Converter&lt;T, TDest&gt; converter)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Converter</span>&lt;T, TDest&gt;</td>
        <td><span class="parametername">converter</span></td>
        <td><p>A delegate to the method to call, passing each item in <type name="BigList&lt;T>"></type>.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Wintellect.PowerCollections.BigList-1.html">BigList</a>&lt;TDest&gt;</td>
        <td><p>The resulting BigList from applying <code data-dev-comment-type="paramref" class="paramref">converter</code> to each item in this list.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="typeParameters">Type Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="parametername">TDest</span></td>
        <td><p>The type each item is being converted to.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="exceptions">Exceptions</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Condition</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.ArgumentNullException</span></td>
        <td><p><code data-dev-comment-type="paramref" class="paramref">converter</code> is null.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Wintellect_PowerCollections_BigList_1_GetEnumerator_" data-uid="Wintellect.PowerCollections.BigList`1.GetEnumerator*"></a>
  <h4 id="Wintellect_PowerCollections_BigList_1_GetEnumerator" data-uid="Wintellect.PowerCollections.BigList`1.GetEnumerator">GetEnumerator()</h4>
  <div class="markdown level1 summary"><p>Enumerates all of the items in the list, in order. The item at index 0
is enumerated first, then the item at index 1, and so on. Usually, the
foreach statement is used to call this method implicitly.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public sealed override IEnumerator&lt;T&gt; GetEnumerator()</code></pre>
  </div>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Collections.Generic.IEnumerator</span>&lt;T&gt;</td>
        <td><p>An IEnumerator&lt;T&gt; that enumerates all the
items in the list.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="overrides">Overrides</h5>
  <div><span class="xref">Wintellect.PowerCollections.ListBase&lt;T&gt;.GetEnumerator()</span></div>
  <h5 id="Wintellect_PowerCollections_BigList_1_GetEnumerator_remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>Enumerating all of the items in the list take time O(N), where
N is the number of items in the list. Using GetEnumerator() or foreach
is much more efficient than accessing all items by index.</p>
</div>
  
  
  <a id="Wintellect_PowerCollections_BigList_1_GetEnumerator_" data-uid="Wintellect.PowerCollections.BigList`1.GetEnumerator*"></a>
  <h4 id="Wintellect_PowerCollections_BigList_1_GetEnumerator" data-uid="Wintellect.PowerCollections.BigList`1.GetEnumerator">GetEnumerator()</h4>
  <div class="markdown level1 summary"><p>Enumerates all of the items in the list, in order. The item at index 0
is enumerated first, then the item at index 1, and so on. Usually, the
foreach statement is used to call this method implicitly.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public sealed override IEnumerator&lt;T&gt; GetEnumerator()</code></pre>
  </div>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Collections.Generic.IEnumerator</span>&lt;T&gt;</td>
        <td><p>An IEnumerator&lt;T&gt; that enumerates all the
items in the list.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="overrides">Overrides</h5>
  <div><span class="xref">Wintellect.PowerCollections.ListBase&lt;T&gt;.GetEnumerator()</span></div>
  <h5 id="Wintellect_PowerCollections_BigList_1_GetEnumerator_remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>Enumerating all of the items in the list take time O(N), where
N is the number of items in the list. Using GetEnumerator() or foreach
is much more efficient than accessing all items by index.</p>
</div>
  
  
  <a id="Wintellect_PowerCollections_BigList_1_GetRange_" data-uid="Wintellect.PowerCollections.BigList`1.GetRange*"></a>
  <h4 id="Wintellect_PowerCollections_BigList_1_GetRange_System_Int32_System_Int32_" data-uid="Wintellect.PowerCollections.BigList`1.GetRange(System.Int32,System.Int32)">GetRange(Int32, Int32)</h4>
  <div class="markdown level1 summary"><p>Creates a new list that contains a subrange of elements from this list. The
current list is unchanged.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public BigList&lt;T&gt; GetRange(int index, int count)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Int32</span></td>
        <td><span class="parametername">index</span></td>
        <td><p>The starting index of the sub-range.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Int32</span></td>
        <td><span class="parametername">count</span></td>
        <td><p>The number of items in the sub-range. If this is zero,
the returned list is empty.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Wintellect.PowerCollections.BigList-1.html">BigList</a>&lt;T&gt;</td>
        <td><p>A new list with the <code data-dev-comment-type="paramref" class="paramref">count</code> items that start at <code data-dev-comment-type="paramref" class="paramref">index</code>.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="Wintellect_PowerCollections_BigList_1_GetRange_System_Int32_System_Int32__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>This method takes take O(log N), where N is the size of the current list. Although
the sub-range is conceptually copied, storage is shared between the two lists until a change
is made to the shared items.</p>
</div>
  
  
  <a id="Wintellect_PowerCollections_BigList_1_GetRange_" data-uid="Wintellect.PowerCollections.BigList`1.GetRange*"></a>
  <h4 id="Wintellect_PowerCollections_BigList_1_GetRange_System_Int32_System_Int32_" data-uid="Wintellect.PowerCollections.BigList`1.GetRange(System.Int32,System.Int32)">GetRange(Int32, Int32)</h4>
  <div class="markdown level1 summary"><p>Creates a new list that contains a subrange of elements from this list. The
current list is unchanged.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public BigList&lt;T&gt; GetRange(int index, int count)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Int32</span></td>
        <td><span class="parametername">index</span></td>
        <td><p>The starting index of the sub-range.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Int32</span></td>
        <td><span class="parametername">count</span></td>
        <td><p>The number of items in the sub-range. If this is zero,
the returned list is empty.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Wintellect.PowerCollections.BigList-1.html">BigList</a>&lt;T&gt;</td>
        <td><p>A new list with the <code data-dev-comment-type="paramref" class="paramref">count</code> items that start at <code data-dev-comment-type="paramref" class="paramref">index</code>.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="Wintellect_PowerCollections_BigList_1_GetRange_System_Int32_System_Int32__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>This method takes take O(log N), where N is the size of the current list. Although
the sub-range is conceptually copied, storage is shared between the two lists until a change
is made to the shared items.</p>
</div>
  
  
  <a id="Wintellect_PowerCollections_BigList_1_Insert_" data-uid="Wintellect.PowerCollections.BigList`1.Insert*"></a>
  <h4 id="Wintellect_PowerCollections_BigList_1_Insert_System_Int32__0_" data-uid="Wintellect.PowerCollections.BigList`1.Insert(System.Int32,`0)">Insert(Int32, T)</h4>
  <div class="markdown level1 summary"><p>Inserts a new item at the given index in the BigList. All items at indexes
equal to or greater than <code data-dev-comment-type="paramref" class="paramref">index</code> move up one index.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public sealed override void Insert(int index, T item)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Int32</span></td>
        <td><span class="parametername">index</span></td>
        <td><p>The index to insert the item at. After the
insertion, the inserted item is located at this index. The
first item has index 0.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">T</span></td>
        <td><span class="parametername">item</span></td>
        <td><p>The item to insert at the given index.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="overrides">Overrides</h5>
  <div><span class="xref">Wintellect.PowerCollections.ListBase&lt;T&gt;.Insert(System.Int32, T)</span></div>
  <h5 id="Wintellect_PowerCollections_BigList_1_Insert_System_Int32__0__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>The amount of time to insert an item is O(log N), no matter where
in the list the insertion occurs. Inserting an item at the beginning or end of the
list is O(N).</p>
</div>
  <h5 class="exceptions">Exceptions</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Condition</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.ArgumentOutOfRangeException</span></td>
        <td><p><code data-dev-comment-type="paramref" class="paramref">index</code> is
less than zero or greater than Count.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Wintellect_PowerCollections_BigList_1_Insert_" data-uid="Wintellect.PowerCollections.BigList`1.Insert*"></a>
  <h4 id="Wintellect_PowerCollections_BigList_1_Insert_System_Int32__0_" data-uid="Wintellect.PowerCollections.BigList`1.Insert(System.Int32,`0)">Insert(Int32, T)</h4>
  <div class="markdown level1 summary"><p>Inserts a new item at the given index in the BigList. All items at indexes
equal to or greater than <code data-dev-comment-type="paramref" class="paramref">index</code> move up one index.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public sealed override void Insert(int index, T item)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Int32</span></td>
        <td><span class="parametername">index</span></td>
        <td><p>The index to insert the item at. After the
insertion, the inserted item is located at this index. The
first item has index 0.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">T</span></td>
        <td><span class="parametername">item</span></td>
        <td><p>The item to insert at the given index.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="overrides">Overrides</h5>
  <div><span class="xref">Wintellect.PowerCollections.ListBase&lt;T&gt;.Insert(System.Int32, T)</span></div>
  <h5 id="Wintellect_PowerCollections_BigList_1_Insert_System_Int32__0__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>The amount of time to insert an item is O(log N), no matter where
in the list the insertion occurs. Inserting an item at the beginning or end of the
list is O(N).</p>
</div>
  <h5 class="exceptions">Exceptions</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Condition</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.ArgumentOutOfRangeException</span></td>
        <td><p><code data-dev-comment-type="paramref" class="paramref">index</code> is
less than zero or greater than Count.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Wintellect_PowerCollections_BigList_1_InsertRange_" data-uid="Wintellect.PowerCollections.BigList`1.InsertRange*"></a>
  <h4 id="Wintellect_PowerCollections_BigList_1_InsertRange_System_Int32_System_Collections_Generic_IEnumerable__0__" data-uid="Wintellect.PowerCollections.BigList`1.InsertRange(System.Int32,System.Collections.Generic.IEnumerable{`0})">InsertRange(Int32, IEnumerable&lt;T&gt;)</h4>
  <div class="markdown level1 summary"><p>Inserts a collection of items at the given index in the BigList. All items at indexes
equal to or greater than <code data-dev-comment-type="paramref" class="paramref">index</code> increase their indices
by the number of items inserted.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public void InsertRange(int index, IEnumerable&lt;T&gt; collection)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Int32</span></td>
        <td><span class="parametername">index</span></td>
        <td><p>The index to insert the collection at. After the
insertion, the first item of the inserted collection is located at this index. The
first item has index 0.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Collections.Generic.IEnumerable</span>&lt;T&gt;</td>
        <td><span class="parametername">collection</span></td>
        <td><p>The collection of items to insert at the given index.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="Wintellect_PowerCollections_BigList_1_InsertRange_System_Int32_System_Collections_Generic_IEnumerable__0___remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>The amount of time to insert an arbitrary collection in the BigList is O(M + log N),
where M is the number of items inserted, and N is the number of items in the list.</p>
</div>
  <h5 class="exceptions">Exceptions</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Condition</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.ArgumentOutOfRangeException</span></td>
        <td><p><code data-dev-comment-type="paramref" class="paramref">index</code> is
less than zero or greater than Count.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.ArgumentNullException</span></td>
        <td><p><code data-dev-comment-type="paramref" class="paramref">collection</code> is null.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Wintellect_PowerCollections_BigList_1_InsertRange_" data-uid="Wintellect.PowerCollections.BigList`1.InsertRange*"></a>
  <h4 id="Wintellect_PowerCollections_BigList_1_InsertRange_System_Int32_System_Collections_Generic_IEnumerable__0__" data-uid="Wintellect.PowerCollections.BigList`1.InsertRange(System.Int32,System.Collections.Generic.IEnumerable{`0})">InsertRange(Int32, IEnumerable&lt;T&gt;)</h4>
  <div class="markdown level1 summary"><p>Inserts a collection of items at the given index in the BigList. All items at indexes
equal to or greater than <code data-dev-comment-type="paramref" class="paramref">index</code> increase their indices
by the number of items inserted.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public void InsertRange(int index, IEnumerable&lt;T&gt; collection)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Int32</span></td>
        <td><span class="parametername">index</span></td>
        <td><p>The index to insert the collection at. After the
insertion, the first item of the inserted collection is located at this index. The
first item has index 0.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Collections.Generic.IEnumerable</span>&lt;T&gt;</td>
        <td><span class="parametername">collection</span></td>
        <td><p>The collection of items to insert at the given index.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="Wintellect_PowerCollections_BigList_1_InsertRange_System_Int32_System_Collections_Generic_IEnumerable__0___remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>The amount of time to insert an arbitrary collection in the BigList is O(M + log N),
where M is the number of items inserted, and N is the number of items in the list.</p>
</div>
  <h5 class="exceptions">Exceptions</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Condition</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.ArgumentOutOfRangeException</span></td>
        <td><p><code data-dev-comment-type="paramref" class="paramref">index</code> is
less than zero or greater than Count.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.ArgumentNullException</span></td>
        <td><p><code data-dev-comment-type="paramref" class="paramref">collection</code> is null.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Wintellect_PowerCollections_BigList_1_InsertRange_" data-uid="Wintellect.PowerCollections.BigList`1.InsertRange*"></a>
  <h4 id="Wintellect_PowerCollections_BigList_1_InsertRange_System_Int32_Wintellect_PowerCollections_BigList__0__" data-uid="Wintellect.PowerCollections.BigList`1.InsertRange(System.Int32,Wintellect.PowerCollections.BigList{`0})">InsertRange(Int32, BigList&lt;T&gt;)</h4>
  <div class="markdown level1 summary"><p>Inserts a BigList of items at the given index in the BigList. All items at indexes
equal to or greater than <code data-dev-comment-type="paramref" class="paramref">index</code> increase their indices
by the number of items inserted.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public void InsertRange(int index, BigList&lt;T&gt; list)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Int32</span></td>
        <td><span class="parametername">index</span></td>
        <td><p>The index to insert the collection at. After the
insertion, the first item of the inserted collection is located at this index. The
first item has index 0.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="Wintellect.PowerCollections.BigList-1.html">BigList</a>&lt;T&gt;</td>
        <td><span class="parametername">list</span></td>
        <td><p>The BigList of items to insert at the given index.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="Wintellect_PowerCollections_BigList_1_InsertRange_System_Int32_Wintellect_PowerCollections_BigList__0___remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>The amount of time to insert another BigList is O(log N),
where N is the number of items in the list, regardless of the number of items in the
inserted list. Storage is shared between the two lists until one of them is changed.</p>
</div>
  <h5 class="exceptions">Exceptions</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Condition</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.ArgumentOutOfRangeException</span></td>
        <td><p><code data-dev-comment-type="paramref" class="paramref">index</code> is
less than zero or greater than Count.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.ArgumentNullException</span></td>
        <td><p><code data-dev-comment-type="paramref" class="paramref">list</code> is null.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Wintellect_PowerCollections_BigList_1_InsertRange_" data-uid="Wintellect.PowerCollections.BigList`1.InsertRange*"></a>
  <h4 id="Wintellect_PowerCollections_BigList_1_InsertRange_System_Int32_Wintellect_PowerCollections_BigList__0__" data-uid="Wintellect.PowerCollections.BigList`1.InsertRange(System.Int32,Wintellect.PowerCollections.BigList{`0})">InsertRange(Int32, BigList&lt;T&gt;)</h4>
  <div class="markdown level1 summary"><p>Inserts a BigList of items at the given index in the BigList. All items at indexes
equal to or greater than <code data-dev-comment-type="paramref" class="paramref">index</code> increase their indices
by the number of items inserted.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public void InsertRange(int index, BigList&lt;T&gt; list)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Int32</span></td>
        <td><span class="parametername">index</span></td>
        <td><p>The index to insert the collection at. After the
insertion, the first item of the inserted collection is located at this index. The
first item has index 0.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="Wintellect.PowerCollections.BigList-1.html">BigList</a>&lt;T&gt;</td>
        <td><span class="parametername">list</span></td>
        <td><p>The BigList of items to insert at the given index.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="Wintellect_PowerCollections_BigList_1_InsertRange_System_Int32_Wintellect_PowerCollections_BigList__0___remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>The amount of time to insert another BigList is O(log N),
where N is the number of items in the list, regardless of the number of items in the
inserted list. Storage is shared between the two lists until one of them is changed.</p>
</div>
  <h5 class="exceptions">Exceptions</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Condition</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.ArgumentOutOfRangeException</span></td>
        <td><p><code data-dev-comment-type="paramref" class="paramref">index</code> is
less than zero or greater than Count.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.ArgumentNullException</span></td>
        <td><p><code data-dev-comment-type="paramref" class="paramref">list</code> is null.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Wintellect_PowerCollections_BigList_1_Range_" data-uid="Wintellect.PowerCollections.BigList`1.Range*"></a>
  <h4 id="Wintellect_PowerCollections_BigList_1_Range_System_Int32_System_Int32_" data-uid="Wintellect.PowerCollections.BigList`1.Range(System.Int32,System.Int32)">Range(Int32, Int32)</h4>
  <div class="markdown level1 summary"><p>Returns a view onto a sub-range of this list. Items are not copied; the
returned IList&lt;T&gt; is simply a different view onto the same underlying items. Changes to this list
are reflected in the view, and vice versa. Insertions and deletions in the view change the size of the
view, but insertions and deletions in the underlying list do not.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public sealed override IList&lt;T&gt; Range(int index, int count)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Int32</span></td>
        <td><span class="parametername">index</span></td>
        <td><p>The starting index of the view.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Int32</span></td>
        <td><span class="parametername">count</span></td>
        <td><p>The number of items in the view.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Collections.Generic.IList</span>&lt;T&gt;</td>
        <td><p>A list that is a view onto the given sub-list.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="overrides">Overrides</h5>
  <div><span class="xref">Wintellect.PowerCollections.ListBase&lt;T&gt;.Range(System.Int32, System.Int32)</span></div>
  <h5 id="Wintellect_PowerCollections_BigList_1_Range_System_Int32_System_Int32__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>If a copy of the sub-range is desired, use the <a class="xref" href="Wintellect.PowerCollections.BigList-1.html#Wintellect_PowerCollections_BigList_1_GetRange_System_Int32_System_Int32_">GetRange(Int32, Int32)</a> method instead.</p>
<p>This method can be used to apply an algorithm to a portion of a list. For example:</p>
<pre><code>Algorithms.ReverseInPlace(list.Range(3, 6))</code></pre>
will reverse the 6 items beginning at index 3.
</div>
  <h5 class="exceptions">Exceptions</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Condition</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.ArgumentOutOfRangeException</span></td>
        <td><p><code data-dev-comment-type="paramref" class="paramref">index</code> or <code data-dev-comment-type="paramref" class="paramref">count</code> is negative.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.ArgumentOutOfRangeException</span></td>
        <td><p><code data-dev-comment-type="paramref" class="paramref">index</code> + <code data-dev-comment-type="paramref" class="paramref">count</code> is greater than the
size of this list.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Wintellect_PowerCollections_BigList_1_Range_" data-uid="Wintellect.PowerCollections.BigList`1.Range*"></a>
  <h4 id="Wintellect_PowerCollections_BigList_1_Range_System_Int32_System_Int32_" data-uid="Wintellect.PowerCollections.BigList`1.Range(System.Int32,System.Int32)">Range(Int32, Int32)</h4>
  <div class="markdown level1 summary"><p>Returns a view onto a sub-range of this list. Items are not copied; the
returned IList&lt;T&gt; is simply a different view onto the same underlying items. Changes to this list
are reflected in the view, and vice versa. Insertions and deletions in the view change the size of the
view, but insertions and deletions in the underlying list do not.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public sealed override IList&lt;T&gt; Range(int index, int count)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Int32</span></td>
        <td><span class="parametername">index</span></td>
        <td><p>The starting index of the view.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Int32</span></td>
        <td><span class="parametername">count</span></td>
        <td><p>The number of items in the view.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Collections.Generic.IList</span>&lt;T&gt;</td>
        <td><p>A list that is a view onto the given sub-list.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="overrides">Overrides</h5>
  <div><span class="xref">Wintellect.PowerCollections.ListBase&lt;T&gt;.Range(System.Int32, System.Int32)</span></div>
  <h5 id="Wintellect_PowerCollections_BigList_1_Range_System_Int32_System_Int32__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>If a copy of the sub-range is desired, use the <a class="xref" href="Wintellect.PowerCollections.BigList-1.html#Wintellect_PowerCollections_BigList_1_GetRange_System_Int32_System_Int32_">GetRange(Int32, Int32)</a> method instead.</p>
<p>This method can be used to apply an algorithm to a portion of a list. For example:</p>
<pre><code>Algorithms.ReverseInPlace(list.Range(3, 6))</code></pre>
will reverse the 6 items beginning at index 3.
</div>
  <h5 class="exceptions">Exceptions</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Condition</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.ArgumentOutOfRangeException</span></td>
        <td><p><code data-dev-comment-type="paramref" class="paramref">index</code> or <code data-dev-comment-type="paramref" class="paramref">count</code> is negative.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.ArgumentOutOfRangeException</span></td>
        <td><p><code data-dev-comment-type="paramref" class="paramref">index</code> + <code data-dev-comment-type="paramref" class="paramref">count</code> is greater than the
size of this list.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Wintellect_PowerCollections_BigList_1_RemoveAt_" data-uid="Wintellect.PowerCollections.BigList`1.RemoveAt*"></a>
  <h4 id="Wintellect_PowerCollections_BigList_1_RemoveAt_System_Int32_" data-uid="Wintellect.PowerCollections.BigList`1.RemoveAt(System.Int32)">RemoveAt(Int32)</h4>
  <div class="markdown level1 summary"><p>Removes the item at the given index in the BigList. All items at indexes
greater than <code data-dev-comment-type="paramref" class="paramref">index</code> move down one index.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public sealed override void RemoveAt(int index)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Int32</span></td>
        <td><span class="parametername">index</span></td>
        <td><p>The index in the list to remove the item at. The
first item in the list has index 0.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="overrides">Overrides</h5>
  <div><span class="xref">Wintellect.PowerCollections.ListBase&lt;T&gt;.RemoveAt(System.Int32)</span></div>
  <h5 id="Wintellect_PowerCollections_BigList_1_RemoveAt_System_Int32__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>The amount of time to delete an item in the BigList is O(log N),
where N is the number of items in the list.</p>
</div>
  <h5 class="exceptions">Exceptions</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Condition</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.ArgumentOutOfRangeException</span></td>
        <td><p><code data-dev-comment-type="paramref" class="paramref">index</code> is
less than zero or greater than or equal to Count.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Wintellect_PowerCollections_BigList_1_RemoveAt_" data-uid="Wintellect.PowerCollections.BigList`1.RemoveAt*"></a>
  <h4 id="Wintellect_PowerCollections_BigList_1_RemoveAt_System_Int32_" data-uid="Wintellect.PowerCollections.BigList`1.RemoveAt(System.Int32)">RemoveAt(Int32)</h4>
  <div class="markdown level1 summary"><p>Removes the item at the given index in the BigList. All items at indexes
greater than <code data-dev-comment-type="paramref" class="paramref">index</code> move down one index.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public sealed override void RemoveAt(int index)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Int32</span></td>
        <td><span class="parametername">index</span></td>
        <td><p>The index in the list to remove the item at. The
first item in the list has index 0.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="overrides">Overrides</h5>
  <div><span class="xref">Wintellect.PowerCollections.ListBase&lt;T&gt;.RemoveAt(System.Int32)</span></div>
  <h5 id="Wintellect_PowerCollections_BigList_1_RemoveAt_System_Int32__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>The amount of time to delete an item in the BigList is O(log N),
where N is the number of items in the list.</p>
</div>
  <h5 class="exceptions">Exceptions</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Condition</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.ArgumentOutOfRangeException</span></td>
        <td><p><code data-dev-comment-type="paramref" class="paramref">index</code> is
less than zero or greater than or equal to Count.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Wintellect_PowerCollections_BigList_1_RemoveRange_" data-uid="Wintellect.PowerCollections.BigList`1.RemoveRange*"></a>
  <h4 id="Wintellect_PowerCollections_BigList_1_RemoveRange_System_Int32_System_Int32_" data-uid="Wintellect.PowerCollections.BigList`1.RemoveRange(System.Int32,System.Int32)">RemoveRange(Int32, Int32)</h4>
  <div class="markdown level1 summary"><p>Removes a range of items at the given index in the Deque. All items at indexes
greater than <code data-dev-comment-type="paramref" class="paramref">index</code> move down <code data-dev-comment-type="paramref" class="paramref">count</code> indices
in the Deque.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public void RemoveRange(int index, int count)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Int32</span></td>
        <td><span class="parametername">index</span></td>
        <td><p>The index in the list to remove the range at. The
first item in the list has index 0.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Int32</span></td>
        <td><span class="parametername">count</span></td>
        <td><p>The number of items to remove.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="Wintellect_PowerCollections_BigList_1_RemoveRange_System_Int32_System_Int32__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>The amount of time to delete <code data-dev-comment-type="paramref" class="paramref">count</code> items in the Deque is proportional
to the distance of index from the closest end of the Deque, plus <code data-dev-comment-type="paramref" class="paramref">count</code>:
O(count + Min(<code data-dev-comment-type="paramref" class="paramref">index</code>, Count - 1 - <code data-dev-comment-type="paramref" class="paramref">index</code>)).</p>
</div>
  <h5 class="exceptions">Exceptions</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Condition</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.ArgumentOutOfRangeException</span></td>
        <td><p><code data-dev-comment-type="paramref" class="paramref">index</code> is
less than zero or greater than or equal to Count, or <code data-dev-comment-type="paramref" class="paramref">count</code> is less than zero
or too large.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Wintellect_PowerCollections_BigList_1_RemoveRange_" data-uid="Wintellect.PowerCollections.BigList`1.RemoveRange*"></a>
  <h4 id="Wintellect_PowerCollections_BigList_1_RemoveRange_System_Int32_System_Int32_" data-uid="Wintellect.PowerCollections.BigList`1.RemoveRange(System.Int32,System.Int32)">RemoveRange(Int32, Int32)</h4>
  <div class="markdown level1 summary"><p>Removes a range of items at the given index in the Deque. All items at indexes
greater than <code data-dev-comment-type="paramref" class="paramref">index</code> move down <code data-dev-comment-type="paramref" class="paramref">count</code> indices
in the Deque.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public void RemoveRange(int index, int count)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Int32</span></td>
        <td><span class="parametername">index</span></td>
        <td><p>The index in the list to remove the range at. The
first item in the list has index 0.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Int32</span></td>
        <td><span class="parametername">count</span></td>
        <td><p>The number of items to remove.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="Wintellect_PowerCollections_BigList_1_RemoveRange_System_Int32_System_Int32__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>The amount of time to delete <code data-dev-comment-type="paramref" class="paramref">count</code> items in the Deque is proportional
to the distance of index from the closest end of the Deque, plus <code data-dev-comment-type="paramref" class="paramref">count</code>:
O(count + Min(<code data-dev-comment-type="paramref" class="paramref">index</code>, Count - 1 - <code data-dev-comment-type="paramref" class="paramref">index</code>)).</p>
</div>
  <h5 class="exceptions">Exceptions</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Condition</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.ArgumentOutOfRangeException</span></td>
        <td><p><code data-dev-comment-type="paramref" class="paramref">index</code> is
less than zero or greater than or equal to Count, or <code data-dev-comment-type="paramref" class="paramref">count</code> is less than zero
or too large.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Wintellect_PowerCollections_BigList_1_Reverse_" data-uid="Wintellect.PowerCollections.BigList`1.Reverse*"></a>
  <h4 id="Wintellect_PowerCollections_BigList_1_Reverse" data-uid="Wintellect.PowerCollections.BigList`1.Reverse">Reverse()</h4>
  <div class="markdown level1 summary"><p>Reverses the current list in place.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public void Reverse()</code></pre>
  </div>
  
  
  <a id="Wintellect_PowerCollections_BigList_1_Reverse_" data-uid="Wintellect.PowerCollections.BigList`1.Reverse*"></a>
  <h4 id="Wintellect_PowerCollections_BigList_1_Reverse" data-uid="Wintellect.PowerCollections.BigList`1.Reverse">Reverse()</h4>
  <div class="markdown level1 summary"><p>Reverses the current list in place.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public void Reverse()</code></pre>
  </div>
  
  
  <a id="Wintellect_PowerCollections_BigList_1_Reverse_" data-uid="Wintellect.PowerCollections.BigList`1.Reverse*"></a>
  <h4 id="Wintellect_PowerCollections_BigList_1_Reverse_System_Int32_System_Int32_" data-uid="Wintellect.PowerCollections.BigList`1.Reverse(System.Int32,System.Int32)">Reverse(Int32, Int32)</h4>
  <div class="markdown level1 summary"><p>Reverses the items in the range of <code data-dev-comment-type="paramref" class="paramref">count</code> items starting from <code data-dev-comment-type="paramref" class="paramref">start</code>, in place.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public void Reverse(int start, int count)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Int32</span></td>
        <td><span class="parametername">start</span></td>
        <td><p>The starting index of the range to reverse.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Int32</span></td>
        <td><span class="parametername">count</span></td>
        <td><p>The number of items in range to reverse.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Wintellect_PowerCollections_BigList_1_Reverse_" data-uid="Wintellect.PowerCollections.BigList`1.Reverse*"></a>
  <h4 id="Wintellect_PowerCollections_BigList_1_Reverse_System_Int32_System_Int32_" data-uid="Wintellect.PowerCollections.BigList`1.Reverse(System.Int32,System.Int32)">Reverse(Int32, Int32)</h4>
  <div class="markdown level1 summary"><p>Reverses the items in the range of <code data-dev-comment-type="paramref" class="paramref">count</code> items starting from <code data-dev-comment-type="paramref" class="paramref">start</code>, in place.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public void Reverse(int start, int count)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Int32</span></td>
        <td><span class="parametername">start</span></td>
        <td><p>The starting index of the range to reverse.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Int32</span></td>
        <td><span class="parametername">count</span></td>
        <td><p>The number of items in range to reverse.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Wintellect_PowerCollections_BigList_1_Sort_" data-uid="Wintellect.PowerCollections.BigList`1.Sort*"></a>
  <h4 id="Wintellect_PowerCollections_BigList_1_Sort" data-uid="Wintellect.PowerCollections.BigList`1.Sort">Sort()</h4>
  <div class="markdown level1 summary"><p>Sorts the list in place.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public void Sort()</code></pre>
  </div>
  <h5 id="Wintellect_PowerCollections_BigList_1_Sort_remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>The Quicksort algorithm is used to sort the items. In virtually all cases,
    this takes time O(N log N), where N is the number of items in the list.</p>
<p>Values are compared by using the IComparable or IComparable&lt;T>
interface implementation on the type T.</p>
</div>
  <h5 class="exceptions">Exceptions</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Condition</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.InvalidOperationException</span></td>
        <td><p>The type T does not implement either the IComparable or
IComparable&lt;T&gt; interfaces.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Wintellect_PowerCollections_BigList_1_Sort_" data-uid="Wintellect.PowerCollections.BigList`1.Sort*"></a>
  <h4 id="Wintellect_PowerCollections_BigList_1_Sort" data-uid="Wintellect.PowerCollections.BigList`1.Sort">Sort()</h4>
  <div class="markdown level1 summary"><p>Sorts the list in place.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public void Sort()</code></pre>
  </div>
  <h5 id="Wintellect_PowerCollections_BigList_1_Sort_remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>The Quicksort algorithm is used to sort the items. In virtually all cases,
    this takes time O(N log N), where N is the number of items in the list.</p>
<p>Values are compared by using the IComparable or IComparable&lt;T>
interface implementation on the type T.</p>
</div>
  <h5 class="exceptions">Exceptions</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Condition</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.InvalidOperationException</span></td>
        <td><p>The type T does not implement either the IComparable or
IComparable&lt;T&gt; interfaces.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Wintellect_PowerCollections_BigList_1_Sort_" data-uid="Wintellect.PowerCollections.BigList`1.Sort*"></a>
  <h4 id="Wintellect_PowerCollections_BigList_1_Sort_System_Collections_Generic_IComparer__0__" data-uid="Wintellect.PowerCollections.BigList`1.Sort(System.Collections.Generic.IComparer{`0})">Sort(IComparer&lt;T&gt;)</h4>
  <div class="markdown level1 summary"><p>Sorts the list in place. A supplied IComparer&lt;T&gt; is used
to compare the items in the list.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public void Sort(IComparer&lt;T&gt; comparer)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Collections.Generic.IComparer</span>&lt;T&gt;</td>
        <td><span class="parametername">comparer</span></td>
        <td><p>The comparer instance used to compare items in the collection. Only
the Compare method is used.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="Wintellect_PowerCollections_BigList_1_Sort_System_Collections_Generic_IComparer__0___remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>The Quicksort algorithms is used to sort the items. In virtually all cases,
this takes time O(N log N), where N is the number of items in the list.</p>
</div>
  
  
  <a id="Wintellect_PowerCollections_BigList_1_Sort_" data-uid="Wintellect.PowerCollections.BigList`1.Sort*"></a>
  <h4 id="Wintellect_PowerCollections_BigList_1_Sort_System_Collections_Generic_IComparer__0__" data-uid="Wintellect.PowerCollections.BigList`1.Sort(System.Collections.Generic.IComparer{`0})">Sort(IComparer&lt;T&gt;)</h4>
  <div class="markdown level1 summary"><p>Sorts the list in place. A supplied IComparer&lt;T&gt; is used
to compare the items in the list.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public void Sort(IComparer&lt;T&gt; comparer)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Collections.Generic.IComparer</span>&lt;T&gt;</td>
        <td><span class="parametername">comparer</span></td>
        <td><p>The comparer instance used to compare items in the collection. Only
the Compare method is used.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="Wintellect_PowerCollections_BigList_1_Sort_System_Collections_Generic_IComparer__0___remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>The Quicksort algorithms is used to sort the items. In virtually all cases,
this takes time O(N log N), where N is the number of items in the list.</p>
</div>
  
  
  <a id="Wintellect_PowerCollections_BigList_1_Sort_" data-uid="Wintellect.PowerCollections.BigList`1.Sort*"></a>
  <h4 id="Wintellect_PowerCollections_BigList_1_Sort_System_Comparison__0__" data-uid="Wintellect.PowerCollections.BigList`1.Sort(System.Comparison{`0})">Sort(Comparison&lt;T&gt;)</h4>
  <div class="markdown level1 summary"><p>Sorts the list in place. A supplied Comparison&lt;T&gt; delegate is used
to compare the items in the list.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public void Sort(Comparison&lt;T&gt; comparison)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Comparison</span>&lt;T&gt;</td>
        <td><span class="parametername">comparison</span></td>
        <td><p>The comparison delegate used to compare items in the collection.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="Wintellect_PowerCollections_BigList_1_Sort_System_Comparison__0___remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>The Quicksort algorithms is used to sort the items. In virtually all cases,
this takes time O(N log N), where N is the number of items in the list.</p>
</div>
  
  
  <a id="Wintellect_PowerCollections_BigList_1_Sort_" data-uid="Wintellect.PowerCollections.BigList`1.Sort*"></a>
  <h4 id="Wintellect_PowerCollections_BigList_1_Sort_System_Comparison__0__" data-uid="Wintellect.PowerCollections.BigList`1.Sort(System.Comparison{`0})">Sort(Comparison&lt;T&gt;)</h4>
  <div class="markdown level1 summary"><p>Sorts the list in place. A supplied Comparison&lt;T&gt; delegate is used
to compare the items in the list.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public void Sort(Comparison&lt;T&gt; comparison)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Comparison</span>&lt;T&gt;</td>
        <td><span class="parametername">comparison</span></td>
        <td><p>The comparison delegate used to compare items in the collection.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="Wintellect_PowerCollections_BigList_1_Sort_System_Comparison__0___remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>The Quicksort algorithms is used to sort the items. In virtually all cases,
this takes time O(N log N), where N is the number of items in the list.</p>
</div>
  <h3 id="operators">Operators
  </h3>
  
  
  <a id="Wintellect_PowerCollections_BigList_1_op_Addition_" data-uid="Wintellect.PowerCollections.BigList`1.op_Addition*"></a>
  <h4 id="Wintellect_PowerCollections_BigList_1_op_Addition_Wintellect_PowerCollections_BigList__0__Wintellect_PowerCollections_BigList__0__" data-uid="Wintellect.PowerCollections.BigList`1.op_Addition(Wintellect.PowerCollections.BigList{`0},Wintellect.PowerCollections.BigList{`0})">Addition(BigList&lt;T&gt;, BigList&lt;T&gt;)</h4>
  <div class="markdown level1 summary"><p>Concatenates two lists together to create a new list. Both lists being concatenated
are unchanged. The resulting list contains all the items in <code data-dev-comment-type="paramref" class="paramref">first</code>, followed
by all the items in <code data-dev-comment-type="paramref" class="paramref">second</code>.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public static BigList&lt;T&gt; operator +(BigList&lt;T&gt; first, BigList&lt;T&gt; second)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Wintellect.PowerCollections.BigList-1.html">BigList</a>&lt;T&gt;</td>
        <td><span class="parametername">first</span></td>
        <td><p>The first list to concatenate.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="Wintellect.PowerCollections.BigList-1.html">BigList</a>&lt;T&gt;</td>
        <td><span class="parametername">second</span></td>
        <td><p>The second list to concatenate.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Wintellect.PowerCollections.BigList-1.html">BigList</a>&lt;T&gt;</td>
        <td></td>
      </tr>
    </tbody>
  </table>
  <h5 id="Wintellect_PowerCollections_BigList_1_op_Addition_Wintellect_PowerCollections_BigList__0__Wintellect_PowerCollections_BigList__0___remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>This method takes, on average, constant time, regardless of the size
of either list. Although conceptually all of the items in both lists are
copied, storage is shared until changes are made to the
shared sections.</p>
</div>
  <h5 class="exceptions">Exceptions</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Condition</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.ArgumentNullException</span></td>
        <td><p><code data-dev-comment-type="paramref" class="paramref">first</code> or <code data-dev-comment-type="paramref" class="paramref">second</code> is null.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Wintellect_PowerCollections_BigList_1_op_Addition_" data-uid="Wintellect.PowerCollections.BigList`1.op_Addition*"></a>
  <h4 id="Wintellect_PowerCollections_BigList_1_op_Addition_Wintellect_PowerCollections_BigList__0__Wintellect_PowerCollections_BigList__0__" data-uid="Wintellect.PowerCollections.BigList`1.op_Addition(Wintellect.PowerCollections.BigList{`0},Wintellect.PowerCollections.BigList{`0})">Addition(BigList&lt;T&gt;, BigList&lt;T&gt;)</h4>
  <div class="markdown level1 summary"><p>Concatenates two lists together to create a new list. Both lists being concatenated
are unchanged. The resulting list contains all the items in <code data-dev-comment-type="paramref" class="paramref">first</code>, followed
by all the items in <code data-dev-comment-type="paramref" class="paramref">second</code>.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public static BigList&lt;T&gt; operator +(BigList&lt;T&gt; first, BigList&lt;T&gt; second)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Wintellect.PowerCollections.BigList-1.html">BigList</a>&lt;T&gt;</td>
        <td><span class="parametername">first</span></td>
        <td><p>The first list to concatenate.</p>
</td>
      </tr>
      <tr>
        <td><a class="xref" href="Wintellect.PowerCollections.BigList-1.html">BigList</a>&lt;T&gt;</td>
        <td><span class="parametername">second</span></td>
        <td><p>The second list to concatenate.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Wintellect.PowerCollections.BigList-1.html">BigList</a>&lt;T&gt;</td>
        <td></td>
      </tr>
    </tbody>
  </table>
  <h5 id="Wintellect_PowerCollections_BigList_1_op_Addition_Wintellect_PowerCollections_BigList__0__Wintellect_PowerCollections_BigList__0___remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>This method takes, on average, constant time, regardless of the size
of either list. Although conceptually all of the items in both lists are
copied, storage is shared until changes are made to the
shared sections.</p>
</div>
  <h5 class="exceptions">Exceptions</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Condition</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.ArgumentNullException</span></td>
        <td><p><code data-dev-comment-type="paramref" class="paramref">first</code> or <code data-dev-comment-type="paramref" class="paramref">second</code> is null.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h3 id="eii">Explicit Interface Implementations
  </h3>
  
  
  <a id="Wintellect_PowerCollections_BigList_1_System_ICloneable_Clone_" data-uid="Wintellect.PowerCollections.BigList`1.System#ICloneable#Clone*"></a>
  <h4 id="Wintellect_PowerCollections_BigList_1_System_ICloneable_Clone" data-uid="Wintellect.PowerCollections.BigList`1.System#ICloneable#Clone">ICloneable.Clone()</h4>
  <div class="markdown level1 summary"><p>Creates a new BigList that is a copy of this list.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">object ICloneable.Clone()</code></pre>
  </div>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Object</span></td>
        <td><p>A copy of the current list</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="Wintellect_PowerCollections_BigList_1_System_ICloneable_Clone_remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>Copying a BigList takes constant time, and little
additional memory, since the storage for the items of the two lists is shared. However, changing
either list will take additional time and memory. Portions of the list are copied when they are changed.</p>
</div>
  
  
  <a id="Wintellect_PowerCollections_BigList_1_System_ICloneable_Clone_" data-uid="Wintellect.PowerCollections.BigList`1.System#ICloneable#Clone*"></a>
  <h4 id="Wintellect_PowerCollections_BigList_1_System_ICloneable_Clone" data-uid="Wintellect.PowerCollections.BigList`1.System#ICloneable#Clone">ICloneable.Clone()</h4>
  <div class="markdown level1 summary"><p>Creates a new BigList that is a copy of this list.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">object ICloneable.Clone()</code></pre>
  </div>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Object</span></td>
        <td><p>A copy of the current list</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="Wintellect_PowerCollections_BigList_1_System_ICloneable_Clone_remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>Copying a BigList takes constant time, and little
additional memory, since the storage for the items of the two lists is shared. However, changing
either list will take additional time and memory. Portions of the list are copied when they are changed.</p>
</div>
  <h3 id="implements">Implements</h3>
  <div>
      <span class="xref">System.Collections.Generic.IList&lt;T&gt;</span>
  </div>
  <div>
      <span class="xref">System.Collections.Generic.ICollection&lt;T&gt;</span>
  </div>
  <div>
      <span class="xref">System.Collections.Generic.IEnumerable&lt;T&gt;</span>
  </div>
  <div>
      <span class="xref">System.Collections.IList</span>
  </div>
  <div>
      <span class="xref">System.Collections.ICollection</span>
  </div>
  <div>
      <span class="xref">System.Collections.IEnumerable</span>
  </div>
  <div>
      <span class="xref">System.ICloneable</span>
  </div>
</article>
          </div>
          
          <div class="hidden-sm col-md-2" role="complementary">
            <div class="sideaffix">
              <div class="contribution">
                <ul class="nav">
                </ul>
              </div>
              <nav class="bs-docs-sidebar hidden-print hidden-xs hidden-sm affix" id="affix">
                <h5>In This Article</h5>
                <div></div>
              </nav>
            </div>
          </div>
        </div>
      </div>
      
      <footer>
        <div class="grad-bottom"></div>
        <div class="footer">
          <div class="container">
            <span class="pull-right">
              <a href="#top">Back to top</a>
            </span>
            
            <span>Generated by <strong>DocFX</strong></span>
          </div>
        </div>
      </footer>
    </div>
    
    <script type="text/javascript" src="../styles/docfx.vendor.js"></script>
    <script type="text/javascript" src="../styles/docfx.js"></script>
    <script type="text/javascript" src="../styles/main.js"></script>
  </body>
</html>
