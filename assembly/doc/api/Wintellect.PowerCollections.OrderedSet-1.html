<!DOCTYPE html>
<!--[if IE]><![endif]-->
<html>
  
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>Class OrderedSet&lt;T&gt;
   </title>
    <meta name="viewport" content="width=device-width">
    <meta name="title" content="Class OrderedSet&lt;T&gt;
   ">
    <meta name="generator" content="docfx 2.59.4.0">
    
    <link rel="shortcut icon" href="../favicon.ico">
    <link rel="stylesheet" href="../styles/docfx.vendor.css">
    <link rel="stylesheet" href="../styles/docfx.css">
    <link rel="stylesheet" href="../styles/main.css">
    <meta property="docfx:navrel" content="../toc">
    <meta property="docfx:tocrel" content="toc">
    
    
    
  </head>
  <body data-spy="scroll" data-target="#affix" data-offset="120">
    <div id="wrapper">
      <header>
        
        <nav id="autocollapse" class="navbar navbar-inverse ng-scope" role="navigation">
          <div class="container">
            <div class="navbar-header">
              <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#navbar">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
              </button>
              
              <a class="navbar-brand" href="../index.html">
                <img id="logo" class="svg" src="../logo.svg" alt="">
              </a>
            </div>
            <div class="collapse navbar-collapse" id="navbar">
              <form class="navbar-form navbar-right" role="search" id="search">
                <div class="form-group">
                  <input type="text" class="form-control" id="search-query" placeholder="Search" autocomplete="off">
                </div>
              </form>
                
                <ul class="nav level1 navbar-nav">
                      <li>
                          <a href=".././api/Wintellect.PowerCollections.html" title="Wintellect">Wintellect</a>
                      </li>
                </ul>    </div>
          </div>
        </nav>
        
        <div class="subnav navbar navbar-default">
          <div class="container hide-when-search" id="breadcrumb">
            <ul class="breadcrumb">
              <li></li>
            </ul>
          </div>
        </div>
      </header>
      <div role="main" class="container body-content hide-when-search">
        <div class="sidenav hide-when-search">
          <a class="btn toc-toggle collapse" data-toggle="collapse" href="#sidetoggle" aria-expanded="false" aria-controls="sidetoggle">Show / Hide Table of Contents</a>
          <div class="sidetoggle collapse" id="sidetoggle">
            <div>
              <div class="sidefilter">
                <form class="toc-filter">
                  <span class="glyphicon glyphicon-filter filter-icon"></span>
                  <input type="text" id="toc_filter_input" placeholder="Enter here to filter..." onkeypress="if(event.keyCode==13) {return false;}">
                </form>
              </div>
              <div class="sidetoc">
                <div class="toc" id="toc">
                  
                  <ul class="nav level1">
                    <li class="">
                      <span class="expand-stub"></span>
                      <a href="Wintellect.PowerCollections.html" title="Wintellect.PowerCollections" class="">Wintellect.PowerCollections</a>
                        
                        <ul class="nav level2">
                          <li class="">
                            <a href="Wintellect.PowerCollections.Algorithms.html" title="Algorithms" class="">Algorithms</a>
                          </li>
                          <li class="">
                            <a href="Wintellect.PowerCollections.Bag-1.html" title="Bag&lt;T&gt;" class="">Bag&lt;T&gt;</a>
                          </li>
                          <li class="">
                            <a href="Wintellect.PowerCollections.BigList-1.html" title="BigList&lt;T&gt;" class="">BigList&lt;T&gt;</a>
                          </li>
                          <li class="">
                            <a href="Wintellect.PowerCollections.BinaryPredicate-1.html" title="BinaryPredicate&lt;T&gt;" class="">BinaryPredicate&lt;T&gt;</a>
                          </li>
                          <li class="">
                            <a href="Wintellect.PowerCollections.BinaryPredicate-1.html" title="BinaryPredicate&lt;T&gt;" class="">BinaryPredicate&lt;T&gt;</a>
                          </li>
                          <li class="">
                            <a href="Wintellect.PowerCollections.CollectionBase-1.html" title="CollectionBase&lt;T&gt;" class="">CollectionBase&lt;T&gt;</a>
                          </li>
                          <li class="">
                            <a href="Wintellect.PowerCollections.Deque-1.html" title="Deque&lt;T&gt;" class="">Deque&lt;T&gt;</a>
                          </li>
                          <li class="">
                            <a href="Wintellect.PowerCollections.DictionaryBase-2.html" title="DictionaryBase&lt;TKey, TValue&gt;" class="">DictionaryBase&lt;TKey, TValue&gt;</a>
                          </li>
                          <li class="">
                            <a href="Wintellect.PowerCollections.ListBase-1.html" title="ListBase&lt;T&gt;" class="">ListBase&lt;T&gt;</a>
                          </li>
                          <li class="">
                            <a href="Wintellect.PowerCollections.MultiDictionary-2.html" title="MultiDictionary&lt;TKey, TValue&gt;" class="">MultiDictionary&lt;TKey, TValue&gt;</a>
                          </li>
                          <li class="">
                            <a href="Wintellect.PowerCollections.MultiDictionaryBase-2.html" title="MultiDictionaryBase&lt;TKey, TValue&gt;" class="">MultiDictionaryBase&lt;TKey, TValue&gt;</a>
                          </li>
                          <li class="">
                            <a href="Wintellect.PowerCollections.OrderedBag-1.html" title="OrderedBag&lt;T&gt;" class="">OrderedBag&lt;T&gt;</a>
                          </li>
                          <li class="">
                            <a href="Wintellect.PowerCollections.OrderedBag-1.View.html" title="OrderedBag&lt;T&gt;.View" class="">OrderedBag&lt;T&gt;.View</a>
                          </li>
                          <li class="">
                            <a href="Wintellect.PowerCollections.OrderedDictionary-2.html" title="OrderedDictionary&lt;TKey, TValue&gt;" class="">OrderedDictionary&lt;TKey, TValue&gt;</a>
                          </li>
                          <li class="">
                            <a href="Wintellect.PowerCollections.OrderedDictionary-2.View.html" title="OrderedDictionary&lt;TKey, TValue&gt;.View" class="">OrderedDictionary&lt;TKey, TValue&gt;.View</a>
                          </li>
                          <li class="">
                            <a href="Wintellect.PowerCollections.OrderedMultiDictionary-2.html" title="OrderedMultiDictionary&lt;TKey, TValue&gt;" class="">OrderedMultiDictionary&lt;TKey, TValue&gt;</a>
                          </li>
                          <li class="">
                            <a href="Wintellect.PowerCollections.OrderedMultiDictionary-2.View.html" title="OrderedMultiDictionary&lt;TKey, TValue&gt;.View" class="">OrderedMultiDictionary&lt;TKey, TValue&gt;.View</a>
                          </li>
                          <li class="active">
                            <a href="Wintellect.PowerCollections.OrderedSet-1.html" title="OrderedSet&lt;T&gt;" class="active">OrderedSet&lt;T&gt;</a>
                          </li>
                          <li class="">
                            <a href="Wintellect.PowerCollections.OrderedSet-1.View.html" title="OrderedSet&lt;T&gt;.View" class="">OrderedSet&lt;T&gt;.View</a>
                          </li>
                          <li class="">
                            <a href="Wintellect.PowerCollections.Pair-2.html" title="Pair&lt;TFirst, TSecond&gt;" class="">Pair&lt;TFirst, TSecond&gt;</a>
                          </li>
                          <li class="">
                            <a href="Wintellect.PowerCollections.ReadOnlyCollectionBase-1.html" title="ReadOnlyCollectionBase&lt;T&gt;" class="">ReadOnlyCollectionBase&lt;T&gt;</a>
                          </li>
                          <li class="">
                            <a href="Wintellect.PowerCollections.ReadOnlyDictionaryBase-2.html" title="ReadOnlyDictionaryBase&lt;TKey, TValue&gt;" class="">ReadOnlyDictionaryBase&lt;TKey, TValue&gt;</a>
                          </li>
                          <li class="">
                            <a href="Wintellect.PowerCollections.ReadOnlyListBase-1.html" title="ReadOnlyListBase&lt;T&gt;" class="">ReadOnlyListBase&lt;T&gt;</a>
                          </li>
                          <li class="">
                            <a href="Wintellect.PowerCollections.ReadOnlyMultiDictionaryBase-2.html" title="ReadOnlyMultiDictionaryBase&lt;TKey, TValue&gt;" class="">ReadOnlyMultiDictionaryBase&lt;TKey, TValue&gt;</a>
                          </li>
                          <li class="">
                            <a href="Wintellect.PowerCollections.Set-1.html" title="Set&lt;T&gt;" class="">Set&lt;T&gt;</a>
                          </li>
                          <li class="">
                            <a href="Wintellect.PowerCollections.Stack-1.html" title="Stack&lt;T&gt;" class="">Stack&lt;T&gt;</a>
                          </li>
                          <li class="">
                            <a href="Wintellect.PowerCollections.Triple-3.html" title="Triple&lt;TFirst, TSecond, TThird&gt;" class="">Triple&lt;TFirst, TSecond, TThird&gt;</a>
                          </li>
                        </ul>  </li>
                  </ul>        </div>
              </div>
            </div>
          </div>
        </div>
        <div class="article row grid-right">
          <div class="col-md-10">
            <article class="content wrap" id="_content" data-uid="Wintellect.PowerCollections.OrderedSet`1">
  
  
  <h1 id="Wintellect_PowerCollections_OrderedSet_1" data-uid="Wintellect.PowerCollections.OrderedSet`1" class="text-break">Class OrderedSet&lt;T&gt;
  </h1>
  <div class="markdown level0 summary"><p>OrderedSet&lt;T&gt; is a collection that contains items of type T.
The item are maintained in a sorted order, and duplicate items are not allowed. Each item has
an index in the set: the smallest item has index 0, the next smallest item has index 1,
and so forth.</p>
</div>
  <div class="markdown level0 conceptual"></div>
  <div class="inheritance">
    <h5>Inheritance</h5>
    <div class="level0"><span class="xref">System.Object</span></div>
    <div class="level1"><a class="xref" href="Wintellect.PowerCollections.CollectionBase-1.html">CollectionBase</a>&lt;T&gt;</div>
    <div class="level2"><span class="xref">OrderedSet&lt;T&gt;</span></div>
  </div>
  <div class="implements">
    <h5>Implements</h5>
    <div><span class="xref">System.Collections.ICollection</span></div>
    <div><span class="xref">System.Collections.Generic.ICollection</span>&lt;T&gt;</div>
    <div><span class="xref">System.Collections.Generic.IEnumerable</span>&lt;T&gt;</div>
    <div><span class="xref">System.Collections.IEnumerable</span></div>
    <div><span class="xref">System.ICloneable</span></div>
  </div>
  <div class="inheritedMembers">
    <h5>Inherited Members</h5>
    <div>
      <a class="xref" href="Wintellect.PowerCollections.CollectionBase-1.html#Wintellect_PowerCollections_CollectionBase_1_ToString">CollectionBase&lt;T&gt;.ToString()</a>
    </div>
    <div>
      <a class="xref" href="Wintellect.PowerCollections.CollectionBase-1.html#Wintellect_PowerCollections_CollectionBase_1_CopyTo__0___System_Int32_">CollectionBase&lt;T&gt;.CopyTo(T[], Int32)</a>
    </div>
    <div>
      <a class="xref" href="Wintellect.PowerCollections.CollectionBase-1.html#Wintellect_PowerCollections_CollectionBase_1_ToArray">CollectionBase&lt;T&gt;.ToArray()</a>
    </div>
    <div>
      <a class="xref" href="Wintellect.PowerCollections.CollectionBase-1.html#Wintellect_PowerCollections_CollectionBase_1_System_Collections_Generic_ICollection_T__IsReadOnly">CollectionBase&lt;T&gt;.ICollection&lt;T&gt;.IsReadOnly</a>
    </div>
    <div>
      <a class="xref" href="Wintellect.PowerCollections.CollectionBase-1.html#Wintellect_PowerCollections_CollectionBase_1_AsReadOnly">CollectionBase&lt;T&gt;.AsReadOnly()</a>
    </div>
    <div>
      <a class="xref" href="Wintellect.PowerCollections.CollectionBase-1.html#Wintellect_PowerCollections_CollectionBase_1_Exists_System_Predicate__0__">CollectionBase&lt;T&gt;.Exists(Predicate&lt;T&gt;)</a>
    </div>
    <div>
      <a class="xref" href="Wintellect.PowerCollections.CollectionBase-1.html#Wintellect_PowerCollections_CollectionBase_1_TrueForAll_System_Predicate__0__">CollectionBase&lt;T&gt;.TrueForAll(Predicate&lt;T&gt;)</a>
    </div>
    <div>
      <a class="xref" href="Wintellect.PowerCollections.CollectionBase-1.html#Wintellect_PowerCollections_CollectionBase_1_CountWhere_System_Predicate__0__">CollectionBase&lt;T&gt;.CountWhere(Predicate&lt;T&gt;)</a>
    </div>
    <div>
      <a class="xref" href="Wintellect.PowerCollections.CollectionBase-1.html#Wintellect_PowerCollections_CollectionBase_1_FindAll_System_Predicate__0__">CollectionBase&lt;T&gt;.FindAll(Predicate&lt;T&gt;)</a>
    </div>
    <div>
      <a class="xref" href="Wintellect.PowerCollections.CollectionBase-1.html#Wintellect_PowerCollections_CollectionBase_1_RemoveAll_System_Predicate__0__">CollectionBase&lt;T&gt;.RemoveAll(Predicate&lt;T&gt;)</a>
    </div>
    <div>
      <a class="xref" href="Wintellect.PowerCollections.CollectionBase-1.html#Wintellect_PowerCollections_CollectionBase_1_ForEach_System_Action__0__">CollectionBase&lt;T&gt;.ForEach(Action&lt;T&gt;)</a>
    </div>
    <div>
      <a class="xref" href="Wintellect.PowerCollections.CollectionBase-1.html#Wintellect_PowerCollections_CollectionBase_1_ConvertAll__1_System_Converter__0___0__">CollectionBase&lt;T&gt;.ConvertAll&lt;TOutput&gt;(Converter&lt;T, TOutput&gt;)</a>
    </div>
    <div>
      <a class="xref" href="Wintellect.PowerCollections.CollectionBase-1.html#Wintellect_PowerCollections_CollectionBase_1_System_Collections_ICollection_CopyTo_System_Array_System_Int32_">CollectionBase&lt;T&gt;.ICollection.CopyTo(Array, Int32)</a>
    </div>
    <div>
      <a class="xref" href="Wintellect.PowerCollections.CollectionBase-1.html#Wintellect_PowerCollections_CollectionBase_1_System_Collections_ICollection_IsSynchronized">CollectionBase&lt;T&gt;.ICollection.IsSynchronized</a>
    </div>
    <div>
      <a class="xref" href="Wintellect.PowerCollections.CollectionBase-1.html#Wintellect_PowerCollections_CollectionBase_1_System_Collections_ICollection_SyncRoot">CollectionBase&lt;T&gt;.ICollection.SyncRoot</a>
    </div>
    <div>
      <a class="xref" href="Wintellect.PowerCollections.CollectionBase-1.html#Wintellect_PowerCollections_CollectionBase_1_System_Collections_IEnumerable_GetEnumerator">CollectionBase&lt;T&gt;.IEnumerable.GetEnumerator()</a>
    </div>
    <div>
      <span class="xref">System.Object.Equals(System.Object)</span>
    </div>
    <div>
      <span class="xref">System.Object.Equals(System.Object, System.Object)</span>
    </div>
    <div>
      <span class="xref">System.Object.ReferenceEquals(System.Object, System.Object)</span>
    </div>
    <div>
      <span class="xref">System.Object.GetHashCode()</span>
    </div>
    <div>
      <span class="xref">System.Object.GetType()</span>
    </div>
    <div>
      <span class="xref">System.Object.MemberwiseClone()</span>
    </div>
  </div>
  <h6><strong>Namespace</strong>: <a class="xref" href="Wintellect.PowerCollections.html">Wintellect.PowerCollections</a></h6>
  <h6><strong>Assembly</strong>: cs.temp.dll.dll</h6>
  <h5 id="Wintellect_PowerCollections_OrderedSet_1_syntax">Syntax</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Serializable]
[Serializable]
public class OrderedSet&lt;T&gt; : CollectionBase&lt;T&gt;, ICollection, ICollection&lt;T&gt;, IEnumerable&lt;T&gt;, IEnumerable, ICloneable</code></pre>
  </div>
  <h5 class="typeParameters">Type Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="parametername">T</span></td>
        <td></td>
      </tr>
    </tbody>
  </table>
  <h5 id="Wintellect_PowerCollections_OrderedSet_1_remarks"><strong>Remarks</strong></h5>
  <div class="markdown level0 remarks"><p>The items are compared in one of three ways. If T implements IComparable&lt;TKey> or IComparable,
then the CompareTo method of that interface will be used to compare items. Alternatively, a comparison
function can be passed in either as a delegate, or as an instance of IComparer&lt;TKey>.</p>
<p>OrderedSet is implemented as a balanced binary tree. Inserting, deleting, and looking up an
an element all are done in log(N) type, where N is the number of keys in the tree.</p>
<p><a class="xref" href="Wintellect.PowerCollections.Set-1.html">Set&lt;T&gt;</a> is similar, but uses hashing instead of comparison, and does not maintain
the items in sorted order.</p>
</div>
  <h3 id="constructors">Constructors
  </h3>
  
  
  <a id="Wintellect_PowerCollections_OrderedSet_1__ctor_" data-uid="Wintellect.PowerCollections.OrderedSet`1.#ctor*"></a>
  <h4 id="Wintellect_PowerCollections_OrderedSet_1__ctor" data-uid="Wintellect.PowerCollections.OrderedSet`1.#ctor">OrderedSet()</h4>
  <div class="markdown level1 summary"><p>Creates a new OrderedSet. The T must implement IComparable&lt;T&gt;
or IComparable.
The CompareTo method of this interface will be used to compare items in this set.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public OrderedSet()</code></pre>
  </div>
  <h5 id="Wintellect_PowerCollections_OrderedSet_1__ctor_remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>Items that are null are permitted, and will be sorted before all other items.</p>
</div>
  <h5 class="exceptions">Exceptions</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Condition</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.InvalidOperationException</span></td>
        <td><p>T does not implement IComparable&lt;TKey&gt;.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Wintellect_PowerCollections_OrderedSet_1__ctor_" data-uid="Wintellect.PowerCollections.OrderedSet`1.#ctor*"></a>
  <h4 id="Wintellect_PowerCollections_OrderedSet_1__ctor" data-uid="Wintellect.PowerCollections.OrderedSet`1.#ctor">OrderedSet()</h4>
  <div class="markdown level1 summary"><p>Creates a new OrderedSet. The T must implement IComparable&lt;T&gt;
or IComparable.
The CompareTo method of this interface will be used to compare items in this set.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public OrderedSet()</code></pre>
  </div>
  <h5 id="Wintellect_PowerCollections_OrderedSet_1__ctor_remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>Items that are null are permitted, and will be sorted before all other items.</p>
</div>
  <h5 class="exceptions">Exceptions</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Condition</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.InvalidOperationException</span></td>
        <td><p>T does not implement IComparable&lt;TKey&gt;.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Wintellect_PowerCollections_OrderedSet_1__ctor_" data-uid="Wintellect.PowerCollections.OrderedSet`1.#ctor*"></a>
  <h4 id="Wintellect_PowerCollections_OrderedSet_1__ctor_System_Collections_Generic_IComparer__0__" data-uid="Wintellect.PowerCollections.OrderedSet`1.#ctor(System.Collections.Generic.IComparer{`0})">OrderedSet(IComparer&lt;T&gt;)</h4>
  <div class="markdown level1 summary"><p>Creates a new OrderedSet. The Compare method of the passed comparison object
will be used to compare items in this set.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public OrderedSet(IComparer&lt;T&gt; comparer)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Collections.Generic.IComparer</span>&lt;T&gt;</td>
        <td><span class="parametername">comparer</span></td>
        <td><p>An instance of IComparer&lt;T&gt; that will be used to compare items.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="Wintellect_PowerCollections_OrderedSet_1__ctor_System_Collections_Generic_IComparer__0___remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>The GetHashCode and Equals methods of the provided IComparer&lt;T&gt; will never
be called, and need not be implemented.</p>
</div>
  
  
  <a id="Wintellect_PowerCollections_OrderedSet_1__ctor_" data-uid="Wintellect.PowerCollections.OrderedSet`1.#ctor*"></a>
  <h4 id="Wintellect_PowerCollections_OrderedSet_1__ctor_System_Collections_Generic_IComparer__0__" data-uid="Wintellect.PowerCollections.OrderedSet`1.#ctor(System.Collections.Generic.IComparer{`0})">OrderedSet(IComparer&lt;T&gt;)</h4>
  <div class="markdown level1 summary"><p>Creates a new OrderedSet. The Compare method of the passed comparison object
will be used to compare items in this set.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public OrderedSet(IComparer&lt;T&gt; comparer)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Collections.Generic.IComparer</span>&lt;T&gt;</td>
        <td><span class="parametername">comparer</span></td>
        <td><p>An instance of IComparer&lt;T&gt; that will be used to compare items.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="Wintellect_PowerCollections_OrderedSet_1__ctor_System_Collections_Generic_IComparer__0___remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>The GetHashCode and Equals methods of the provided IComparer&lt;T&gt; will never
be called, and need not be implemented.</p>
</div>
  
  
  <a id="Wintellect_PowerCollections_OrderedSet_1__ctor_" data-uid="Wintellect.PowerCollections.OrderedSet`1.#ctor*"></a>
  <h4 id="Wintellect_PowerCollections_OrderedSet_1__ctor_System_Collections_Generic_IEnumerable__0__" data-uid="Wintellect.PowerCollections.OrderedSet`1.#ctor(System.Collections.Generic.IEnumerable{`0})">OrderedSet(IEnumerable&lt;T&gt;)</h4>
  <div class="markdown level1 summary"><p>Creates a new OrderedSet. The T must implement IComparable&lt;T&gt;
or IComparable.
The CompareTo method of this interface will be used to compare items in this set. The set is
initialized with all the items in the given collection.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public OrderedSet(IEnumerable&lt;T&gt; collection)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Collections.Generic.IEnumerable</span>&lt;T&gt;</td>
        <td><span class="parametername">collection</span></td>
        <td><p>A collection with items to be placed into the OrderedSet.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="Wintellect_PowerCollections_OrderedSet_1__ctor_System_Collections_Generic_IEnumerable__0___remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>Items that are null are permitted, and will be sorted before all other items.</p>
</div>
  <h5 class="exceptions">Exceptions</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Condition</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.InvalidOperationException</span></td>
        <td><p>T does not implement IComparable&lt;TKey&gt;.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Wintellect_PowerCollections_OrderedSet_1__ctor_" data-uid="Wintellect.PowerCollections.OrderedSet`1.#ctor*"></a>
  <h4 id="Wintellect_PowerCollections_OrderedSet_1__ctor_System_Collections_Generic_IEnumerable__0__" data-uid="Wintellect.PowerCollections.OrderedSet`1.#ctor(System.Collections.Generic.IEnumerable{`0})">OrderedSet(IEnumerable&lt;T&gt;)</h4>
  <div class="markdown level1 summary"><p>Creates a new OrderedSet. The T must implement IComparable&lt;T&gt;
or IComparable.
The CompareTo method of this interface will be used to compare items in this set. The set is
initialized with all the items in the given collection.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public OrderedSet(IEnumerable&lt;T&gt; collection)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Collections.Generic.IEnumerable</span>&lt;T&gt;</td>
        <td><span class="parametername">collection</span></td>
        <td><p>A collection with items to be placed into the OrderedSet.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="Wintellect_PowerCollections_OrderedSet_1__ctor_System_Collections_Generic_IEnumerable__0___remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>Items that are null are permitted, and will be sorted before all other items.</p>
</div>
  <h5 class="exceptions">Exceptions</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Condition</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.InvalidOperationException</span></td>
        <td><p>T does not implement IComparable&lt;TKey&gt;.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Wintellect_PowerCollections_OrderedSet_1__ctor_" data-uid="Wintellect.PowerCollections.OrderedSet`1.#ctor*"></a>
  <h4 id="Wintellect_PowerCollections_OrderedSet_1__ctor_System_Collections_Generic_IEnumerable__0__System_Collections_Generic_IComparer__0__" data-uid="Wintellect.PowerCollections.OrderedSet`1.#ctor(System.Collections.Generic.IEnumerable{`0},System.Collections.Generic.IComparer{`0})">OrderedSet(IEnumerable&lt;T&gt;, IComparer&lt;T&gt;)</h4>
  <div class="markdown level1 summary"><p>Creates a new OrderedSet. The Compare method of the passed comparison object
will be used to compare items in this set. The set is
initialized with all the items in the given collection.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public OrderedSet(IEnumerable&lt;T&gt; collection, IComparer&lt;T&gt; comparer)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Collections.Generic.IEnumerable</span>&lt;T&gt;</td>
        <td><span class="parametername">collection</span></td>
        <td><p>A collection with items to be placed into the OrderedSet.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Collections.Generic.IComparer</span>&lt;T&gt;</td>
        <td><span class="parametername">comparer</span></td>
        <td><p>An instance of IComparer&lt;T&gt; that will be used to compare items.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="Wintellect_PowerCollections_OrderedSet_1__ctor_System_Collections_Generic_IEnumerable__0__System_Collections_Generic_IComparer__0___remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>The GetHashCode and Equals methods of the provided IComparer&lt;T&gt; will never
be called, and need not be implemented.</p>
</div>
  
  
  <a id="Wintellect_PowerCollections_OrderedSet_1__ctor_" data-uid="Wintellect.PowerCollections.OrderedSet`1.#ctor*"></a>
  <h4 id="Wintellect_PowerCollections_OrderedSet_1__ctor_System_Collections_Generic_IEnumerable__0__System_Collections_Generic_IComparer__0__" data-uid="Wintellect.PowerCollections.OrderedSet`1.#ctor(System.Collections.Generic.IEnumerable{`0},System.Collections.Generic.IComparer{`0})">OrderedSet(IEnumerable&lt;T&gt;, IComparer&lt;T&gt;)</h4>
  <div class="markdown level1 summary"><p>Creates a new OrderedSet. The Compare method of the passed comparison object
will be used to compare items in this set. The set is
initialized with all the items in the given collection.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public OrderedSet(IEnumerable&lt;T&gt; collection, IComparer&lt;T&gt; comparer)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Collections.Generic.IEnumerable</span>&lt;T&gt;</td>
        <td><span class="parametername">collection</span></td>
        <td><p>A collection with items to be placed into the OrderedSet.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Collections.Generic.IComparer</span>&lt;T&gt;</td>
        <td><span class="parametername">comparer</span></td>
        <td><p>An instance of IComparer&lt;T&gt; that will be used to compare items.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="Wintellect_PowerCollections_OrderedSet_1__ctor_System_Collections_Generic_IEnumerable__0__System_Collections_Generic_IComparer__0___remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>The GetHashCode and Equals methods of the provided IComparer&lt;T&gt; will never
be called, and need not be implemented.</p>
</div>
  
  
  <a id="Wintellect_PowerCollections_OrderedSet_1__ctor_" data-uid="Wintellect.PowerCollections.OrderedSet`1.#ctor*"></a>
  <h4 id="Wintellect_PowerCollections_OrderedSet_1__ctor_System_Collections_Generic_IEnumerable__0__System_Comparison__0__" data-uid="Wintellect.PowerCollections.OrderedSet`1.#ctor(System.Collections.Generic.IEnumerable{`0},System.Comparison{`0})">OrderedSet(IEnumerable&lt;T&gt;, Comparison&lt;T&gt;)</h4>
  <div class="markdown level1 summary"><p>Creates a new OrderedSet. The passed delegate will be used to compare items in this set.
The set is initialized with all the items in the given collection.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public OrderedSet(IEnumerable&lt;T&gt; collection, Comparison&lt;T&gt; comparison)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Collections.Generic.IEnumerable</span>&lt;T&gt;</td>
        <td><span class="parametername">collection</span></td>
        <td><p>A collection with items to be placed into the OrderedSet.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Comparison</span>&lt;T&gt;</td>
        <td><span class="parametername">comparison</span></td>
        <td><p>A delegate to a method that will be used to compare items.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Wintellect_PowerCollections_OrderedSet_1__ctor_" data-uid="Wintellect.PowerCollections.OrderedSet`1.#ctor*"></a>
  <h4 id="Wintellect_PowerCollections_OrderedSet_1__ctor_System_Collections_Generic_IEnumerable__0__System_Comparison__0__" data-uid="Wintellect.PowerCollections.OrderedSet`1.#ctor(System.Collections.Generic.IEnumerable{`0},System.Comparison{`0})">OrderedSet(IEnumerable&lt;T&gt;, Comparison&lt;T&gt;)</h4>
  <div class="markdown level1 summary"><p>Creates a new OrderedSet. The passed delegate will be used to compare items in this set.
The set is initialized with all the items in the given collection.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public OrderedSet(IEnumerable&lt;T&gt; collection, Comparison&lt;T&gt; comparison)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Collections.Generic.IEnumerable</span>&lt;T&gt;</td>
        <td><span class="parametername">collection</span></td>
        <td><p>A collection with items to be placed into the OrderedSet.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Comparison</span>&lt;T&gt;</td>
        <td><span class="parametername">comparison</span></td>
        <td><p>A delegate to a method that will be used to compare items.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Wintellect_PowerCollections_OrderedSet_1__ctor_" data-uid="Wintellect.PowerCollections.OrderedSet`1.#ctor*"></a>
  <h4 id="Wintellect_PowerCollections_OrderedSet_1__ctor_System_Comparison__0__" data-uid="Wintellect.PowerCollections.OrderedSet`1.#ctor(System.Comparison{`0})">OrderedSet(Comparison&lt;T&gt;)</h4>
  <div class="markdown level1 summary"><p>Creates a new OrderedSet. The passed delegate will be used to compare items in this set.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public OrderedSet(Comparison&lt;T&gt; comparison)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Comparison</span>&lt;T&gt;</td>
        <td><span class="parametername">comparison</span></td>
        <td><p>A delegate to a method that will be used to compare items.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Wintellect_PowerCollections_OrderedSet_1__ctor_" data-uid="Wintellect.PowerCollections.OrderedSet`1.#ctor*"></a>
  <h4 id="Wintellect_PowerCollections_OrderedSet_1__ctor_System_Comparison__0__" data-uid="Wintellect.PowerCollections.OrderedSet`1.#ctor(System.Comparison{`0})">OrderedSet(Comparison&lt;T&gt;)</h4>
  <div class="markdown level1 summary"><p>Creates a new OrderedSet. The passed delegate will be used to compare items in this set.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public OrderedSet(Comparison&lt;T&gt; comparison)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Comparison</span>&lt;T&gt;</td>
        <td><span class="parametername">comparison</span></td>
        <td><p>A delegate to a method that will be used to compare items.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h3 id="properties">Properties
  </h3>
  
  
  <a id="Wintellect_PowerCollections_OrderedSet_1_Comparer_" data-uid="Wintellect.PowerCollections.OrderedSet`1.Comparer*"></a>
  <h4 id="Wintellect_PowerCollections_OrderedSet_1_Comparer" data-uid="Wintellect.PowerCollections.OrderedSet`1.Comparer">Comparer</h4>
  <div class="markdown level1 summary"><p>Returns the IComparer&lt;T&gt; used to compare items in this set.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public IComparer&lt;T&gt; Comparer { get; }</code></pre>
  </div>
  <h5 class="propertyValue">Property Value</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Collections.Generic.IComparer</span>&lt;T&gt;</td>
        <td><p>If the set was created using a comparer, that comparer is returned. If the set was
created using a comparison delegate, then a comparer equivalent to that delegate
is returned. Otherwise
the default comparer for T (Comparer&lt;T&gt;.Default) is returned.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Wintellect_PowerCollections_OrderedSet_1_Comparer_" data-uid="Wintellect.PowerCollections.OrderedSet`1.Comparer*"></a>
  <h4 id="Wintellect_PowerCollections_OrderedSet_1_Comparer" data-uid="Wintellect.PowerCollections.OrderedSet`1.Comparer">Comparer</h4>
  <div class="markdown level1 summary"><p>Returns the IComparer&lt;T&gt; used to compare items in this set.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public IComparer&lt;T&gt; Comparer { get; }</code></pre>
  </div>
  <h5 class="propertyValue">Property Value</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Collections.Generic.IComparer</span>&lt;T&gt;</td>
        <td><p>If the set was created using a comparer, that comparer is returned. If the set was
created using a comparison delegate, then a comparer equivalent to that delegate
is returned. Otherwise
the default comparer for T (Comparer&lt;T&gt;.Default) is returned.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Wintellect_PowerCollections_OrderedSet_1_Count_" data-uid="Wintellect.PowerCollections.OrderedSet`1.Count*"></a>
  <h4 id="Wintellect_PowerCollections_OrderedSet_1_Count" data-uid="Wintellect.PowerCollections.OrderedSet`1.Count">Count</h4>
  <div class="markdown level1 summary"><p>Returns the number of items in the set.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public sealed override int Count { get; }</code></pre>
  </div>
  <h5 class="propertyValue">Property Value</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Int32</span></td>
        <td><p>The number of items in the set.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="overrides">Overrides</h5>
  <div><span class="xref">Wintellect.PowerCollections.CollectionBase&lt;T&gt;.Count</span></div>
  <h5 id="Wintellect_PowerCollections_OrderedSet_1_Count_remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>The size of the set is returned in constant time.</p>
</div>
  
  
  <a id="Wintellect_PowerCollections_OrderedSet_1_Count_" data-uid="Wintellect.PowerCollections.OrderedSet`1.Count*"></a>
  <h4 id="Wintellect_PowerCollections_OrderedSet_1_Count" data-uid="Wintellect.PowerCollections.OrderedSet`1.Count">Count</h4>
  <div class="markdown level1 summary"><p>Returns the number of items in the set.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public sealed override int Count { get; }</code></pre>
  </div>
  <h5 class="propertyValue">Property Value</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Int32</span></td>
        <td><p>The number of items in the set.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="overrides">Overrides</h5>
  <div><span class="xref">Wintellect.PowerCollections.CollectionBase&lt;T&gt;.Count</span></div>
  <h5 id="Wintellect_PowerCollections_OrderedSet_1_Count_remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>The size of the set is returned in constant time.</p>
</div>
  
  
  <a id="Wintellect_PowerCollections_OrderedSet_1_Item_" data-uid="Wintellect.PowerCollections.OrderedSet`1.Item*"></a>
  <h4 id="Wintellect_PowerCollections_OrderedSet_1_Item_System_Int32_" data-uid="Wintellect.PowerCollections.OrderedSet`1.Item(System.Int32)">Item[Int32]</h4>
  <div class="markdown level1 summary"><p>Get the item by its index in the sorted order. The smallest item has index 0,
the next smallest item has index 1, and the largest item has index Count-1.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public T this[int index] { get; }</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Int32</span></td>
        <td><span class="parametername">index</span></td>
        <td><p>The index to get the item by.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="propertyValue">Property Value</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">T</span></td>
        <td><p>The item at the given index.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="Wintellect_PowerCollections_OrderedSet_1_Item_System_Int32__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>The indexer takes time O(log N), which N is the number of items in
the set.</p>
</div>
  <h5 class="exceptions">Exceptions</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Condition</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.ArgumentOutOfRangeException</span></td>
        <td><p><code data-dev-comment-type="paramref" class="paramref">index</code> is
less than zero or greater than or equal to Count.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Wintellect_PowerCollections_OrderedSet_1_Item_" data-uid="Wintellect.PowerCollections.OrderedSet`1.Item*"></a>
  <h4 id="Wintellect_PowerCollections_OrderedSet_1_Item_System_Int32_" data-uid="Wintellect.PowerCollections.OrderedSet`1.Item(System.Int32)">Item[Int32]</h4>
  <div class="markdown level1 summary"><p>Get the item by its index in the sorted order. The smallest item has index 0,
the next smallest item has index 1, and the largest item has index Count-1.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public T this[int index] { get; }</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Int32</span></td>
        <td><span class="parametername">index</span></td>
        <td><p>The index to get the item by.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="propertyValue">Property Value</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">T</span></td>
        <td><p>The item at the given index.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="Wintellect_PowerCollections_OrderedSet_1_Item_System_Int32__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>The indexer takes time O(log N), which N is the number of items in
the set.</p>
</div>
  <h5 class="exceptions">Exceptions</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Condition</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.ArgumentOutOfRangeException</span></td>
        <td><p><code data-dev-comment-type="paramref" class="paramref">index</code> is
less than zero or greater than or equal to Count.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h3 id="methods">Methods
  </h3>
  
  
  <a id="Wintellect_PowerCollections_OrderedSet_1_Add_" data-uid="Wintellect.PowerCollections.OrderedSet`1.Add*"></a>
  <h4 id="Wintellect_PowerCollections_OrderedSet_1_Add__0_" data-uid="Wintellect.PowerCollections.OrderedSet`1.Add(`0)">Add(T)</h4>
  <div class="markdown level1 summary"><p>Adds a new item to the set. If the set already contains an item equal to
<code data-dev-comment-type="paramref" class="paramref">item</code>, that item is replaced with <code data-dev-comment-type="paramref" class="paramref">item</code>.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public bool Add(T item)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">T</span></td>
        <td><span class="parametername">item</span></td>
        <td><p>The item to add to the set.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Boolean</span></td>
        <td><p>True if the set already contained an item equal to <code data-dev-comment-type="paramref" class="paramref">item</code> (which was replaced), false
otherwise.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="Wintellect_PowerCollections_OrderedSet_1_Add__0__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>Equality between items is determined by the comparison instance or delegate used
to create the set.</p>
<p>Adding an item takes time O(log N), where N is the number of items in the set.</p>
</div>
  
  
  <a id="Wintellect_PowerCollections_OrderedSet_1_Add_" data-uid="Wintellect.PowerCollections.OrderedSet`1.Add*"></a>
  <h4 id="Wintellect_PowerCollections_OrderedSet_1_Add__0_" data-uid="Wintellect.PowerCollections.OrderedSet`1.Add(`0)">Add(T)</h4>
  <div class="markdown level1 summary"><p>Adds a new item to the set. If the set already contains an item equal to
<code data-dev-comment-type="paramref" class="paramref">item</code>, that item is replaced with <code data-dev-comment-type="paramref" class="paramref">item</code>.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public bool Add(T item)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">T</span></td>
        <td><span class="parametername">item</span></td>
        <td><p>The item to add to the set.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Boolean</span></td>
        <td><p>True if the set already contained an item equal to <code data-dev-comment-type="paramref" class="paramref">item</code> (which was replaced), false
otherwise.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="Wintellect_PowerCollections_OrderedSet_1_Add__0__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>Equality between items is determined by the comparison instance or delegate used
to create the set.</p>
<p>Adding an item takes time O(log N), where N is the number of items in the set.</p>
</div>
  
  
  <a id="Wintellect_PowerCollections_OrderedSet_1_AddMany_" data-uid="Wintellect.PowerCollections.OrderedSet`1.AddMany*"></a>
  <h4 id="Wintellect_PowerCollections_OrderedSet_1_AddMany_System_Collections_Generic_IEnumerable__0__" data-uid="Wintellect.PowerCollections.OrderedSet`1.AddMany(System.Collections.Generic.IEnumerable{`0})">AddMany(IEnumerable&lt;T&gt;)</h4>
  <div class="markdown level1 summary"><p>Adds all the items in <code data-dev-comment-type="paramref" class="paramref">collection</code> to the set. If the set already contains an item equal to
one of the items in <code data-dev-comment-type="paramref" class="paramref">collection</code>, that item will be replaced.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public void AddMany(IEnumerable&lt;T&gt; collection)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Collections.Generic.IEnumerable</span>&lt;T&gt;</td>
        <td><span class="parametername">collection</span></td>
        <td><p>A collection of items to add to the set.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="Wintellect_PowerCollections_OrderedSet_1_AddMany_System_Collections_Generic_IEnumerable__0___remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>Equality between items is determined by the comparison instance or delegate used
to create the set.</p>
<p>Adding the collection takes time O(M log N), where N is the number of items in the set, and M is the 
number of items in <code data-dev-comment-type="paramref" class="paramref">collection</code>.</p>
</div>
  
  
  <a id="Wintellect_PowerCollections_OrderedSet_1_AddMany_" data-uid="Wintellect.PowerCollections.OrderedSet`1.AddMany*"></a>
  <h4 id="Wintellect_PowerCollections_OrderedSet_1_AddMany_System_Collections_Generic_IEnumerable__0__" data-uid="Wintellect.PowerCollections.OrderedSet`1.AddMany(System.Collections.Generic.IEnumerable{`0})">AddMany(IEnumerable&lt;T&gt;)</h4>
  <div class="markdown level1 summary"><p>Adds all the items in <code data-dev-comment-type="paramref" class="paramref">collection</code> to the set. If the set already contains an item equal to
one of the items in <code data-dev-comment-type="paramref" class="paramref">collection</code>, that item will be replaced.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public void AddMany(IEnumerable&lt;T&gt; collection)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Collections.Generic.IEnumerable</span>&lt;T&gt;</td>
        <td><span class="parametername">collection</span></td>
        <td><p>A collection of items to add to the set.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="Wintellect_PowerCollections_OrderedSet_1_AddMany_System_Collections_Generic_IEnumerable__0___remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>Equality between items is determined by the comparison instance or delegate used
to create the set.</p>
<p>Adding the collection takes time O(M log N), where N is the number of items in the set, and M is the 
number of items in <code data-dev-comment-type="paramref" class="paramref">collection</code>.</p>
</div>
  
  
  <a id="Wintellect_PowerCollections_OrderedSet_1_AsList_" data-uid="Wintellect.PowerCollections.OrderedSet`1.AsList*"></a>
  <h4 id="Wintellect_PowerCollections_OrderedSet_1_AsList" data-uid="Wintellect.PowerCollections.OrderedSet`1.AsList">AsList()</h4>
  <div class="markdown level1 summary"><p>Get a read-only list view of the items in this ordered set. The
items in the list are in sorted order, with the smallest item
at index 0. This view does not copy any data, and reflects any
changes to the underlying OrderedSet.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public IList&lt;T&gt; AsList()</code></pre>
  </div>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Collections.Generic.IList</span>&lt;T&gt;</td>
        <td><p>A read-only IList&lt;T&gt; view onto this OrderedSet.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Wintellect_PowerCollections_OrderedSet_1_AsList_" data-uid="Wintellect.PowerCollections.OrderedSet`1.AsList*"></a>
  <h4 id="Wintellect_PowerCollections_OrderedSet_1_AsList" data-uid="Wintellect.PowerCollections.OrderedSet`1.AsList">AsList()</h4>
  <div class="markdown level1 summary"><p>Get a read-only list view of the items in this ordered set. The
items in the list are in sorted order, with the smallest item
at index 0. This view does not copy any data, and reflects any
changes to the underlying OrderedSet.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public IList&lt;T&gt; AsList()</code></pre>
  </div>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Collections.Generic.IList</span>&lt;T&gt;</td>
        <td><p>A read-only IList&lt;T&gt; view onto this OrderedSet.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Wintellect_PowerCollections_OrderedSet_1_Clear_" data-uid="Wintellect.PowerCollections.OrderedSet`1.Clear*"></a>
  <h4 id="Wintellect_PowerCollections_OrderedSet_1_Clear" data-uid="Wintellect.PowerCollections.OrderedSet`1.Clear">Clear()</h4>
  <div class="markdown level1 summary"><p>Removes all items from the set.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public sealed override void Clear()</code></pre>
  </div>
  <h5 class="overrides">Overrides</h5>
  <div><span class="xref">Wintellect.PowerCollections.CollectionBase&lt;T&gt;.Clear()</span></div>
  <h5 id="Wintellect_PowerCollections_OrderedSet_1_Clear_remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>Clearing the sets takes a constant amount of time, regardless of the number of items in it.</p>
</div>
  
  
  <a id="Wintellect_PowerCollections_OrderedSet_1_Clear_" data-uid="Wintellect.PowerCollections.OrderedSet`1.Clear*"></a>
  <h4 id="Wintellect_PowerCollections_OrderedSet_1_Clear" data-uid="Wintellect.PowerCollections.OrderedSet`1.Clear">Clear()</h4>
  <div class="markdown level1 summary"><p>Removes all items from the set.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public sealed override void Clear()</code></pre>
  </div>
  <h5 class="overrides">Overrides</h5>
  <div><span class="xref">Wintellect.PowerCollections.CollectionBase&lt;T&gt;.Clear()</span></div>
  <h5 id="Wintellect_PowerCollections_OrderedSet_1_Clear_remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>Clearing the sets takes a constant amount of time, regardless of the number of items in it.</p>
</div>
  
  
  <a id="Wintellect_PowerCollections_OrderedSet_1_Clone_" data-uid="Wintellect.PowerCollections.OrderedSet`1.Clone*"></a>
  <h4 id="Wintellect_PowerCollections_OrderedSet_1_Clone" data-uid="Wintellect.PowerCollections.OrderedSet`1.Clone">Clone()</h4>
  <div class="markdown level1 summary"><p>Makes a shallow clone of this set; i.e., if items of the
set are reference types, then they are not cloned. If T is a value type,
then each element is copied as if by simple assignment.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public OrderedSet&lt;T&gt; Clone()</code></pre>
  </div>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Wintellect.PowerCollections.OrderedSet-1.html">OrderedSet</a>&lt;T&gt;</td>
        <td><p>The cloned set.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="Wintellect_PowerCollections_OrderedSet_1_Clone_remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>Cloning the set takes time O(N), where N is the number of items in the set.</p>
</div>
  
  
  <a id="Wintellect_PowerCollections_OrderedSet_1_Clone_" data-uid="Wintellect.PowerCollections.OrderedSet`1.Clone*"></a>
  <h4 id="Wintellect_PowerCollections_OrderedSet_1_Clone" data-uid="Wintellect.PowerCollections.OrderedSet`1.Clone">Clone()</h4>
  <div class="markdown level1 summary"><p>Makes a shallow clone of this set; i.e., if items of the
set are reference types, then they are not cloned. If T is a value type,
then each element is copied as if by simple assignment.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public OrderedSet&lt;T&gt; Clone()</code></pre>
  </div>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Wintellect.PowerCollections.OrderedSet-1.html">OrderedSet</a>&lt;T&gt;</td>
        <td><p>The cloned set.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="Wintellect_PowerCollections_OrderedSet_1_Clone_remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>Cloning the set takes time O(N), where N is the number of items in the set.</p>
</div>
  
  
  <a id="Wintellect_PowerCollections_OrderedSet_1_CloneContents_" data-uid="Wintellect.PowerCollections.OrderedSet`1.CloneContents*"></a>
  <h4 id="Wintellect_PowerCollections_OrderedSet_1_CloneContents" data-uid="Wintellect.PowerCollections.OrderedSet`1.CloneContents">CloneContents()</h4>
  <div class="markdown level1 summary"><p>Makes a deep clone of this set. A new set is created with a clone of
each element of this set, by calling ICloneable.Clone on each element. If T is
a value type, then each element is copied as if by simple assignment.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public OrderedSet&lt;T&gt; CloneContents()</code></pre>
  </div>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Wintellect.PowerCollections.OrderedSet-1.html">OrderedSet</a>&lt;T&gt;</td>
        <td><p>The cloned set.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="Wintellect_PowerCollections_OrderedSet_1_CloneContents_remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>If T is a reference type, it must implement
    ICloneable. Otherwise, an InvalidOperationException is thrown.</p>
<p>Cloning the set takes time O(N log N), where N is the number of items in the set.</p>
</div>
  <h5 class="exceptions">Exceptions</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Condition</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.InvalidOperationException</span></td>
        <td><p>T is a reference type that does not implement ICloneable.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Wintellect_PowerCollections_OrderedSet_1_CloneContents_" data-uid="Wintellect.PowerCollections.OrderedSet`1.CloneContents*"></a>
  <h4 id="Wintellect_PowerCollections_OrderedSet_1_CloneContents" data-uid="Wintellect.PowerCollections.OrderedSet`1.CloneContents">CloneContents()</h4>
  <div class="markdown level1 summary"><p>Makes a deep clone of this set. A new set is created with a clone of
each element of this set, by calling ICloneable.Clone on each element. If T is
a value type, then each element is copied as if by simple assignment.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public OrderedSet&lt;T&gt; CloneContents()</code></pre>
  </div>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Wintellect.PowerCollections.OrderedSet-1.html">OrderedSet</a>&lt;T&gt;</td>
        <td><p>The cloned set.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="Wintellect_PowerCollections_OrderedSet_1_CloneContents_remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>If T is a reference type, it must implement
    ICloneable. Otherwise, an InvalidOperationException is thrown.</p>
<p>Cloning the set takes time O(N log N), where N is the number of items in the set.</p>
</div>
  <h5 class="exceptions">Exceptions</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Condition</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.InvalidOperationException</span></td>
        <td><p>T is a reference type that does not implement ICloneable.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Wintellect_PowerCollections_OrderedSet_1_Contains_" data-uid="Wintellect.PowerCollections.OrderedSet`1.Contains*"></a>
  <h4 id="Wintellect_PowerCollections_OrderedSet_1_Contains__0_" data-uid="Wintellect.PowerCollections.OrderedSet`1.Contains(`0)">Contains(T)</h4>
  <div class="markdown level1 summary"><p>Determines if this set contains an item equal to <code data-dev-comment-type="paramref" class="paramref">item</code>. The set
is not changed.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public sealed override bool Contains(T item)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">T</span></td>
        <td><span class="parametername">item</span></td>
        <td><p>The item to search for.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Boolean</span></td>
        <td><p>True if the set contains <code data-dev-comment-type="paramref" class="paramref">item</code>. False if the set does not contain <code data-dev-comment-type="paramref" class="paramref">item</code>.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="overrides">Overrides</h5>
  <div><span class="xref">Wintellect.PowerCollections.CollectionBase&lt;T&gt;.Contains(T)</span></div>
  <h5 id="Wintellect_PowerCollections_OrderedSet_1_Contains__0__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>Searching the set for an item takes time O(log N), where N is the number of items in the set.</p>
</div>
  
  
  <a id="Wintellect_PowerCollections_OrderedSet_1_Contains_" data-uid="Wintellect.PowerCollections.OrderedSet`1.Contains*"></a>
  <h4 id="Wintellect_PowerCollections_OrderedSet_1_Contains__0_" data-uid="Wintellect.PowerCollections.OrderedSet`1.Contains(`0)">Contains(T)</h4>
  <div class="markdown level1 summary"><p>Determines if this set contains an item equal to <code data-dev-comment-type="paramref" class="paramref">item</code>. The set
is not changed.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public sealed override bool Contains(T item)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">T</span></td>
        <td><span class="parametername">item</span></td>
        <td><p>The item to search for.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Boolean</span></td>
        <td><p>True if the set contains <code data-dev-comment-type="paramref" class="paramref">item</code>. False if the set does not contain <code data-dev-comment-type="paramref" class="paramref">item</code>.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="overrides">Overrides</h5>
  <div><span class="xref">Wintellect.PowerCollections.CollectionBase&lt;T&gt;.Contains(T)</span></div>
  <h5 id="Wintellect_PowerCollections_OrderedSet_1_Contains__0__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>Searching the set for an item takes time O(log N), where N is the number of items in the set.</p>
</div>
  
  
  <a id="Wintellect_PowerCollections_OrderedSet_1_Difference_" data-uid="Wintellect.PowerCollections.OrderedSet`1.Difference*"></a>
  <h4 id="Wintellect_PowerCollections_OrderedSet_1_Difference_Wintellect_PowerCollections_OrderedSet__0__" data-uid="Wintellect.PowerCollections.OrderedSet`1.Difference(Wintellect.PowerCollections.OrderedSet{`0})">Difference(OrderedSet&lt;T&gt;)</h4>
  <div class="markdown level1 summary"><p>Computes the difference of this set with another set. The difference of these two sets
is all items that appear in this set, but not in <code data-dev-comment-type="paramref" class="paramref">otherSet</code>. A new set is
created with the difference of the sets and is returned. This set and the other set
are unchanged.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public OrderedSet&lt;T&gt; Difference(OrderedSet&lt;T&gt; otherSet)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Wintellect.PowerCollections.OrderedSet-1.html">OrderedSet</a>&lt;T&gt;</td>
        <td><span class="parametername">otherSet</span></td>
        <td><p>Set to difference with.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Wintellect.PowerCollections.OrderedSet-1.html">OrderedSet</a>&lt;T&gt;</td>
        <td><p>The difference of the two sets.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="Wintellect_PowerCollections_OrderedSet_1_Difference_Wintellect_PowerCollections_OrderedSet__0___remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>The difference of two sets is computed in time O(M + N log M), where M is the size of the 
larger set, and N is the size of the smaller set.</p>
</div>
  <h5 class="exceptions">Exceptions</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Condition</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.InvalidOperationException</span></td>
        <td><p>This set and <code data-dev-comment-type="paramref" class="paramref">otherSet</code> don't use the same method for comparing items.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Wintellect_PowerCollections_OrderedSet_1_Difference_" data-uid="Wintellect.PowerCollections.OrderedSet`1.Difference*"></a>
  <h4 id="Wintellect_PowerCollections_OrderedSet_1_Difference_Wintellect_PowerCollections_OrderedSet__0__" data-uid="Wintellect.PowerCollections.OrderedSet`1.Difference(Wintellect.PowerCollections.OrderedSet{`0})">Difference(OrderedSet&lt;T&gt;)</h4>
  <div class="markdown level1 summary"><p>Computes the difference of this set with another set. The difference of these two sets
is all items that appear in this set, but not in <code data-dev-comment-type="paramref" class="paramref">otherSet</code>. A new set is
created with the difference of the sets and is returned. This set and the other set
are unchanged.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public OrderedSet&lt;T&gt; Difference(OrderedSet&lt;T&gt; otherSet)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Wintellect.PowerCollections.OrderedSet-1.html">OrderedSet</a>&lt;T&gt;</td>
        <td><span class="parametername">otherSet</span></td>
        <td><p>Set to difference with.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Wintellect.PowerCollections.OrderedSet-1.html">OrderedSet</a>&lt;T&gt;</td>
        <td><p>The difference of the two sets.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="Wintellect_PowerCollections_OrderedSet_1_Difference_Wintellect_PowerCollections_OrderedSet__0___remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>The difference of two sets is computed in time O(M + N log M), where M is the size of the 
larger set, and N is the size of the smaller set.</p>
</div>
  <h5 class="exceptions">Exceptions</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Condition</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.InvalidOperationException</span></td>
        <td><p>This set and <code data-dev-comment-type="paramref" class="paramref">otherSet</code> don't use the same method for comparing items.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Wintellect_PowerCollections_OrderedSet_1_DifferenceWith_" data-uid="Wintellect.PowerCollections.OrderedSet`1.DifferenceWith*"></a>
  <h4 id="Wintellect_PowerCollections_OrderedSet_1_DifferenceWith_Wintellect_PowerCollections_OrderedSet__0__" data-uid="Wintellect.PowerCollections.OrderedSet`1.DifferenceWith(Wintellect.PowerCollections.OrderedSet{`0})">DifferenceWith(OrderedSet&lt;T&gt;)</h4>
  <div class="markdown level1 summary"><p>Computes the difference of this set with another set. The difference of these two sets
is all items that appear in this set, but not in <code data-dev-comment-type="paramref" class="paramref">otherSet</code>. This set receives
the difference of the two sets; the other set is unchanged.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public void DifferenceWith(OrderedSet&lt;T&gt; otherSet)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Wintellect.PowerCollections.OrderedSet-1.html">OrderedSet</a>&lt;T&gt;</td>
        <td><span class="parametername">otherSet</span></td>
        <td><p>Set to difference with.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="Wintellect_PowerCollections_OrderedSet_1_DifferenceWith_Wintellect_PowerCollections_OrderedSet__0___remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>The difference of two sets is computed in time O(M + N log M), where M is the size of the 
larger set, and N is the size of the smaller set.</p>
</div>
  <h5 class="exceptions">Exceptions</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Condition</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.InvalidOperationException</span></td>
        <td><p>This set and <code data-dev-comment-type="paramref" class="paramref">otherSet</code> don't use the same method for comparing items.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Wintellect_PowerCollections_OrderedSet_1_DifferenceWith_" data-uid="Wintellect.PowerCollections.OrderedSet`1.DifferenceWith*"></a>
  <h4 id="Wintellect_PowerCollections_OrderedSet_1_DifferenceWith_Wintellect_PowerCollections_OrderedSet__0__" data-uid="Wintellect.PowerCollections.OrderedSet`1.DifferenceWith(Wintellect.PowerCollections.OrderedSet{`0})">DifferenceWith(OrderedSet&lt;T&gt;)</h4>
  <div class="markdown level1 summary"><p>Computes the difference of this set with another set. The difference of these two sets
is all items that appear in this set, but not in <code data-dev-comment-type="paramref" class="paramref">otherSet</code>. This set receives
the difference of the two sets; the other set is unchanged.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public void DifferenceWith(OrderedSet&lt;T&gt; otherSet)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Wintellect.PowerCollections.OrderedSet-1.html">OrderedSet</a>&lt;T&gt;</td>
        <td><span class="parametername">otherSet</span></td>
        <td><p>Set to difference with.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="Wintellect_PowerCollections_OrderedSet_1_DifferenceWith_Wintellect_PowerCollections_OrderedSet__0___remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>The difference of two sets is computed in time O(M + N log M), where M is the size of the 
larger set, and N is the size of the smaller set.</p>
</div>
  <h5 class="exceptions">Exceptions</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Condition</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.InvalidOperationException</span></td>
        <td><p>This set and <code data-dev-comment-type="paramref" class="paramref">otherSet</code> don't use the same method for comparing items.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Wintellect_PowerCollections_OrderedSet_1_GetEnumerator_" data-uid="Wintellect.PowerCollections.OrderedSet`1.GetEnumerator*"></a>
  <h4 id="Wintellect_PowerCollections_OrderedSet_1_GetEnumerator" data-uid="Wintellect.PowerCollections.OrderedSet`1.GetEnumerator">GetEnumerator()</h4>
  <div class="markdown level1 summary"><p>Returns an enumerator that enumerates all the items in the set.
The items are enumerated in sorted order.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public sealed override IEnumerator&lt;T&gt; GetEnumerator()</code></pre>
  </div>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Collections.Generic.IEnumerator</span>&lt;T&gt;</td>
        <td><p>An enumerator for enumerating all the items in the OrderedSet.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="overrides">Overrides</h5>
  <div><span class="xref">Wintellect.PowerCollections.CollectionBase&lt;T&gt;.GetEnumerator()</span></div>
  <h5 id="Wintellect_PowerCollections_OrderedSet_1_GetEnumerator_remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>Typically, this method is not called directly. Instead the &quot;foreach&quot; statement is used
to enumerate the items, which uses this method implicitly.</p>
<p>If an item is added to or deleted from the set while it is being enumerated, then 
the enumeration will end with an InvalidOperationException.</p>
<p>Enumeration all the items in the set takes time O(N log N), where N is the number
of items in the set.</p>
</div>
  
  
  <a id="Wintellect_PowerCollections_OrderedSet_1_GetEnumerator_" data-uid="Wintellect.PowerCollections.OrderedSet`1.GetEnumerator*"></a>
  <h4 id="Wintellect_PowerCollections_OrderedSet_1_GetEnumerator" data-uid="Wintellect.PowerCollections.OrderedSet`1.GetEnumerator">GetEnumerator()</h4>
  <div class="markdown level1 summary"><p>Returns an enumerator that enumerates all the items in the set.
The items are enumerated in sorted order.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public sealed override IEnumerator&lt;T&gt; GetEnumerator()</code></pre>
  </div>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Collections.Generic.IEnumerator</span>&lt;T&gt;</td>
        <td><p>An enumerator for enumerating all the items in the OrderedSet.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="overrides">Overrides</h5>
  <div><span class="xref">Wintellect.PowerCollections.CollectionBase&lt;T&gt;.GetEnumerator()</span></div>
  <h5 id="Wintellect_PowerCollections_OrderedSet_1_GetEnumerator_remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>Typically, this method is not called directly. Instead the &quot;foreach&quot; statement is used
to enumerate the items, which uses this method implicitly.</p>
<p>If an item is added to or deleted from the set while it is being enumerated, then 
the enumeration will end with an InvalidOperationException.</p>
<p>Enumeration all the items in the set takes time O(N log N), where N is the number
of items in the set.</p>
</div>
  
  
  <a id="Wintellect_PowerCollections_OrderedSet_1_GetFirst_" data-uid="Wintellect.PowerCollections.OrderedSet`1.GetFirst*"></a>
  <h4 id="Wintellect_PowerCollections_OrderedSet_1_GetFirst" data-uid="Wintellect.PowerCollections.OrderedSet`1.GetFirst">GetFirst()</h4>
  <div class="markdown level1 summary"><p>Returns the first item in the set: the item
that would appear first if the set was enumerated. This is also
the smallest item in the set.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public T GetFirst()</code></pre>
  </div>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">T</span></td>
        <td><p>The first item in the set.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="Wintellect_PowerCollections_OrderedSet_1_GetFirst_remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>GetFirst() takes time O(log N), where N is the number of items in the set.</p>
</div>
  <h5 class="exceptions">Exceptions</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Condition</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.InvalidOperationException</span></td>
        <td><p>The set is empty.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Wintellect_PowerCollections_OrderedSet_1_GetFirst_" data-uid="Wintellect.PowerCollections.OrderedSet`1.GetFirst*"></a>
  <h4 id="Wintellect_PowerCollections_OrderedSet_1_GetFirst" data-uid="Wintellect.PowerCollections.OrderedSet`1.GetFirst">GetFirst()</h4>
  <div class="markdown level1 summary"><p>Returns the first item in the set: the item
that would appear first if the set was enumerated. This is also
the smallest item in the set.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public T GetFirst()</code></pre>
  </div>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">T</span></td>
        <td><p>The first item in the set.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="Wintellect_PowerCollections_OrderedSet_1_GetFirst_remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>GetFirst() takes time O(log N), where N is the number of items in the set.</p>
</div>
  <h5 class="exceptions">Exceptions</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Condition</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.InvalidOperationException</span></td>
        <td><p>The set is empty.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Wintellect_PowerCollections_OrderedSet_1_GetLast_" data-uid="Wintellect.PowerCollections.OrderedSet`1.GetLast*"></a>
  <h4 id="Wintellect_PowerCollections_OrderedSet_1_GetLast" data-uid="Wintellect.PowerCollections.OrderedSet`1.GetLast">GetLast()</h4>
  <div class="markdown level1 summary"><p>Returns the lastl item in the set: the item
that would appear last if the set was enumerated. This is also the
largest item in the set.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public T GetLast()</code></pre>
  </div>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">T</span></td>
        <td><p>The lastl item in the set.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="Wintellect_PowerCollections_OrderedSet_1_GetLast_remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>GetLast() takes time O(log N), where N is the number of items in the set.</p>
</div>
  <h5 class="exceptions">Exceptions</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Condition</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.InvalidOperationException</span></td>
        <td><p>The set is empty.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Wintellect_PowerCollections_OrderedSet_1_GetLast_" data-uid="Wintellect.PowerCollections.OrderedSet`1.GetLast*"></a>
  <h4 id="Wintellect_PowerCollections_OrderedSet_1_GetLast" data-uid="Wintellect.PowerCollections.OrderedSet`1.GetLast">GetLast()</h4>
  <div class="markdown level1 summary"><p>Returns the lastl item in the set: the item
that would appear last if the set was enumerated. This is also the
largest item in the set.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public T GetLast()</code></pre>
  </div>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">T</span></td>
        <td><p>The lastl item in the set.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="Wintellect_PowerCollections_OrderedSet_1_GetLast_remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>GetLast() takes time O(log N), where N is the number of items in the set.</p>
</div>
  <h5 class="exceptions">Exceptions</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Condition</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.InvalidOperationException</span></td>
        <td><p>The set is empty.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Wintellect_PowerCollections_OrderedSet_1_IndexOf_" data-uid="Wintellect.PowerCollections.OrderedSet`1.IndexOf*"></a>
  <h4 id="Wintellect_PowerCollections_OrderedSet_1_IndexOf__0_" data-uid="Wintellect.PowerCollections.OrderedSet`1.IndexOf(`0)">IndexOf(T)</h4>
  <div class="markdown level1 summary"><p>Get the index of the given item in the sorted order. The smallest item has index 0,
the next smallest item has index 1, and the largest item has index Count-1.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public int IndexOf(T item)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">T</span></td>
        <td><span class="parametername">item</span></td>
        <td><p>The item to get the index of.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Int32</span></td>
        <td><p>The index of the item in the sorted set, or -1 if the item is not present
in the set.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="Wintellect_PowerCollections_OrderedSet_1_IndexOf__0__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>Finding the index takes time O(log N), which N is the number of items in
the set.</p>
</div>
  
  
  <a id="Wintellect_PowerCollections_OrderedSet_1_IndexOf_" data-uid="Wintellect.PowerCollections.OrderedSet`1.IndexOf*"></a>
  <h4 id="Wintellect_PowerCollections_OrderedSet_1_IndexOf__0_" data-uid="Wintellect.PowerCollections.OrderedSet`1.IndexOf(`0)">IndexOf(T)</h4>
  <div class="markdown level1 summary"><p>Get the index of the given item in the sorted order. The smallest item has index 0,
the next smallest item has index 1, and the largest item has index Count-1.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public int IndexOf(T item)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">T</span></td>
        <td><span class="parametername">item</span></td>
        <td><p>The item to get the index of.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Int32</span></td>
        <td><p>The index of the item in the sorted set, or -1 if the item is not present
in the set.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="Wintellect_PowerCollections_OrderedSet_1_IndexOf__0__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>Finding the index takes time O(log N), which N is the number of items in
the set.</p>
</div>
  
  
  <a id="Wintellect_PowerCollections_OrderedSet_1_Intersection_" data-uid="Wintellect.PowerCollections.OrderedSet`1.Intersection*"></a>
  <h4 id="Wintellect_PowerCollections_OrderedSet_1_Intersection_Wintellect_PowerCollections_OrderedSet__0__" data-uid="Wintellect.PowerCollections.OrderedSet`1.Intersection(Wintellect.PowerCollections.OrderedSet{`0})">Intersection(OrderedSet&lt;T&gt;)</h4>
  <div class="markdown level1 summary"><p>Computes the intersection of this set with another set. The intersection of two sets
is all items that appear in both of the sets. A new set is
created with the intersection of the sets and is returned. This set and the other set
are unchanged.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public OrderedSet&lt;T&gt; Intersection(OrderedSet&lt;T&gt; otherSet)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Wintellect.PowerCollections.OrderedSet-1.html">OrderedSet</a>&lt;T&gt;</td>
        <td><span class="parametername">otherSet</span></td>
        <td><p>Set to intersection with.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Wintellect.PowerCollections.OrderedSet-1.html">OrderedSet</a>&lt;T&gt;</td>
        <td><p>The intersection of the two sets.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="Wintellect_PowerCollections_OrderedSet_1_Intersection_Wintellect_PowerCollections_OrderedSet__0___remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>When equal items appear in both sets, the intersection will include an arbitrary choice of one of the
two equal items.</p>
<p>The intersection of two sets is computed in time O(N log M), where M is the size of the 
larger set, and N is the size of the smaller set.</p>
</div>
  <h5 class="exceptions">Exceptions</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Condition</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.InvalidOperationException</span></td>
        <td><p>This set and <code data-dev-comment-type="paramref" class="paramref">otherSet</code> don't use the same method for comparing items.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Wintellect_PowerCollections_OrderedSet_1_Intersection_" data-uid="Wintellect.PowerCollections.OrderedSet`1.Intersection*"></a>
  <h4 id="Wintellect_PowerCollections_OrderedSet_1_Intersection_Wintellect_PowerCollections_OrderedSet__0__" data-uid="Wintellect.PowerCollections.OrderedSet`1.Intersection(Wintellect.PowerCollections.OrderedSet{`0})">Intersection(OrderedSet&lt;T&gt;)</h4>
  <div class="markdown level1 summary"><p>Computes the intersection of this set with another set. The intersection of two sets
is all items that appear in both of the sets. A new set is
created with the intersection of the sets and is returned. This set and the other set
are unchanged.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public OrderedSet&lt;T&gt; Intersection(OrderedSet&lt;T&gt; otherSet)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Wintellect.PowerCollections.OrderedSet-1.html">OrderedSet</a>&lt;T&gt;</td>
        <td><span class="parametername">otherSet</span></td>
        <td><p>Set to intersection with.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Wintellect.PowerCollections.OrderedSet-1.html">OrderedSet</a>&lt;T&gt;</td>
        <td><p>The intersection of the two sets.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="Wintellect_PowerCollections_OrderedSet_1_Intersection_Wintellect_PowerCollections_OrderedSet__0___remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>When equal items appear in both sets, the intersection will include an arbitrary choice of one of the
two equal items.</p>
<p>The intersection of two sets is computed in time O(N log M), where M is the size of the 
larger set, and N is the size of the smaller set.</p>
</div>
  <h5 class="exceptions">Exceptions</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Condition</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.InvalidOperationException</span></td>
        <td><p>This set and <code data-dev-comment-type="paramref" class="paramref">otherSet</code> don't use the same method for comparing items.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Wintellect_PowerCollections_OrderedSet_1_IntersectionWith_" data-uid="Wintellect.PowerCollections.OrderedSet`1.IntersectionWith*"></a>
  <h4 id="Wintellect_PowerCollections_OrderedSet_1_IntersectionWith_Wintellect_PowerCollections_OrderedSet__0__" data-uid="Wintellect.PowerCollections.OrderedSet`1.IntersectionWith(Wintellect.PowerCollections.OrderedSet{`0})">IntersectionWith(OrderedSet&lt;T&gt;)</h4>
  <div class="markdown level1 summary"><p>Computes the intersection of this set with another set. The intersection of two sets
is all items that appear in both of the sets. This set receives
the intersection of the two sets, the other set is unchanged.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public void IntersectionWith(OrderedSet&lt;T&gt; otherSet)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Wintellect.PowerCollections.OrderedSet-1.html">OrderedSet</a>&lt;T&gt;</td>
        <td><span class="parametername">otherSet</span></td>
        <td><p>Set to intersection with.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="Wintellect_PowerCollections_OrderedSet_1_IntersectionWith_Wintellect_PowerCollections_OrderedSet__0___remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>When equal items appear in both sets, the intersection will include an arbitrary choice of one of the
two equal items.</p>
<p>The intersection of two sets is computed in time O(N log M), where M is the size of the 
larger set, and N is the size of the smaller set.</p>
</div>
  <h5 class="exceptions">Exceptions</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Condition</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.InvalidOperationException</span></td>
        <td><p>This set and <code data-dev-comment-type="paramref" class="paramref">otherSet</code> don't use the same method for comparing items.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Wintellect_PowerCollections_OrderedSet_1_IntersectionWith_" data-uid="Wintellect.PowerCollections.OrderedSet`1.IntersectionWith*"></a>
  <h4 id="Wintellect_PowerCollections_OrderedSet_1_IntersectionWith_Wintellect_PowerCollections_OrderedSet__0__" data-uid="Wintellect.PowerCollections.OrderedSet`1.IntersectionWith(Wintellect.PowerCollections.OrderedSet{`0})">IntersectionWith(OrderedSet&lt;T&gt;)</h4>
  <div class="markdown level1 summary"><p>Computes the intersection of this set with another set. The intersection of two sets
is all items that appear in both of the sets. This set receives
the intersection of the two sets, the other set is unchanged.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public void IntersectionWith(OrderedSet&lt;T&gt; otherSet)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Wintellect.PowerCollections.OrderedSet-1.html">OrderedSet</a>&lt;T&gt;</td>
        <td><span class="parametername">otherSet</span></td>
        <td><p>Set to intersection with.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="Wintellect_PowerCollections_OrderedSet_1_IntersectionWith_Wintellect_PowerCollections_OrderedSet__0___remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>When equal items appear in both sets, the intersection will include an arbitrary choice of one of the
two equal items.</p>
<p>The intersection of two sets is computed in time O(N log M), where M is the size of the 
larger set, and N is the size of the smaller set.</p>
</div>
  <h5 class="exceptions">Exceptions</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Condition</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.InvalidOperationException</span></td>
        <td><p>This set and <code data-dev-comment-type="paramref" class="paramref">otherSet</code> don't use the same method for comparing items.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Wintellect_PowerCollections_OrderedSet_1_IsDisjointFrom_" data-uid="Wintellect.PowerCollections.OrderedSet`1.IsDisjointFrom*"></a>
  <h4 id="Wintellect_PowerCollections_OrderedSet_1_IsDisjointFrom_Wintellect_PowerCollections_OrderedSet__0__" data-uid="Wintellect.PowerCollections.OrderedSet`1.IsDisjointFrom(Wintellect.PowerCollections.OrderedSet{`0})">IsDisjointFrom(OrderedSet&lt;T&gt;)</h4>
  <div class="markdown level1 summary"><p>Determines if this set is disjoint from another set. Two sets are disjoint
if no item from one set is equal to any item in the other set.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public bool IsDisjointFrom(OrderedSet&lt;T&gt; otherSet)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Wintellect.PowerCollections.OrderedSet-1.html">OrderedSet</a>&lt;T&gt;</td>
        <td><span class="parametername">otherSet</span></td>
        <td><p>Set to check disjointness with.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Boolean</span></td>
        <td><p>True if the two sets are disjoint, false otherwise.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="Wintellect_PowerCollections_OrderedSet_1_IsDisjointFrom_Wintellect_PowerCollections_OrderedSet__0___remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>The answer is computed in time O(N log M), where M is the size of the 
larger set, and N is the size of the smaller set.</p>
</div>
  <h5 class="exceptions">Exceptions</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Condition</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.InvalidOperationException</span></td>
        <td><p>This set and <code data-dev-comment-type="paramref" class="paramref">otherSet</code> don't use the same method for comparing items.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Wintellect_PowerCollections_OrderedSet_1_IsDisjointFrom_" data-uid="Wintellect.PowerCollections.OrderedSet`1.IsDisjointFrom*"></a>
  <h4 id="Wintellect_PowerCollections_OrderedSet_1_IsDisjointFrom_Wintellect_PowerCollections_OrderedSet__0__" data-uid="Wintellect.PowerCollections.OrderedSet`1.IsDisjointFrom(Wintellect.PowerCollections.OrderedSet{`0})">IsDisjointFrom(OrderedSet&lt;T&gt;)</h4>
  <div class="markdown level1 summary"><p>Determines if this set is disjoint from another set. Two sets are disjoint
if no item from one set is equal to any item in the other set.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public bool IsDisjointFrom(OrderedSet&lt;T&gt; otherSet)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Wintellect.PowerCollections.OrderedSet-1.html">OrderedSet</a>&lt;T&gt;</td>
        <td><span class="parametername">otherSet</span></td>
        <td><p>Set to check disjointness with.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Boolean</span></td>
        <td><p>True if the two sets are disjoint, false otherwise.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="Wintellect_PowerCollections_OrderedSet_1_IsDisjointFrom_Wintellect_PowerCollections_OrderedSet__0___remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>The answer is computed in time O(N log M), where M is the size of the 
larger set, and N is the size of the smaller set.</p>
</div>
  <h5 class="exceptions">Exceptions</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Condition</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.InvalidOperationException</span></td>
        <td><p>This set and <code data-dev-comment-type="paramref" class="paramref">otherSet</code> don't use the same method for comparing items.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Wintellect_PowerCollections_OrderedSet_1_IsEqualTo_" data-uid="Wintellect.PowerCollections.OrderedSet`1.IsEqualTo*"></a>
  <h4 id="Wintellect_PowerCollections_OrderedSet_1_IsEqualTo_Wintellect_PowerCollections_OrderedSet__0__" data-uid="Wintellect.PowerCollections.OrderedSet`1.IsEqualTo(Wintellect.PowerCollections.OrderedSet{`0})">IsEqualTo(OrderedSet&lt;T&gt;)</h4>
  <div class="markdown level1 summary"><p>Determines if this set is equal to another set. This set is equal to
<code data-dev-comment-type="paramref" class="paramref">otherSet</code> if they contain the same items.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public bool IsEqualTo(OrderedSet&lt;T&gt; otherSet)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Wintellect.PowerCollections.OrderedSet-1.html">OrderedSet</a>&lt;T&gt;</td>
        <td><span class="parametername">otherSet</span></td>
        <td><p>Set to compare to</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Boolean</span></td>
        <td><p>True if this set is equal to <code data-dev-comment-type="paramref" class="paramref">otherSet</code>, false otherwise.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="Wintellect_PowerCollections_OrderedSet_1_IsEqualTo_Wintellect_PowerCollections_OrderedSet__0___remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>IsEqualTo is computed in time O(N), where N is the number of items in
this set.</p>
</div>
  <h5 class="exceptions">Exceptions</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Condition</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.InvalidOperationException</span></td>
        <td><p>This set and <code data-dev-comment-type="paramref" class="paramref">otherSet</code> don't use the same method for comparing items.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Wintellect_PowerCollections_OrderedSet_1_IsEqualTo_" data-uid="Wintellect.PowerCollections.OrderedSet`1.IsEqualTo*"></a>
  <h4 id="Wintellect_PowerCollections_OrderedSet_1_IsEqualTo_Wintellect_PowerCollections_OrderedSet__0__" data-uid="Wintellect.PowerCollections.OrderedSet`1.IsEqualTo(Wintellect.PowerCollections.OrderedSet{`0})">IsEqualTo(OrderedSet&lt;T&gt;)</h4>
  <div class="markdown level1 summary"><p>Determines if this set is equal to another set. This set is equal to
<code data-dev-comment-type="paramref" class="paramref">otherSet</code> if they contain the same items.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public bool IsEqualTo(OrderedSet&lt;T&gt; otherSet)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Wintellect.PowerCollections.OrderedSet-1.html">OrderedSet</a>&lt;T&gt;</td>
        <td><span class="parametername">otherSet</span></td>
        <td><p>Set to compare to</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Boolean</span></td>
        <td><p>True if this set is equal to <code data-dev-comment-type="paramref" class="paramref">otherSet</code>, false otherwise.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="Wintellect_PowerCollections_OrderedSet_1_IsEqualTo_Wintellect_PowerCollections_OrderedSet__0___remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>IsEqualTo is computed in time O(N), where N is the number of items in
this set.</p>
</div>
  <h5 class="exceptions">Exceptions</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Condition</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.InvalidOperationException</span></td>
        <td><p>This set and <code data-dev-comment-type="paramref" class="paramref">otherSet</code> don't use the same method for comparing items.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Wintellect_PowerCollections_OrderedSet_1_IsProperSubsetOf_" data-uid="Wintellect.PowerCollections.OrderedSet`1.IsProperSubsetOf*"></a>
  <h4 id="Wintellect_PowerCollections_OrderedSet_1_IsProperSubsetOf_Wintellect_PowerCollections_OrderedSet__0__" data-uid="Wintellect.PowerCollections.OrderedSet`1.IsProperSubsetOf(Wintellect.PowerCollections.OrderedSet{`0})">IsProperSubsetOf(OrderedSet&lt;T&gt;)</h4>
  <div class="markdown level1 summary"><p>Determines if this set is a proper subset of another set. Neither set is modified.
This set is a subset of <code data-dev-comment-type="paramref" class="paramref">otherSet</code> if every element in this set
is also in <code data-dev-comment-type="paramref" class="paramref">otherSet</code>. Additionally, this set must have strictly
fewer items than <code data-dev-comment-type="paramref" class="paramref">otherSet</code>.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public bool IsProperSubsetOf(OrderedSet&lt;T&gt; otherSet)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Wintellect.PowerCollections.OrderedSet-1.html">OrderedSet</a>&lt;T&gt;</td>
        <td><span class="parametername">otherSet</span></td>
        <td><p>Set to compare to.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Boolean</span></td>
        <td><p>True if this is a proper subset of <code data-dev-comment-type="paramref" class="paramref">otherSet</code>.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="Wintellect_PowerCollections_OrderedSet_1_IsProperSubsetOf_Wintellect_PowerCollections_OrderedSet__0___remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>IsSubsetOf is computed in time O(N log M), where M is the size of the
<code data-dev-comment-type="paramref" class="paramref">otherSet</code>, and N is the size of the this set.</p>
</div>
  <h5 class="exceptions">Exceptions</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Condition</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.InvalidOperationException</span></td>
        <td><p>This set and <code data-dev-comment-type="paramref" class="paramref">otherSet</code> don't use the same method for comparing items.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Wintellect_PowerCollections_OrderedSet_1_IsProperSubsetOf_" data-uid="Wintellect.PowerCollections.OrderedSet`1.IsProperSubsetOf*"></a>
  <h4 id="Wintellect_PowerCollections_OrderedSet_1_IsProperSubsetOf_Wintellect_PowerCollections_OrderedSet__0__" data-uid="Wintellect.PowerCollections.OrderedSet`1.IsProperSubsetOf(Wintellect.PowerCollections.OrderedSet{`0})">IsProperSubsetOf(OrderedSet&lt;T&gt;)</h4>
  <div class="markdown level1 summary"><p>Determines if this set is a proper subset of another set. Neither set is modified.
This set is a subset of <code data-dev-comment-type="paramref" class="paramref">otherSet</code> if every element in this set
is also in <code data-dev-comment-type="paramref" class="paramref">otherSet</code>. Additionally, this set must have strictly
fewer items than <code data-dev-comment-type="paramref" class="paramref">otherSet</code>.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public bool IsProperSubsetOf(OrderedSet&lt;T&gt; otherSet)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Wintellect.PowerCollections.OrderedSet-1.html">OrderedSet</a>&lt;T&gt;</td>
        <td><span class="parametername">otherSet</span></td>
        <td><p>Set to compare to.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Boolean</span></td>
        <td><p>True if this is a proper subset of <code data-dev-comment-type="paramref" class="paramref">otherSet</code>.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="Wintellect_PowerCollections_OrderedSet_1_IsProperSubsetOf_Wintellect_PowerCollections_OrderedSet__0___remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>IsSubsetOf is computed in time O(N log M), where M is the size of the
<code data-dev-comment-type="paramref" class="paramref">otherSet</code>, and N is the size of the this set.</p>
</div>
  <h5 class="exceptions">Exceptions</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Condition</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.InvalidOperationException</span></td>
        <td><p>This set and <code data-dev-comment-type="paramref" class="paramref">otherSet</code> don't use the same method for comparing items.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Wintellect_PowerCollections_OrderedSet_1_IsProperSupersetOf_" data-uid="Wintellect.PowerCollections.OrderedSet`1.IsProperSupersetOf*"></a>
  <h4 id="Wintellect_PowerCollections_OrderedSet_1_IsProperSupersetOf_Wintellect_PowerCollections_OrderedSet__0__" data-uid="Wintellect.PowerCollections.OrderedSet`1.IsProperSupersetOf(Wintellect.PowerCollections.OrderedSet{`0})">IsProperSupersetOf(OrderedSet&lt;T&gt;)</h4>
  <div class="markdown level1 summary"><p>Determines if this set is a proper superset of another set. Neither set is modified.
This set is a proper superset of <code data-dev-comment-type="paramref" class="paramref">otherSet</code> if every element in
<code data-dev-comment-type="paramref" class="paramref">otherSet</code> is also in this set.
Additionally, this set must have strictly more items than <code data-dev-comment-type="paramref" class="paramref">otherSet</code>.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public bool IsProperSupersetOf(OrderedSet&lt;T&gt; otherSet)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Wintellect.PowerCollections.OrderedSet-1.html">OrderedSet</a>&lt;T&gt;</td>
        <td><span class="parametername">otherSet</span></td>
        <td><p>OrderedSet to compare to.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Boolean</span></td>
        <td><p>True if this is a proper superset of <code data-dev-comment-type="paramref" class="paramref">otherSet</code>.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="Wintellect_PowerCollections_OrderedSet_1_IsProperSupersetOf_Wintellect_PowerCollections_OrderedSet__0___remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>IsProperSupersetOf is computed in time O(M log N), where M is the number of unique items in
<code data-dev-comment-type="paramref" class="paramref">otherSet</code>.</p>
</div>
  <h5 class="exceptions">Exceptions</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Condition</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.InvalidOperationException</span></td>
        <td><p>This set and <code data-dev-comment-type="paramref" class="paramref">otherSet</code> don't use the same method for comparing items.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Wintellect_PowerCollections_OrderedSet_1_IsProperSupersetOf_" data-uid="Wintellect.PowerCollections.OrderedSet`1.IsProperSupersetOf*"></a>
  <h4 id="Wintellect_PowerCollections_OrderedSet_1_IsProperSupersetOf_Wintellect_PowerCollections_OrderedSet__0__" data-uid="Wintellect.PowerCollections.OrderedSet`1.IsProperSupersetOf(Wintellect.PowerCollections.OrderedSet{`0})">IsProperSupersetOf(OrderedSet&lt;T&gt;)</h4>
  <div class="markdown level1 summary"><p>Determines if this set is a proper superset of another set. Neither set is modified.
This set is a proper superset of <code data-dev-comment-type="paramref" class="paramref">otherSet</code> if every element in
<code data-dev-comment-type="paramref" class="paramref">otherSet</code> is also in this set.
Additionally, this set must have strictly more items than <code data-dev-comment-type="paramref" class="paramref">otherSet</code>.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public bool IsProperSupersetOf(OrderedSet&lt;T&gt; otherSet)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Wintellect.PowerCollections.OrderedSet-1.html">OrderedSet</a>&lt;T&gt;</td>
        <td><span class="parametername">otherSet</span></td>
        <td><p>OrderedSet to compare to.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Boolean</span></td>
        <td><p>True if this is a proper superset of <code data-dev-comment-type="paramref" class="paramref">otherSet</code>.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="Wintellect_PowerCollections_OrderedSet_1_IsProperSupersetOf_Wintellect_PowerCollections_OrderedSet__0___remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>IsProperSupersetOf is computed in time O(M log N), where M is the number of unique items in
<code data-dev-comment-type="paramref" class="paramref">otherSet</code>.</p>
</div>
  <h5 class="exceptions">Exceptions</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Condition</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.InvalidOperationException</span></td>
        <td><p>This set and <code data-dev-comment-type="paramref" class="paramref">otherSet</code> don't use the same method for comparing items.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Wintellect_PowerCollections_OrderedSet_1_IsSubsetOf_" data-uid="Wintellect.PowerCollections.OrderedSet`1.IsSubsetOf*"></a>
  <h4 id="Wintellect_PowerCollections_OrderedSet_1_IsSubsetOf_Wintellect_PowerCollections_OrderedSet__0__" data-uid="Wintellect.PowerCollections.OrderedSet`1.IsSubsetOf(Wintellect.PowerCollections.OrderedSet{`0})">IsSubsetOf(OrderedSet&lt;T&gt;)</h4>
  <div class="markdown level1 summary"><p>Determines if this set is a subset of another set. Neither set is modified.
This set is a subset of <code data-dev-comment-type="paramref" class="paramref">otherSet</code> if every element in this set
is also in <code data-dev-comment-type="paramref" class="paramref">otherSet</code>.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public bool IsSubsetOf(OrderedSet&lt;T&gt; otherSet)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Wintellect.PowerCollections.OrderedSet-1.html">OrderedSet</a>&lt;T&gt;</td>
        <td><span class="parametername">otherSet</span></td>
        <td><p>Set to compare to.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Boolean</span></td>
        <td><p>True if this is a subset of <code data-dev-comment-type="paramref" class="paramref">otherSet</code>.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="Wintellect_PowerCollections_OrderedSet_1_IsSubsetOf_Wintellect_PowerCollections_OrderedSet__0___remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>IsSubsetOf is computed in time O(N log M), where M is the size of the
<code data-dev-comment-type="paramref" class="paramref">otherSet</code>, and N is the size of the this set.</p>
</div>
  <h5 class="exceptions">Exceptions</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Condition</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.InvalidOperationException</span></td>
        <td><p>This set and <code data-dev-comment-type="paramref" class="paramref">otherSet</code> don't use the same method for comparing items.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Wintellect_PowerCollections_OrderedSet_1_IsSubsetOf_" data-uid="Wintellect.PowerCollections.OrderedSet`1.IsSubsetOf*"></a>
  <h4 id="Wintellect_PowerCollections_OrderedSet_1_IsSubsetOf_Wintellect_PowerCollections_OrderedSet__0__" data-uid="Wintellect.PowerCollections.OrderedSet`1.IsSubsetOf(Wintellect.PowerCollections.OrderedSet{`0})">IsSubsetOf(OrderedSet&lt;T&gt;)</h4>
  <div class="markdown level1 summary"><p>Determines if this set is a subset of another set. Neither set is modified.
This set is a subset of <code data-dev-comment-type="paramref" class="paramref">otherSet</code> if every element in this set
is also in <code data-dev-comment-type="paramref" class="paramref">otherSet</code>.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public bool IsSubsetOf(OrderedSet&lt;T&gt; otherSet)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Wintellect.PowerCollections.OrderedSet-1.html">OrderedSet</a>&lt;T&gt;</td>
        <td><span class="parametername">otherSet</span></td>
        <td><p>Set to compare to.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Boolean</span></td>
        <td><p>True if this is a subset of <code data-dev-comment-type="paramref" class="paramref">otherSet</code>.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="Wintellect_PowerCollections_OrderedSet_1_IsSubsetOf_Wintellect_PowerCollections_OrderedSet__0___remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>IsSubsetOf is computed in time O(N log M), where M is the size of the
<code data-dev-comment-type="paramref" class="paramref">otherSet</code>, and N is the size of the this set.</p>
</div>
  <h5 class="exceptions">Exceptions</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Condition</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.InvalidOperationException</span></td>
        <td><p>This set and <code data-dev-comment-type="paramref" class="paramref">otherSet</code> don't use the same method for comparing items.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Wintellect_PowerCollections_OrderedSet_1_IsSupersetOf_" data-uid="Wintellect.PowerCollections.OrderedSet`1.IsSupersetOf*"></a>
  <h4 id="Wintellect_PowerCollections_OrderedSet_1_IsSupersetOf_Wintellect_PowerCollections_OrderedSet__0__" data-uid="Wintellect.PowerCollections.OrderedSet`1.IsSupersetOf(Wintellect.PowerCollections.OrderedSet{`0})">IsSupersetOf(OrderedSet&lt;T&gt;)</h4>
  <div class="markdown level1 summary"><p>Determines if this set is a superset of another set. Neither set is modified.
This set is a superset of <code data-dev-comment-type="paramref" class="paramref">otherSet</code> if every element in
<code data-dev-comment-type="paramref" class="paramref">otherSet</code> is also in this set.
<remarks>IsSupersetOf is computed in time O(M log N), where M is the size of the
<code data-dev-comment-type="paramref" class="paramref">otherSet</code>, and N is the size of the this set.</remarks></p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public bool IsSupersetOf(OrderedSet&lt;T&gt; otherSet)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Wintellect.PowerCollections.OrderedSet-1.html">OrderedSet</a>&lt;T&gt;</td>
        <td><span class="parametername">otherSet</span></td>
        <td><p>OrderedSet to compare to.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Boolean</span></td>
        <td><p>True if this is a superset of <code data-dev-comment-type="paramref" class="paramref">otherSet</code>.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="exceptions">Exceptions</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Condition</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.InvalidOperationException</span></td>
        <td><p>This set and <code data-dev-comment-type="paramref" class="paramref">otherSet</code> don't use the same method for comparing items.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Wintellect_PowerCollections_OrderedSet_1_IsSupersetOf_" data-uid="Wintellect.PowerCollections.OrderedSet`1.IsSupersetOf*"></a>
  <h4 id="Wintellect_PowerCollections_OrderedSet_1_IsSupersetOf_Wintellect_PowerCollections_OrderedSet__0__" data-uid="Wintellect.PowerCollections.OrderedSet`1.IsSupersetOf(Wintellect.PowerCollections.OrderedSet{`0})">IsSupersetOf(OrderedSet&lt;T&gt;)</h4>
  <div class="markdown level1 summary"><p>Determines if this set is a superset of another set. Neither set is modified.
This set is a superset of <code data-dev-comment-type="paramref" class="paramref">otherSet</code> if every element in
<code data-dev-comment-type="paramref" class="paramref">otherSet</code> is also in this set.
<remarks>IsSupersetOf is computed in time O(M log N), where M is the size of the
<code data-dev-comment-type="paramref" class="paramref">otherSet</code>, and N is the size of the this set.</remarks></p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public bool IsSupersetOf(OrderedSet&lt;T&gt; otherSet)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Wintellect.PowerCollections.OrderedSet-1.html">OrderedSet</a>&lt;T&gt;</td>
        <td><span class="parametername">otherSet</span></td>
        <td><p>OrderedSet to compare to.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Boolean</span></td>
        <td><p>True if this is a superset of <code data-dev-comment-type="paramref" class="paramref">otherSet</code>.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="exceptions">Exceptions</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Condition</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.InvalidOperationException</span></td>
        <td><p>This set and <code data-dev-comment-type="paramref" class="paramref">otherSet</code> don't use the same method for comparing items.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Wintellect_PowerCollections_OrderedSet_1_Range_" data-uid="Wintellect.PowerCollections.OrderedSet`1.Range*"></a>
  <h4 id="Wintellect_PowerCollections_OrderedSet_1_Range__0_System_Boolean__0_System_Boolean_" data-uid="Wintellect.PowerCollections.OrderedSet`1.Range(`0,System.Boolean,`0,System.Boolean)">Range(T, Boolean, T, Boolean)</h4>
  <div class="markdown level1 summary"><p>Returns a View collection that can be used for enumerating a range of the items in the set..
Only items that are greater than <code data-dev-comment-type="paramref" class="paramref">from</code> and
less than <code data-dev-comment-type="paramref" class="paramref">to</code> are included. The items are enumerated in sorted order.
Items equal to the end points of the range can be included or excluded depending on the
<code data-dev-comment-type="paramref" class="paramref">fromInclusive</code> and <code data-dev-comment-type="paramref" class="paramref">toInclusive</code> parameters.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public OrderedSet&lt;T&gt;.View Range(T from, bool fromInclusive, T to, bool toInclusive)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">T</span></td>
        <td><span class="parametername">from</span></td>
        <td><p>The lower bound of the range.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Boolean</span></td>
        <td><span class="parametername">fromInclusive</span></td>
        <td><p>If true, the lower bound is inclusive--items equal to the lower bound will
be included in the range. If false, the lower bound is exclusive--items equal to the lower bound will not
be included in the range.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">T</span></td>
        <td><span class="parametername">to</span></td>
        <td><p>The upper bound of the range.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Boolean</span></td>
        <td><span class="parametername">toInclusive</span></td>
        <td><p>If true, the upper bound is inclusive--items equal to the upper bound will
be included in the range. If false, the upper bound is exclusive--items equal to the upper bound will not
be included in the range.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Wintellect.PowerCollections.OrderedSet-1.View.html">OrderedSet.View</a>&lt;&gt;</td>
        <td><p>An OrderedSet.View of items in the given range.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="Wintellect_PowerCollections_OrderedSet_1_Range__0_System_Boolean__0_System_Boolean__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>If <code data-dev-comment-type="paramref" class="paramref">from</code> is greater than <code data-dev-comment-type="paramref" class="paramref">to</code>, the returned collection is empty. </p>
<p>Typically, this method is used in conjunction with a foreach statement. For example:
<pre><code> foreach(T item in set.Range(from, true, to, false)) {
    // process item
 }</code></pre></p>
<p>If an item is added to or deleted from the set while the View is being enumerated, then 
the enumeration will end with an InvalidOperationException.</p>
<p>Calling Range does not copy the data in the tree, and the operation takes constant time.</p>
</div>
  
  
  <a id="Wintellect_PowerCollections_OrderedSet_1_Range_" data-uid="Wintellect.PowerCollections.OrderedSet`1.Range*"></a>
  <h4 id="Wintellect_PowerCollections_OrderedSet_1_Range__0_System_Boolean__0_System_Boolean_" data-uid="Wintellect.PowerCollections.OrderedSet`1.Range(`0,System.Boolean,`0,System.Boolean)">Range(T, Boolean, T, Boolean)</h4>
  <div class="markdown level1 summary"><p>Returns a View collection that can be used for enumerating a range of the items in the set..
Only items that are greater than <code data-dev-comment-type="paramref" class="paramref">from</code> and
less than <code data-dev-comment-type="paramref" class="paramref">to</code> are included. The items are enumerated in sorted order.
Items equal to the end points of the range can be included or excluded depending on the
<code data-dev-comment-type="paramref" class="paramref">fromInclusive</code> and <code data-dev-comment-type="paramref" class="paramref">toInclusive</code> parameters.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public OrderedSet&lt;T&gt;.View Range(T from, bool fromInclusive, T to, bool toInclusive)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">T</span></td>
        <td><span class="parametername">from</span></td>
        <td><p>The lower bound of the range.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Boolean</span></td>
        <td><span class="parametername">fromInclusive</span></td>
        <td><p>If true, the lower bound is inclusive--items equal to the lower bound will
be included in the range. If false, the lower bound is exclusive--items equal to the lower bound will not
be included in the range.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">T</span></td>
        <td><span class="parametername">to</span></td>
        <td><p>The upper bound of the range.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Boolean</span></td>
        <td><span class="parametername">toInclusive</span></td>
        <td><p>If true, the upper bound is inclusive--items equal to the upper bound will
be included in the range. If false, the upper bound is exclusive--items equal to the upper bound will not
be included in the range.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Wintellect.PowerCollections.OrderedSet-1.View.html">OrderedSet.View</a>&lt;&gt;</td>
        <td><p>An OrderedSet.View of items in the given range.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="Wintellect_PowerCollections_OrderedSet_1_Range__0_System_Boolean__0_System_Boolean__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>If <code data-dev-comment-type="paramref" class="paramref">from</code> is greater than <code data-dev-comment-type="paramref" class="paramref">to</code>, the returned collection is empty. </p>
<p>Typically, this method is used in conjunction with a foreach statement. For example:
<pre><code> foreach(T item in set.Range(from, true, to, false)) {
    // process item
 }</code></pre></p>
<p>If an item is added to or deleted from the set while the View is being enumerated, then 
the enumeration will end with an InvalidOperationException.</p>
<p>Calling Range does not copy the data in the tree, and the operation takes constant time.</p>
</div>
  
  
  <a id="Wintellect_PowerCollections_OrderedSet_1_RangeFrom_" data-uid="Wintellect.PowerCollections.OrderedSet`1.RangeFrom*"></a>
  <h4 id="Wintellect_PowerCollections_OrderedSet_1_RangeFrom__0_System_Boolean_" data-uid="Wintellect.PowerCollections.OrderedSet`1.RangeFrom(`0,System.Boolean)">RangeFrom(T, Boolean)</h4>
  <div class="markdown level1 summary"><p>Returns a View collection that can be used for enumerating a range of the items in the set..
Only items that are greater than (and optionally, equal to) <code data-dev-comment-type="paramref" class="paramref">from</code> are included.
The items are enumerated in sorted order. Items equal to <code data-dev-comment-type="paramref" class="paramref">from</code> can be included
or excluded depending on the <code data-dev-comment-type="paramref" class="paramref">fromInclusive</code> parameter.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public OrderedSet&lt;T&gt;.View RangeFrom(T from, bool fromInclusive)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">T</span></td>
        <td><span class="parametername">from</span></td>
        <td><p>The lower bound of the range.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Boolean</span></td>
        <td><span class="parametername">fromInclusive</span></td>
        <td><p>If true, the lower bound is inclusive--items equal to the lower bound will
be included in the range. If false, the lower bound is exclusive--items equal to the lower bound will not
be included in the range.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Wintellect.PowerCollections.OrderedSet-1.View.html">OrderedSet.View</a>&lt;&gt;</td>
        <td><p>An OrderedSet.View of items in the given range.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="Wintellect_PowerCollections_OrderedSet_1_RangeFrom__0_System_Boolean__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>Typically, this method is used in conjunction with a foreach statement. For example:
<pre><code> foreach(T item in set.RangeFrom(from, true)) {
    // process item
 }</code></pre></p>
<p>If an item is added to or deleted from the set while the View is being enumerated, then 
the enumeration will end with an InvalidOperationException.</p>
<p>Calling RangeFrom does not copy the data in the tree, and the operation takes constant time.</p>
</div>
  
  
  <a id="Wintellect_PowerCollections_OrderedSet_1_RangeFrom_" data-uid="Wintellect.PowerCollections.OrderedSet`1.RangeFrom*"></a>
  <h4 id="Wintellect_PowerCollections_OrderedSet_1_RangeFrom__0_System_Boolean_" data-uid="Wintellect.PowerCollections.OrderedSet`1.RangeFrom(`0,System.Boolean)">RangeFrom(T, Boolean)</h4>
  <div class="markdown level1 summary"><p>Returns a View collection that can be used for enumerating a range of the items in the set..
Only items that are greater than (and optionally, equal to) <code data-dev-comment-type="paramref" class="paramref">from</code> are included.
The items are enumerated in sorted order. Items equal to <code data-dev-comment-type="paramref" class="paramref">from</code> can be included
or excluded depending on the <code data-dev-comment-type="paramref" class="paramref">fromInclusive</code> parameter.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public OrderedSet&lt;T&gt;.View RangeFrom(T from, bool fromInclusive)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">T</span></td>
        <td><span class="parametername">from</span></td>
        <td><p>The lower bound of the range.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Boolean</span></td>
        <td><span class="parametername">fromInclusive</span></td>
        <td><p>If true, the lower bound is inclusive--items equal to the lower bound will
be included in the range. If false, the lower bound is exclusive--items equal to the lower bound will not
be included in the range.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Wintellect.PowerCollections.OrderedSet-1.View.html">OrderedSet.View</a>&lt;&gt;</td>
        <td><p>An OrderedSet.View of items in the given range.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="Wintellect_PowerCollections_OrderedSet_1_RangeFrom__0_System_Boolean__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>Typically, this method is used in conjunction with a foreach statement. For example:
<pre><code> foreach(T item in set.RangeFrom(from, true)) {
    // process item
 }</code></pre></p>
<p>If an item is added to or deleted from the set while the View is being enumerated, then 
the enumeration will end with an InvalidOperationException.</p>
<p>Calling RangeFrom does not copy the data in the tree, and the operation takes constant time.</p>
</div>
  
  
  <a id="Wintellect_PowerCollections_OrderedSet_1_RangeTo_" data-uid="Wintellect.PowerCollections.OrderedSet`1.RangeTo*"></a>
  <h4 id="Wintellect_PowerCollections_OrderedSet_1_RangeTo__0_System_Boolean_" data-uid="Wintellect.PowerCollections.OrderedSet`1.RangeTo(`0,System.Boolean)">RangeTo(T, Boolean)</h4>
  <div class="markdown level1 summary"><p>Returns a View collection that can be used for enumerating a range of the items in the set..
Only items that are less than (and optionally, equal to) <code data-dev-comment-type="paramref" class="paramref">to</code> are included.
The items are enumerated in sorted order. Items equal to <code data-dev-comment-type="paramref" class="paramref">to</code> can be included
or excluded depending on the <code data-dev-comment-type="paramref" class="paramref">toInclusive</code> parameter.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public OrderedSet&lt;T&gt;.View RangeTo(T to, bool toInclusive)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">T</span></td>
        <td><span class="parametername">to</span></td>
        <td><p>The upper bound of the range.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Boolean</span></td>
        <td><span class="parametername">toInclusive</span></td>
        <td><p>If true, the upper bound is inclusive--items equal to the upper bound will
be included in the range. If false, the upper bound is exclusive--items equal to the upper bound will not
be included in the range.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Wintellect.PowerCollections.OrderedSet-1.View.html">OrderedSet.View</a>&lt;&gt;</td>
        <td><p>An OrderedSet.View of items in the given range.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="Wintellect_PowerCollections_OrderedSet_1_RangeTo__0_System_Boolean__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>Typically, this method is used in conjunction with a foreach statement. For example:
<pre><code> foreach(T item in set.RangeTo(to, false)) {
    // process item
 }</code></pre></p>
<p>If an item is added to or deleted from the set while the View is being enumerated, then 
the enumeration will end with an InvalidOperationException.</p>
<p>Calling RangeTo does not copy the data in the tree, and the operation takes constant time.</p>
</div>
  
  
  <a id="Wintellect_PowerCollections_OrderedSet_1_RangeTo_" data-uid="Wintellect.PowerCollections.OrderedSet`1.RangeTo*"></a>
  <h4 id="Wintellect_PowerCollections_OrderedSet_1_RangeTo__0_System_Boolean_" data-uid="Wintellect.PowerCollections.OrderedSet`1.RangeTo(`0,System.Boolean)">RangeTo(T, Boolean)</h4>
  <div class="markdown level1 summary"><p>Returns a View collection that can be used for enumerating a range of the items in the set..
Only items that are less than (and optionally, equal to) <code data-dev-comment-type="paramref" class="paramref">to</code> are included.
The items are enumerated in sorted order. Items equal to <code data-dev-comment-type="paramref" class="paramref">to</code> can be included
or excluded depending on the <code data-dev-comment-type="paramref" class="paramref">toInclusive</code> parameter.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public OrderedSet&lt;T&gt;.View RangeTo(T to, bool toInclusive)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">T</span></td>
        <td><span class="parametername">to</span></td>
        <td><p>The upper bound of the range.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Boolean</span></td>
        <td><span class="parametername">toInclusive</span></td>
        <td><p>If true, the upper bound is inclusive--items equal to the upper bound will
be included in the range. If false, the upper bound is exclusive--items equal to the upper bound will not
be included in the range.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Wintellect.PowerCollections.OrderedSet-1.View.html">OrderedSet.View</a>&lt;&gt;</td>
        <td><p>An OrderedSet.View of items in the given range.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="Wintellect_PowerCollections_OrderedSet_1_RangeTo__0_System_Boolean__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>Typically, this method is used in conjunction with a foreach statement. For example:
<pre><code> foreach(T item in set.RangeTo(to, false)) {
    // process item
 }</code></pre></p>
<p>If an item is added to or deleted from the set while the View is being enumerated, then 
the enumeration will end with an InvalidOperationException.</p>
<p>Calling RangeTo does not copy the data in the tree, and the operation takes constant time.</p>
</div>
  
  
  <a id="Wintellect_PowerCollections_OrderedSet_1_Remove_" data-uid="Wintellect.PowerCollections.OrderedSet`1.Remove*"></a>
  <h4 id="Wintellect_PowerCollections_OrderedSet_1_Remove__0_" data-uid="Wintellect.PowerCollections.OrderedSet`1.Remove(`0)">Remove(T)</h4>
  <div class="markdown level1 summary"><p>Searches the set for an item equal to <code data-dev-comment-type="paramref" class="paramref">item</code>, and if found,
removes it from the set. If not found, the set is unchanged.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public sealed override bool Remove(T item)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">T</span></td>
        <td><span class="parametername">item</span></td>
        <td><p>The item to remove.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Boolean</span></td>
        <td><p>True if <code data-dev-comment-type="paramref" class="paramref">item</code> was found and removed. False if <code data-dev-comment-type="paramref" class="paramref">item</code> was not in the set.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="overrides">Overrides</h5>
  <div><span class="xref">Wintellect.PowerCollections.CollectionBase&lt;T&gt;.Remove(T)</span></div>
  <h5 id="Wintellect_PowerCollections_OrderedSet_1_Remove__0__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>Equality between items is determined by the comparison instance or delegate used
to create the set.</p>
<p>Removing an item from the set takes time O(log N), where N is the number of items in the set.</p>
</div>
  
  
  <a id="Wintellect_PowerCollections_OrderedSet_1_Remove_" data-uid="Wintellect.PowerCollections.OrderedSet`1.Remove*"></a>
  <h4 id="Wintellect_PowerCollections_OrderedSet_1_Remove__0_" data-uid="Wintellect.PowerCollections.OrderedSet`1.Remove(`0)">Remove(T)</h4>
  <div class="markdown level1 summary"><p>Searches the set for an item equal to <code data-dev-comment-type="paramref" class="paramref">item</code>, and if found,
removes it from the set. If not found, the set is unchanged.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public sealed override bool Remove(T item)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">T</span></td>
        <td><span class="parametername">item</span></td>
        <td><p>The item to remove.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Boolean</span></td>
        <td><p>True if <code data-dev-comment-type="paramref" class="paramref">item</code> was found and removed. False if <code data-dev-comment-type="paramref" class="paramref">item</code> was not in the set.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="overrides">Overrides</h5>
  <div><span class="xref">Wintellect.PowerCollections.CollectionBase&lt;T&gt;.Remove(T)</span></div>
  <h5 id="Wintellect_PowerCollections_OrderedSet_1_Remove__0__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>Equality between items is determined by the comparison instance or delegate used
to create the set.</p>
<p>Removing an item from the set takes time O(log N), where N is the number of items in the set.</p>
</div>
  
  
  <a id="Wintellect_PowerCollections_OrderedSet_1_RemoveFirst_" data-uid="Wintellect.PowerCollections.OrderedSet`1.RemoveFirst*"></a>
  <h4 id="Wintellect_PowerCollections_OrderedSet_1_RemoveFirst" data-uid="Wintellect.PowerCollections.OrderedSet`1.RemoveFirst">RemoveFirst()</h4>
  <div class="markdown level1 summary"><p>Removes the first item in the set. This is also the smallest item in the set.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public T RemoveFirst()</code></pre>
  </div>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">T</span></td>
        <td><p>The item that was removed, which was the smallest item in the set.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="Wintellect_PowerCollections_OrderedSet_1_RemoveFirst_remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>RemoveFirst() takes time O(log N), where N is the number of items in the set.</p>
</div>
  <h5 class="exceptions">Exceptions</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Condition</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.InvalidOperationException</span></td>
        <td><p>The set is empty.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Wintellect_PowerCollections_OrderedSet_1_RemoveFirst_" data-uid="Wintellect.PowerCollections.OrderedSet`1.RemoveFirst*"></a>
  <h4 id="Wintellect_PowerCollections_OrderedSet_1_RemoveFirst" data-uid="Wintellect.PowerCollections.OrderedSet`1.RemoveFirst">RemoveFirst()</h4>
  <div class="markdown level1 summary"><p>Removes the first item in the set. This is also the smallest item in the set.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public T RemoveFirst()</code></pre>
  </div>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">T</span></td>
        <td><p>The item that was removed, which was the smallest item in the set.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="Wintellect_PowerCollections_OrderedSet_1_RemoveFirst_remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>RemoveFirst() takes time O(log N), where N is the number of items in the set.</p>
</div>
  <h5 class="exceptions">Exceptions</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Condition</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.InvalidOperationException</span></td>
        <td><p>The set is empty.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Wintellect_PowerCollections_OrderedSet_1_RemoveLast_" data-uid="Wintellect.PowerCollections.OrderedSet`1.RemoveLast*"></a>
  <h4 id="Wintellect_PowerCollections_OrderedSet_1_RemoveLast" data-uid="Wintellect.PowerCollections.OrderedSet`1.RemoveLast">RemoveLast()</h4>
  <div class="markdown level1 summary"><p>Removes the last item in the set. This is also the largest item in the set.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public T RemoveLast()</code></pre>
  </div>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">T</span></td>
        <td><p>The item that was removed, which was the largest item in the set.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="Wintellect_PowerCollections_OrderedSet_1_RemoveLast_remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>RemoveLast() takes time O(log N), where N is the number of items in the set.</p>
</div>
  <h5 class="exceptions">Exceptions</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Condition</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.InvalidOperationException</span></td>
        <td><p>The set is empty.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Wintellect_PowerCollections_OrderedSet_1_RemoveLast_" data-uid="Wintellect.PowerCollections.OrderedSet`1.RemoveLast*"></a>
  <h4 id="Wintellect_PowerCollections_OrderedSet_1_RemoveLast" data-uid="Wintellect.PowerCollections.OrderedSet`1.RemoveLast">RemoveLast()</h4>
  <div class="markdown level1 summary"><p>Removes the last item in the set. This is also the largest item in the set.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public T RemoveLast()</code></pre>
  </div>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">T</span></td>
        <td><p>The item that was removed, which was the largest item in the set.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="Wintellect_PowerCollections_OrderedSet_1_RemoveLast_remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>RemoveLast() takes time O(log N), where N is the number of items in the set.</p>
</div>
  <h5 class="exceptions">Exceptions</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Condition</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.InvalidOperationException</span></td>
        <td><p>The set is empty.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Wintellect_PowerCollections_OrderedSet_1_RemoveMany_" data-uid="Wintellect.PowerCollections.OrderedSet`1.RemoveMany*"></a>
  <h4 id="Wintellect_PowerCollections_OrderedSet_1_RemoveMany_System_Collections_Generic_IEnumerable__0__" data-uid="Wintellect.PowerCollections.OrderedSet`1.RemoveMany(System.Collections.Generic.IEnumerable{`0})">RemoveMany(IEnumerable&lt;T&gt;)</h4>
  <div class="markdown level1 summary"><p>Removes all the items in <code data-dev-comment-type="paramref" class="paramref">collection</code> from the set. Items
not present in the set are ignored.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public int RemoveMany(IEnumerable&lt;T&gt; collection)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Collections.Generic.IEnumerable</span>&lt;T&gt;</td>
        <td><span class="parametername">collection</span></td>
        <td><p>A collection of items to remove from the set.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Int32</span></td>
        <td><p>The number of items removed from the set.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="Wintellect_PowerCollections_OrderedSet_1_RemoveMany_System_Collections_Generic_IEnumerable__0___remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>Equality between items is determined by the comparison instance or delegate used
to create the set.</p>
<p>Removing the collection takes time O(M log N), where N is the number of items in the set, and M is the 
number of items in <code data-dev-comment-type="paramref" class="paramref">collection</code>.</p>
</div>
  <h5 class="exceptions">Exceptions</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Condition</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.ArgumentNullException</span></td>
        <td><p><code data-dev-comment-type="paramref" class="paramref">collection</code> is null.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Wintellect_PowerCollections_OrderedSet_1_RemoveMany_" data-uid="Wintellect.PowerCollections.OrderedSet`1.RemoveMany*"></a>
  <h4 id="Wintellect_PowerCollections_OrderedSet_1_RemoveMany_System_Collections_Generic_IEnumerable__0__" data-uid="Wintellect.PowerCollections.OrderedSet`1.RemoveMany(System.Collections.Generic.IEnumerable{`0})">RemoveMany(IEnumerable&lt;T&gt;)</h4>
  <div class="markdown level1 summary"><p>Removes all the items in <code data-dev-comment-type="paramref" class="paramref">collection</code> from the set. Items
not present in the set are ignored.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public int RemoveMany(IEnumerable&lt;T&gt; collection)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Collections.Generic.IEnumerable</span>&lt;T&gt;</td>
        <td><span class="parametername">collection</span></td>
        <td><p>A collection of items to remove from the set.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Int32</span></td>
        <td><p>The number of items removed from the set.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="Wintellect_PowerCollections_OrderedSet_1_RemoveMany_System_Collections_Generic_IEnumerable__0___remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>Equality between items is determined by the comparison instance or delegate used
to create the set.</p>
<p>Removing the collection takes time O(M log N), where N is the number of items in the set, and M is the 
number of items in <code data-dev-comment-type="paramref" class="paramref">collection</code>.</p>
</div>
  <h5 class="exceptions">Exceptions</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Condition</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.ArgumentNullException</span></td>
        <td><p><code data-dev-comment-type="paramref" class="paramref">collection</code> is null.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Wintellect_PowerCollections_OrderedSet_1_Reversed_" data-uid="Wintellect.PowerCollections.OrderedSet`1.Reversed*"></a>
  <h4 id="Wintellect_PowerCollections_OrderedSet_1_Reversed" data-uid="Wintellect.PowerCollections.OrderedSet`1.Reversed">Reversed()</h4>
  <div class="markdown level1 summary"><p>Returns a View collection that can be used for enumerating the items in the set in
reversed order.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public OrderedSet&lt;T&gt;.View Reversed()</code></pre>
  </div>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Wintellect.PowerCollections.OrderedSet-1.View.html">OrderedSet.View</a>&lt;&gt;</td>
        <td><p>An OrderedSet.View of items in reverse order.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="Wintellect_PowerCollections_OrderedSet_1_Reversed_remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>Typically, this method is used in conjunction with a foreach statement. For example:
<pre><code> foreach(T item in set.Reversed()) {
    // process item
 }</code></pre></p>
<p>If an item is added to or deleted from the set while the View is being enumerated, then 
the enumeration will end with an InvalidOperationException.</p>
<p>Calling Reverse does not copy the data in the tree, and the operation takes constant time.</p>
</div>
  
  
  <a id="Wintellect_PowerCollections_OrderedSet_1_Reversed_" data-uid="Wintellect.PowerCollections.OrderedSet`1.Reversed*"></a>
  <h4 id="Wintellect_PowerCollections_OrderedSet_1_Reversed" data-uid="Wintellect.PowerCollections.OrderedSet`1.Reversed">Reversed()</h4>
  <div class="markdown level1 summary"><p>Returns a View collection that can be used for enumerating the items in the set in
reversed order.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public OrderedSet&lt;T&gt;.View Reversed()</code></pre>
  </div>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Wintellect.PowerCollections.OrderedSet-1.View.html">OrderedSet.View</a>&lt;&gt;</td>
        <td><p>An OrderedSet.View of items in reverse order.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="Wintellect_PowerCollections_OrderedSet_1_Reversed_remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>Typically, this method is used in conjunction with a foreach statement. For example:
<pre><code> foreach(T item in set.Reversed()) {
    // process item
 }</code></pre></p>
<p>If an item is added to or deleted from the set while the View is being enumerated, then 
the enumeration will end with an InvalidOperationException.</p>
<p>Calling Reverse does not copy the data in the tree, and the operation takes constant time.</p>
</div>
  
  
  <a id="Wintellect_PowerCollections_OrderedSet_1_SymmetricDifference_" data-uid="Wintellect.PowerCollections.OrderedSet`1.SymmetricDifference*"></a>
  <h4 id="Wintellect_PowerCollections_OrderedSet_1_SymmetricDifference_Wintellect_PowerCollections_OrderedSet__0__" data-uid="Wintellect.PowerCollections.OrderedSet`1.SymmetricDifference(Wintellect.PowerCollections.OrderedSet{`0})">SymmetricDifference(OrderedSet&lt;T&gt;)</h4>
  <div class="markdown level1 summary"><p>Computes the symmetric difference of this set with another set. The symmetric difference of two sets
is all items that appear in either of the sets, but not both. A new set is
created with the symmetric difference of the sets and is returned. This set and the other set
are unchanged.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public OrderedSet&lt;T&gt; SymmetricDifference(OrderedSet&lt;T&gt; otherSet)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Wintellect.PowerCollections.OrderedSet-1.html">OrderedSet</a>&lt;T&gt;</td>
        <td><span class="parametername">otherSet</span></td>
        <td><p>Set to symmetric difference with.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Wintellect.PowerCollections.OrderedSet-1.html">OrderedSet</a>&lt;T&gt;</td>
        <td><p>The symmetric difference of the two sets.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="Wintellect_PowerCollections_OrderedSet_1_SymmetricDifference_Wintellect_PowerCollections_OrderedSet__0___remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>The symmetric difference of two sets is computed in time O(M + N log M), where M is the size of the 
larger set, and N is the size of the smaller set.</p>
</div>
  <h5 class="exceptions">Exceptions</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Condition</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.InvalidOperationException</span></td>
        <td><p>This set and <code data-dev-comment-type="paramref" class="paramref">otherSet</code> don't use the same method for comparing items.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Wintellect_PowerCollections_OrderedSet_1_SymmetricDifference_" data-uid="Wintellect.PowerCollections.OrderedSet`1.SymmetricDifference*"></a>
  <h4 id="Wintellect_PowerCollections_OrderedSet_1_SymmetricDifference_Wintellect_PowerCollections_OrderedSet__0__" data-uid="Wintellect.PowerCollections.OrderedSet`1.SymmetricDifference(Wintellect.PowerCollections.OrderedSet{`0})">SymmetricDifference(OrderedSet&lt;T&gt;)</h4>
  <div class="markdown level1 summary"><p>Computes the symmetric difference of this set with another set. The symmetric difference of two sets
is all items that appear in either of the sets, but not both. A new set is
created with the symmetric difference of the sets and is returned. This set and the other set
are unchanged.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public OrderedSet&lt;T&gt; SymmetricDifference(OrderedSet&lt;T&gt; otherSet)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Wintellect.PowerCollections.OrderedSet-1.html">OrderedSet</a>&lt;T&gt;</td>
        <td><span class="parametername">otherSet</span></td>
        <td><p>Set to symmetric difference with.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Wintellect.PowerCollections.OrderedSet-1.html">OrderedSet</a>&lt;T&gt;</td>
        <td><p>The symmetric difference of the two sets.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="Wintellect_PowerCollections_OrderedSet_1_SymmetricDifference_Wintellect_PowerCollections_OrderedSet__0___remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>The symmetric difference of two sets is computed in time O(M + N log M), where M is the size of the 
larger set, and N is the size of the smaller set.</p>
</div>
  <h5 class="exceptions">Exceptions</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Condition</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.InvalidOperationException</span></td>
        <td><p>This set and <code data-dev-comment-type="paramref" class="paramref">otherSet</code> don't use the same method for comparing items.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Wintellect_PowerCollections_OrderedSet_1_SymmetricDifferenceWith_" data-uid="Wintellect.PowerCollections.OrderedSet`1.SymmetricDifferenceWith*"></a>
  <h4 id="Wintellect_PowerCollections_OrderedSet_1_SymmetricDifferenceWith_Wintellect_PowerCollections_OrderedSet__0__" data-uid="Wintellect.PowerCollections.OrderedSet`1.SymmetricDifferenceWith(Wintellect.PowerCollections.OrderedSet{`0})">SymmetricDifferenceWith(OrderedSet&lt;T&gt;)</h4>
  <div class="markdown level1 summary"><p>Computes the symmetric difference of this set with another set. The symmetric difference of two sets
is all items that appear in either of the sets, but not both. This set receives
the symmetric difference of the two sets; the other set is unchanged.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public void SymmetricDifferenceWith(OrderedSet&lt;T&gt; otherSet)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Wintellect.PowerCollections.OrderedSet-1.html">OrderedSet</a>&lt;T&gt;</td>
        <td><span class="parametername">otherSet</span></td>
        <td><p>Set to symmetric difference with.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="Wintellect_PowerCollections_OrderedSet_1_SymmetricDifferenceWith_Wintellect_PowerCollections_OrderedSet__0___remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>The symmetric difference of two sets is computed in time O(M + N log M), where M is the size of the 
larger set, and N is the size of the smaller set.</p>
</div>
  <h5 class="exceptions">Exceptions</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Condition</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.InvalidOperationException</span></td>
        <td><p>This set and <code data-dev-comment-type="paramref" class="paramref">otherSet</code> don't use the same method for comparing items.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Wintellect_PowerCollections_OrderedSet_1_SymmetricDifferenceWith_" data-uid="Wintellect.PowerCollections.OrderedSet`1.SymmetricDifferenceWith*"></a>
  <h4 id="Wintellect_PowerCollections_OrderedSet_1_SymmetricDifferenceWith_Wintellect_PowerCollections_OrderedSet__0__" data-uid="Wintellect.PowerCollections.OrderedSet`1.SymmetricDifferenceWith(Wintellect.PowerCollections.OrderedSet{`0})">SymmetricDifferenceWith(OrderedSet&lt;T&gt;)</h4>
  <div class="markdown level1 summary"><p>Computes the symmetric difference of this set with another set. The symmetric difference of two sets
is all items that appear in either of the sets, but not both. This set receives
the symmetric difference of the two sets; the other set is unchanged.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public void SymmetricDifferenceWith(OrderedSet&lt;T&gt; otherSet)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Wintellect.PowerCollections.OrderedSet-1.html">OrderedSet</a>&lt;T&gt;</td>
        <td><span class="parametername">otherSet</span></td>
        <td><p>Set to symmetric difference with.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="Wintellect_PowerCollections_OrderedSet_1_SymmetricDifferenceWith_Wintellect_PowerCollections_OrderedSet__0___remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>The symmetric difference of two sets is computed in time O(M + N log M), where M is the size of the 
larger set, and N is the size of the smaller set.</p>
</div>
  <h5 class="exceptions">Exceptions</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Condition</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.InvalidOperationException</span></td>
        <td><p>This set and <code data-dev-comment-type="paramref" class="paramref">otherSet</code> don't use the same method for comparing items.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Wintellect_PowerCollections_OrderedSet_1_TryGetItem_" data-uid="Wintellect.PowerCollections.OrderedSet`1.TryGetItem*"></a>
  <h4 id="Wintellect_PowerCollections_OrderedSet_1_TryGetItem__0__0__" data-uid="Wintellect.PowerCollections.OrderedSet`1.TryGetItem(`0,`0@)">TryGetItem(T, out T)</h4>
  <div class="markdown level1 summary"><p>Determines if this set contains an item equal to <code data-dev-comment-type="paramref" class="paramref">item</code>, according to the 
comparison mechanism that was used when the set was created. The set
is not changed.</p>
<p>If the set does contain an item equal to <code data-dev-comment-type="paramref" class="paramref">item</code>, then the item from the set is returned.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public bool TryGetItem(T item, out T foundItem)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">T</span></td>
        <td><span class="parametername">item</span></td>
        <td><p>The item to search for.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">T</span></td>
        <td><span class="parametername">foundItem</span></td>
        <td><p>Returns the item from the set that was equal to <code data-dev-comment-type="paramref" class="paramref">item</code>.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Boolean</span></td>
        <td><p>True if the set contains <code data-dev-comment-type="paramref" class="paramref">item</code>. False if the set does not contain <code data-dev-comment-type="paramref" class="paramref">item</code>.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="Wintellect_PowerCollections_OrderedSet_1_TryGetItem__0__0___remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>Searching the set for an item takes time O(log N), where N is the number of items in the set.</p>
</div>
  <h5 id="Wintellect_PowerCollections_OrderedSet_1_TryGetItem__0__0___examples">Examples</h5>
  <p>In the following example, the set contains strings which are compared in a case-insensitive manner.</p>
<pre><code>OrderedSet&lt;string> set = new OrderedSet&lt;string>(StringComparer.CurrentCultureIgnoreCase);
set.Add(&quot;HELLO&quot;);
string s;
bool b = set.TryGetItem(&quot;Hello&quot;, out s);   // b receives true, s receives &quot;HELLO&quot;.</code></pre>

  
  
  <a id="Wintellect_PowerCollections_OrderedSet_1_TryGetItem_" data-uid="Wintellect.PowerCollections.OrderedSet`1.TryGetItem*"></a>
  <h4 id="Wintellect_PowerCollections_OrderedSet_1_TryGetItem__0__0__" data-uid="Wintellect.PowerCollections.OrderedSet`1.TryGetItem(`0,`0@)">TryGetItem(T, out T)</h4>
  <div class="markdown level1 summary"><p>Determines if this set contains an item equal to <code data-dev-comment-type="paramref" class="paramref">item</code>, according to the 
comparison mechanism that was used when the set was created. The set
is not changed.</p>
<p>If the set does contain an item equal to <code data-dev-comment-type="paramref" class="paramref">item</code>, then the item from the set is returned.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public bool TryGetItem(T item, out T foundItem)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">T</span></td>
        <td><span class="parametername">item</span></td>
        <td><p>The item to search for.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">T</span></td>
        <td><span class="parametername">foundItem</span></td>
        <td><p>Returns the item from the set that was equal to <code data-dev-comment-type="paramref" class="paramref">item</code>.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Boolean</span></td>
        <td><p>True if the set contains <code data-dev-comment-type="paramref" class="paramref">item</code>. False if the set does not contain <code data-dev-comment-type="paramref" class="paramref">item</code>.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="Wintellect_PowerCollections_OrderedSet_1_TryGetItem__0__0___remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>Searching the set for an item takes time O(log N), where N is the number of items in the set.</p>
</div>
  <h5 id="Wintellect_PowerCollections_OrderedSet_1_TryGetItem__0__0___examples">Examples</h5>
  <p>In the following example, the set contains strings which are compared in a case-insensitive manner.</p>
<pre><code>OrderedSet&lt;string> set = new OrderedSet&lt;string>(StringComparer.CurrentCultureIgnoreCase);
set.Add(&quot;HELLO&quot;);
string s;
bool b = set.TryGetItem(&quot;Hello&quot;, out s);   // b receives true, s receives &quot;HELLO&quot;.</code></pre>

  
  
  <a id="Wintellect_PowerCollections_OrderedSet_1_Union_" data-uid="Wintellect.PowerCollections.OrderedSet`1.Union*"></a>
  <h4 id="Wintellect_PowerCollections_OrderedSet_1_Union_Wintellect_PowerCollections_OrderedSet__0__" data-uid="Wintellect.PowerCollections.OrderedSet`1.Union(Wintellect.PowerCollections.OrderedSet{`0})">Union(OrderedSet&lt;T&gt;)</h4>
  <div class="markdown level1 summary"><p>Computes the union of this set with another set. The union of two sets
is all items that appear in either or both of the sets. A new set is
created with the union of the sets and is returned. This set and the other set
are unchanged.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public OrderedSet&lt;T&gt; Union(OrderedSet&lt;T&gt; otherSet)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Wintellect.PowerCollections.OrderedSet-1.html">OrderedSet</a>&lt;T&gt;</td>
        <td><span class="parametername">otherSet</span></td>
        <td><p>Set to union with.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Wintellect.PowerCollections.OrderedSet-1.html">OrderedSet</a>&lt;T&gt;</td>
        <td><p>The union of the two sets.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="Wintellect_PowerCollections_OrderedSet_1_Union_Wintellect_PowerCollections_OrderedSet__0___remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>If equal items appear in both sets, the union will include an arbitrary choice of one of the
two equal items.</p>
<p>The union of two sets is computed in time O(M + N log M), where M is the size of the 
larger set, and N is the size of the smaller set.</p>
</div>
  <h5 class="exceptions">Exceptions</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Condition</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.InvalidOperationException</span></td>
        <td><p>This set and <code data-dev-comment-type="paramref" class="paramref">otherSet</code> don't use the same method for comparing items.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Wintellect_PowerCollections_OrderedSet_1_Union_" data-uid="Wintellect.PowerCollections.OrderedSet`1.Union*"></a>
  <h4 id="Wintellect_PowerCollections_OrderedSet_1_Union_Wintellect_PowerCollections_OrderedSet__0__" data-uid="Wintellect.PowerCollections.OrderedSet`1.Union(Wintellect.PowerCollections.OrderedSet{`0})">Union(OrderedSet&lt;T&gt;)</h4>
  <div class="markdown level1 summary"><p>Computes the union of this set with another set. The union of two sets
is all items that appear in either or both of the sets. A new set is
created with the union of the sets and is returned. This set and the other set
are unchanged.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public OrderedSet&lt;T&gt; Union(OrderedSet&lt;T&gt; otherSet)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Wintellect.PowerCollections.OrderedSet-1.html">OrderedSet</a>&lt;T&gt;</td>
        <td><span class="parametername">otherSet</span></td>
        <td><p>Set to union with.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Wintellect.PowerCollections.OrderedSet-1.html">OrderedSet</a>&lt;T&gt;</td>
        <td><p>The union of the two sets.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="Wintellect_PowerCollections_OrderedSet_1_Union_Wintellect_PowerCollections_OrderedSet__0___remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>If equal items appear in both sets, the union will include an arbitrary choice of one of the
two equal items.</p>
<p>The union of two sets is computed in time O(M + N log M), where M is the size of the 
larger set, and N is the size of the smaller set.</p>
</div>
  <h5 class="exceptions">Exceptions</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Condition</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.InvalidOperationException</span></td>
        <td><p>This set and <code data-dev-comment-type="paramref" class="paramref">otherSet</code> don't use the same method for comparing items.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Wintellect_PowerCollections_OrderedSet_1_UnionWith_" data-uid="Wintellect.PowerCollections.OrderedSet`1.UnionWith*"></a>
  <h4 id="Wintellect_PowerCollections_OrderedSet_1_UnionWith_Wintellect_PowerCollections_OrderedSet__0__" data-uid="Wintellect.PowerCollections.OrderedSet`1.UnionWith(Wintellect.PowerCollections.OrderedSet{`0})">UnionWith(OrderedSet&lt;T&gt;)</h4>
  <div class="markdown level1 summary"><p>Computes the union of this set with another set. The union of two sets
is all items that appear in either or both of the sets. This set receives
the union of the two sets, the other set is unchanged.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public void UnionWith(OrderedSet&lt;T&gt; otherSet)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Wintellect.PowerCollections.OrderedSet-1.html">OrderedSet</a>&lt;T&gt;</td>
        <td><span class="parametername">otherSet</span></td>
        <td><p>Set to union with.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="Wintellect_PowerCollections_OrderedSet_1_UnionWith_Wintellect_PowerCollections_OrderedSet__0___remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>If equal items appear in both sets, the union will include an arbitrary choice of one of the
two equal items.</p>
<p>The union of two sets is computed in time O(M + N log M), where M is the size of the 
larger set, and N is the size of the smaller set.</p>
</div>
  <h5 class="exceptions">Exceptions</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Condition</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.InvalidOperationException</span></td>
        <td><p>This set and <code data-dev-comment-type="paramref" class="paramref">otherSet</code> don't use the same method for comparing items.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Wintellect_PowerCollections_OrderedSet_1_UnionWith_" data-uid="Wintellect.PowerCollections.OrderedSet`1.UnionWith*"></a>
  <h4 id="Wintellect_PowerCollections_OrderedSet_1_UnionWith_Wintellect_PowerCollections_OrderedSet__0__" data-uid="Wintellect.PowerCollections.OrderedSet`1.UnionWith(Wintellect.PowerCollections.OrderedSet{`0})">UnionWith(OrderedSet&lt;T&gt;)</h4>
  <div class="markdown level1 summary"><p>Computes the union of this set with another set. The union of two sets
is all items that appear in either or both of the sets. This set receives
the union of the two sets, the other set is unchanged.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public void UnionWith(OrderedSet&lt;T&gt; otherSet)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Wintellect.PowerCollections.OrderedSet-1.html">OrderedSet</a>&lt;T&gt;</td>
        <td><span class="parametername">otherSet</span></td>
        <td><p>Set to union with.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="Wintellect_PowerCollections_OrderedSet_1_UnionWith_Wintellect_PowerCollections_OrderedSet__0___remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>If equal items appear in both sets, the union will include an arbitrary choice of one of the
two equal items.</p>
<p>The union of two sets is computed in time O(M + N log M), where M is the size of the 
larger set, and N is the size of the smaller set.</p>
</div>
  <h5 class="exceptions">Exceptions</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Condition</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.InvalidOperationException</span></td>
        <td><p>This set and <code data-dev-comment-type="paramref" class="paramref">otherSet</code> don't use the same method for comparing items.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h3 id="eii">Explicit Interface Implementations
  </h3>
  
  
  <a id="Wintellect_PowerCollections_OrderedSet_1_System_Collections_Generic_ICollection_T__Add_" data-uid="Wintellect.PowerCollections.OrderedSet`1.System#Collections#Generic#ICollection{T}#Add*"></a>
  <h4 id="Wintellect_PowerCollections_OrderedSet_1_System_Collections_Generic_ICollection_T__Add__0_" data-uid="Wintellect.PowerCollections.OrderedSet`1.System#Collections#Generic#ICollection{T}#Add(`0)">ICollection&lt;T&gt;.Add(T)</h4>
  <div class="markdown level1 summary"><p>Adds a new item to the set. If the set already contains an item equal to
<code data-dev-comment-type="paramref" class="paramref">item</code>, that item is replaces with <code data-dev-comment-type="paramref" class="paramref">item</code>.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">void ICollection&lt;T&gt;.Add(T item)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">T</span></td>
        <td><span class="parametername">item</span></td>
        <td><p>The item to add to the set.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="Wintellect_PowerCollections_OrderedSet_1_System_Collections_Generic_ICollection_T__Add__0__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>Equality between items is determined by the comparison instance or delegate used
to create the set.</p>
<p>Adding an item takes time O(log N), where N is the number of items in the set.</p>
</div>
  
  
  <a id="Wintellect_PowerCollections_OrderedSet_1_System_Collections_Generic_ICollection_T__Add_" data-uid="Wintellect.PowerCollections.OrderedSet`1.System#Collections#Generic#ICollection{T}#Add*"></a>
  <h4 id="Wintellect_PowerCollections_OrderedSet_1_System_Collections_Generic_ICollection_T__Add__0_" data-uid="Wintellect.PowerCollections.OrderedSet`1.System#Collections#Generic#ICollection{T}#Add(`0)">ICollection&lt;T&gt;.Add(T)</h4>
  <div class="markdown level1 summary"><p>Adds a new item to the set. If the set already contains an item equal to
<code data-dev-comment-type="paramref" class="paramref">item</code>, that item is replaces with <code data-dev-comment-type="paramref" class="paramref">item</code>.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">void ICollection&lt;T&gt;.Add(T item)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">T</span></td>
        <td><span class="parametername">item</span></td>
        <td><p>The item to add to the set.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="Wintellect_PowerCollections_OrderedSet_1_System_Collections_Generic_ICollection_T__Add__0__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>Equality between items is determined by the comparison instance or delegate used
to create the set.</p>
<p>Adding an item takes time O(log N), where N is the number of items in the set.</p>
</div>
  
  
  <a id="Wintellect_PowerCollections_OrderedSet_1_System_ICloneable_Clone_" data-uid="Wintellect.PowerCollections.OrderedSet`1.System#ICloneable#Clone*"></a>
  <h4 id="Wintellect_PowerCollections_OrderedSet_1_System_ICloneable_Clone" data-uid="Wintellect.PowerCollections.OrderedSet`1.System#ICloneable#Clone">ICloneable.Clone()</h4>
  <div class="markdown level1 summary"><p>Makes a shallow clone of this set; i.e., if items of the
set are reference types, then they are not cloned. If T is a value type,
then each element is copied as if by simple assignment.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">object ICloneable.Clone()</code></pre>
  </div>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Object</span></td>
        <td><p>The cloned set.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="Wintellect_PowerCollections_OrderedSet_1_System_ICloneable_Clone_remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>Cloning the set takes time O(N), where N is the number of items in the set.</p>
</div>
  
  
  <a id="Wintellect_PowerCollections_OrderedSet_1_System_ICloneable_Clone_" data-uid="Wintellect.PowerCollections.OrderedSet`1.System#ICloneable#Clone*"></a>
  <h4 id="Wintellect_PowerCollections_OrderedSet_1_System_ICloneable_Clone" data-uid="Wintellect.PowerCollections.OrderedSet`1.System#ICloneable#Clone">ICloneable.Clone()</h4>
  <div class="markdown level1 summary"><p>Makes a shallow clone of this set; i.e., if items of the
set are reference types, then they are not cloned. If T is a value type,
then each element is copied as if by simple assignment.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">object ICloneable.Clone()</code></pre>
  </div>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Object</span></td>
        <td><p>The cloned set.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="Wintellect_PowerCollections_OrderedSet_1_System_ICloneable_Clone_remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>Cloning the set takes time O(N), where N is the number of items in the set.</p>
</div>
  <h3 id="implements">Implements</h3>
  <div>
      <span class="xref">System.Collections.ICollection</span>
  </div>
  <div>
      <span class="xref">System.Collections.Generic.ICollection&lt;T&gt;</span>
  </div>
  <div>
      <span class="xref">System.Collections.Generic.IEnumerable&lt;T&gt;</span>
  </div>
  <div>
      <span class="xref">System.Collections.IEnumerable</span>
  </div>
  <div>
      <span class="xref">System.ICloneable</span>
  </div>
  <h3 id="seealso">See Also</h3>
  <div class="seealso">
      <div><a class="xref" href="Wintellect.PowerCollections.Set-1.html">Set</a>&lt;T&gt;</div>
      <div><a class="xref" href="Wintellect.PowerCollections.Set-1.html">Set</a>&lt;T&gt;</div>
  </div>
</article>
          </div>
          
          <div class="hidden-sm col-md-2" role="complementary">
            <div class="sideaffix">
              <div class="contribution">
                <ul class="nav">
                </ul>
              </div>
              <nav class="bs-docs-sidebar hidden-print hidden-xs hidden-sm affix" id="affix">
                <h5>In This Article</h5>
                <div></div>
              </nav>
            </div>
          </div>
        </div>
      </div>
      
      <footer>
        <div class="grad-bottom"></div>
        <div class="footer">
          <div class="container">
            <span class="pull-right">
              <a href="#top">Back to top</a>
            </span>
            
            <span>Generated by <strong>DocFX</strong></span>
          </div>
        </div>
      </footer>
    </div>
    
    <script type="text/javascript" src="../styles/docfx.vendor.js"></script>
    <script type="text/javascript" src="../styles/docfx.js"></script>
    <script type="text/javascript" src="../styles/main.js"></script>
  </body>
</html>
