<!DOCTYPE html>
<!--[if IE]><![endif]-->
<html>
  
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>Class OrderedDictionary&lt;TKey, TValue&gt;
   </title>
    <meta name="viewport" content="width=device-width">
    <meta name="title" content="Class OrderedDictionary&lt;TKey, TValue&gt;
   ">
    <meta name="generator" content="docfx 2.59.4.0">
    
    <link rel="shortcut icon" href="../favicon.ico">
    <link rel="stylesheet" href="../styles/docfx.vendor.css">
    <link rel="stylesheet" href="../styles/docfx.css">
    <link rel="stylesheet" href="../styles/main.css">
    <meta property="docfx:navrel" content="../toc">
    <meta property="docfx:tocrel" content="toc">
    
    
    
  </head>
  <body data-spy="scroll" data-target="#affix" data-offset="120">
    <div id="wrapper">
      <header>
        
        <nav id="autocollapse" class="navbar navbar-inverse ng-scope" role="navigation">
          <div class="container">
            <div class="navbar-header">
              <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#navbar">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
              </button>
              
              <a class="navbar-brand" href="../index.html">
                <img id="logo" class="svg" src="../logo.svg" alt="">
              </a>
            </div>
            <div class="collapse navbar-collapse" id="navbar">
              <form class="navbar-form navbar-right" role="search" id="search">
                <div class="form-group">
                  <input type="text" class="form-control" id="search-query" placeholder="Search" autocomplete="off">
                </div>
              </form>
                
                <ul class="nav level1 navbar-nav">
                      <li>
                          <a href=".././api/Wintellect.PowerCollections.html" title="Wintellect">Wintellect</a>
                      </li>
                </ul>    </div>
          </div>
        </nav>
        
        <div class="subnav navbar navbar-default">
          <div class="container hide-when-search" id="breadcrumb">
            <ul class="breadcrumb">
              <li></li>
            </ul>
          </div>
        </div>
      </header>
      <div role="main" class="container body-content hide-when-search">
        <div class="sidenav hide-when-search">
          <a class="btn toc-toggle collapse" data-toggle="collapse" href="#sidetoggle" aria-expanded="false" aria-controls="sidetoggle">Show / Hide Table of Contents</a>
          <div class="sidetoggle collapse" id="sidetoggle">
            <div>
              <div class="sidefilter">
                <form class="toc-filter">
                  <span class="glyphicon glyphicon-filter filter-icon"></span>
                  <input type="text" id="toc_filter_input" placeholder="Enter here to filter..." onkeypress="if(event.keyCode==13) {return false;}">
                </form>
              </div>
              <div class="sidetoc">
                <div class="toc" id="toc">
                  
                  <ul class="nav level1">
                    <li class="">
                      <span class="expand-stub"></span>
                      <a href="Wintellect.PowerCollections.html" title="Wintellect.PowerCollections" class="">Wintellect.PowerCollections</a>
                        
                        <ul class="nav level2">
                          <li class="">
                            <a href="Wintellect.PowerCollections.Algorithms.html" title="Algorithms" class="">Algorithms</a>
                          </li>
                          <li class="">
                            <a href="Wintellect.PowerCollections.Bag-1.html" title="Bag&lt;T&gt;" class="">Bag&lt;T&gt;</a>
                          </li>
                          <li class="">
                            <a href="Wintellect.PowerCollections.BigList-1.html" title="BigList&lt;T&gt;" class="">BigList&lt;T&gt;</a>
                          </li>
                          <li class="">
                            <a href="Wintellect.PowerCollections.BinaryPredicate-1.html" title="BinaryPredicate&lt;T&gt;" class="">BinaryPredicate&lt;T&gt;</a>
                          </li>
                          <li class="">
                            <a href="Wintellect.PowerCollections.BinaryPredicate-1.html" title="BinaryPredicate&lt;T&gt;" class="">BinaryPredicate&lt;T&gt;</a>
                          </li>
                          <li class="">
                            <a href="Wintellect.PowerCollections.CollectionBase-1.html" title="CollectionBase&lt;T&gt;" class="">CollectionBase&lt;T&gt;</a>
                          </li>
                          <li class="">
                            <a href="Wintellect.PowerCollections.Deque-1.html" title="Deque&lt;T&gt;" class="">Deque&lt;T&gt;</a>
                          </li>
                          <li class="">
                            <a href="Wintellect.PowerCollections.DictionaryBase-2.html" title="DictionaryBase&lt;TKey, TValue&gt;" class="">DictionaryBase&lt;TKey, TValue&gt;</a>
                          </li>
                          <li class="">
                            <a href="Wintellect.PowerCollections.ListBase-1.html" title="ListBase&lt;T&gt;" class="">ListBase&lt;T&gt;</a>
                          </li>
                          <li class="">
                            <a href="Wintellect.PowerCollections.MultiDictionary-2.html" title="MultiDictionary&lt;TKey, TValue&gt;" class="">MultiDictionary&lt;TKey, TValue&gt;</a>
                          </li>
                          <li class="">
                            <a href="Wintellect.PowerCollections.MultiDictionaryBase-2.html" title="MultiDictionaryBase&lt;TKey, TValue&gt;" class="">MultiDictionaryBase&lt;TKey, TValue&gt;</a>
                          </li>
                          <li class="">
                            <a href="Wintellect.PowerCollections.OrderedBag-1.html" title="OrderedBag&lt;T&gt;" class="">OrderedBag&lt;T&gt;</a>
                          </li>
                          <li class="">
                            <a href="Wintellect.PowerCollections.OrderedBag-1.View.html" title="OrderedBag&lt;T&gt;.View" class="">OrderedBag&lt;T&gt;.View</a>
                          </li>
                          <li class="active">
                            <a href="Wintellect.PowerCollections.OrderedDictionary-2.html" title="OrderedDictionary&lt;TKey, TValue&gt;" class="active">OrderedDictionary&lt;TKey, TValue&gt;</a>
                          </li>
                          <li class="">
                            <a href="Wintellect.PowerCollections.OrderedDictionary-2.View.html" title="OrderedDictionary&lt;TKey, TValue&gt;.View" class="">OrderedDictionary&lt;TKey, TValue&gt;.View</a>
                          </li>
                          <li class="">
                            <a href="Wintellect.PowerCollections.OrderedMultiDictionary-2.html" title="OrderedMultiDictionary&lt;TKey, TValue&gt;" class="">OrderedMultiDictionary&lt;TKey, TValue&gt;</a>
                          </li>
                          <li class="">
                            <a href="Wintellect.PowerCollections.OrderedMultiDictionary-2.View.html" title="OrderedMultiDictionary&lt;TKey, TValue&gt;.View" class="">OrderedMultiDictionary&lt;TKey, TValue&gt;.View</a>
                          </li>
                          <li class="">
                            <a href="Wintellect.PowerCollections.OrderedSet-1.html" title="OrderedSet&lt;T&gt;" class="">OrderedSet&lt;T&gt;</a>
                          </li>
                          <li class="">
                            <a href="Wintellect.PowerCollections.OrderedSet-1.View.html" title="OrderedSet&lt;T&gt;.View" class="">OrderedSet&lt;T&gt;.View</a>
                          </li>
                          <li class="">
                            <a href="Wintellect.PowerCollections.Pair-2.html" title="Pair&lt;TFirst, TSecond&gt;" class="">Pair&lt;TFirst, TSecond&gt;</a>
                          </li>
                          <li class="">
                            <a href="Wintellect.PowerCollections.ReadOnlyCollectionBase-1.html" title="ReadOnlyCollectionBase&lt;T&gt;" class="">ReadOnlyCollectionBase&lt;T&gt;</a>
                          </li>
                          <li class="">
                            <a href="Wintellect.PowerCollections.ReadOnlyDictionaryBase-2.html" title="ReadOnlyDictionaryBase&lt;TKey, TValue&gt;" class="">ReadOnlyDictionaryBase&lt;TKey, TValue&gt;</a>
                          </li>
                          <li class="">
                            <a href="Wintellect.PowerCollections.ReadOnlyListBase-1.html" title="ReadOnlyListBase&lt;T&gt;" class="">ReadOnlyListBase&lt;T&gt;</a>
                          </li>
                          <li class="">
                            <a href="Wintellect.PowerCollections.ReadOnlyMultiDictionaryBase-2.html" title="ReadOnlyMultiDictionaryBase&lt;TKey, TValue&gt;" class="">ReadOnlyMultiDictionaryBase&lt;TKey, TValue&gt;</a>
                          </li>
                          <li class="">
                            <a href="Wintellect.PowerCollections.Set-1.html" title="Set&lt;T&gt;" class="">Set&lt;T&gt;</a>
                          </li>
                          <li class="">
                            <a href="Wintellect.PowerCollections.Stack-1.html" title="Stack&lt;T&gt;" class="">Stack&lt;T&gt;</a>
                          </li>
                          <li class="">
                            <a href="Wintellect.PowerCollections.Triple-3.html" title="Triple&lt;TFirst, TSecond, TThird&gt;" class="">Triple&lt;TFirst, TSecond, TThird&gt;</a>
                          </li>
                        </ul>  </li>
                  </ul>        </div>
              </div>
            </div>
          </div>
        </div>
        <div class="article row grid-right">
          <div class="col-md-10">
            <article class="content wrap" id="_content" data-uid="Wintellect.PowerCollections.OrderedDictionary`2">
  
  
  <h1 id="Wintellect_PowerCollections_OrderedDictionary_2" data-uid="Wintellect.PowerCollections.OrderedDictionary`2" class="text-break">Class OrderedDictionary&lt;TKey, TValue&gt;
  </h1>
  <div class="markdown level0 summary"><p>OrderedDictionary&lt;TKey, TValue&gt; is a collection that maps keys of type TKey
to values of type TValue. The keys are maintained in a sorted order, and at most one value
is permitted for each key.</p>
</div>
  <div class="markdown level0 conceptual"></div>
  <div class="inheritance">
    <h5>Inheritance</h5>
    <div class="level0"><span class="xref">System.Object</span></div>
    <div class="level1"><a class="xref" href="Wintellect.PowerCollections.CollectionBase-1.html">CollectionBase</a>&lt;<span class="xref">System.Collections.Generic.KeyValuePair</span>&lt;TKey, TValue&gt;&gt;</div>
    <div class="level2"><a class="xref" href="Wintellect.PowerCollections.DictionaryBase-2.html">DictionaryBase</a>&lt;TKey, TValue&gt;</div>
    <div class="level3"><span class="xref">OrderedDictionary&lt;TKey, TValue&gt;</span></div>
  </div>
  <div class="implements">
    <h5>Implements</h5>
    <div><span class="xref">System.Collections.Generic.IDictionary</span>&lt;TKey, TValue&gt;</div>
    <div><span class="xref">System.Collections.Generic.ICollection</span>&lt;<span class="xref">System.Collections.Generic.KeyValuePair</span>&lt;TKey, TValue&gt;&gt;</div>
    <div><span class="xref">System.Collections.Generic.IEnumerable</span>&lt;<span class="xref">System.Collections.Generic.KeyValuePair</span>&lt;TKey, TValue&gt;&gt;</div>
    <div><span class="xref">System.Collections.IDictionary</span></div>
    <div><span class="xref">System.Collections.ICollection</span></div>
    <div><span class="xref">System.Collections.IEnumerable</span></div>
    <div><span class="xref">System.ICloneable</span></div>
  </div>
  <div class="inheritedMembers">
    <h5>Inherited Members</h5>
    <div>
      <a class="xref" href="Wintellect.PowerCollections.DictionaryBase-2.html#Wintellect_PowerCollections_DictionaryBase_2_Clear">DictionaryBase&lt;TKey, TValue&gt;.Clear()</a>
    </div>
    <div>
      <a class="xref" href="Wintellect.PowerCollections.DictionaryBase-2.html#Wintellect_PowerCollections_DictionaryBase_2_Remove__0_">DictionaryBase&lt;TKey, TValue&gt;.Remove(TKey)</a>
    </div>
    <div>
      <a class="xref" href="Wintellect.PowerCollections.DictionaryBase-2.html#Wintellect_PowerCollections_DictionaryBase_2_TryGetValue__0__1__">DictionaryBase&lt;TKey, TValue&gt;.TryGetValue(TKey, TValue)</a>
    </div>
    <div>
      <a class="xref" href="Wintellect.PowerCollections.DictionaryBase-2.html#Wintellect_PowerCollections_DictionaryBase_2_Add__0__1_">DictionaryBase&lt;TKey, TValue&gt;.Add(TKey, TValue)</a>
    </div>
    <div>
      <a class="xref" href="Wintellect.PowerCollections.DictionaryBase-2.html#Wintellect_PowerCollections_DictionaryBase_2_ContainsKey__0_">DictionaryBase&lt;TKey, TValue&gt;.ContainsKey(TKey)</a>
    </div>
    <div>
      <a class="xref" href="Wintellect.PowerCollections.DictionaryBase-2.html#Wintellect_PowerCollections_DictionaryBase_2_Item__0_">DictionaryBase&lt;TKey, TValue&gt;.Item[TKey]</a>
    </div>
    <div>
      <a class="xref" href="Wintellect.PowerCollections.DictionaryBase-2.html#Wintellect_PowerCollections_DictionaryBase_2_ToString">DictionaryBase&lt;TKey, TValue&gt;.ToString()</a>
    </div>
    <div>
      <a class="xref" href="Wintellect.PowerCollections.DictionaryBase-2.html#Wintellect_PowerCollections_DictionaryBase_2_AsReadOnly">DictionaryBase&lt;TKey, TValue&gt;.AsReadOnly()</a>
    </div>
    <div>
      <a class="xref" href="Wintellect.PowerCollections.DictionaryBase-2.html#Wintellect_PowerCollections_DictionaryBase_2_Keys">DictionaryBase&lt;TKey, TValue&gt;.Keys</a>
    </div>
    <div>
      <a class="xref" href="Wintellect.PowerCollections.DictionaryBase-2.html#Wintellect_PowerCollections_DictionaryBase_2_Values">DictionaryBase&lt;TKey, TValue&gt;.Values</a>
    </div>
    <div>
      <a class="xref" href="Wintellect.PowerCollections.DictionaryBase-2.html#Wintellect_PowerCollections_DictionaryBase_2_Add_System_Collections_Generic_KeyValuePair__0__1__">DictionaryBase&lt;TKey, TValue&gt;.Add(KeyValuePair&lt;TKey, TValue&gt;)</a>
    </div>
    <div>
      <a class="xref" href="Wintellect.PowerCollections.DictionaryBase-2.html#Wintellect_PowerCollections_DictionaryBase_2_Contains_System_Collections_Generic_KeyValuePair__0__1__">DictionaryBase&lt;TKey, TValue&gt;.Contains(KeyValuePair&lt;TKey, TValue&gt;)</a>
    </div>
    <div>
      <a class="xref" href="Wintellect.PowerCollections.DictionaryBase-2.html#Wintellect_PowerCollections_DictionaryBase_2_Remove_System_Collections_Generic_KeyValuePair__0__1__">DictionaryBase&lt;TKey, TValue&gt;.Remove(KeyValuePair&lt;TKey, TValue&gt;)</a>
    </div>
    <div>
      <a class="xref" href="Wintellect.PowerCollections.DictionaryBase-2.html#Wintellect_PowerCollections_DictionaryBase_2_System_Collections_IDictionary_Add_System_Object_System_Object_">DictionaryBase&lt;TKey, TValue&gt;.IDictionary.Add(Object, Object)</a>
    </div>
    <div>
      <a class="xref" href="Wintellect.PowerCollections.DictionaryBase-2.html#Wintellect_PowerCollections_DictionaryBase_2_System_Collections_IDictionary_Clear">DictionaryBase&lt;TKey, TValue&gt;.IDictionary.Clear()</a>
    </div>
    <div>
      <a class="xref" href="Wintellect.PowerCollections.DictionaryBase-2.html#Wintellect_PowerCollections_DictionaryBase_2_System_Collections_IDictionary_Contains_System_Object_">DictionaryBase&lt;TKey, TValue&gt;.IDictionary.Contains(Object)</a>
    </div>
    <div>
      <a class="xref" href="Wintellect.PowerCollections.DictionaryBase-2.html#Wintellect_PowerCollections_DictionaryBase_2_System_Collections_IDictionary_Remove_System_Object_">DictionaryBase&lt;TKey, TValue&gt;.IDictionary.Remove(Object)</a>
    </div>
    <div>
      <a class="xref" href="Wintellect.PowerCollections.DictionaryBase-2.html#Wintellect_PowerCollections_DictionaryBase_2_System_Collections_IDictionary_GetEnumerator">DictionaryBase&lt;TKey, TValue&gt;.IDictionary.GetEnumerator()</a>
    </div>
    <div>
      <a class="xref" href="Wintellect.PowerCollections.DictionaryBase-2.html#Wintellect_PowerCollections_DictionaryBase_2_System_Collections_IEnumerable_GetEnumerator">DictionaryBase&lt;TKey, TValue&gt;.IEnumerable.GetEnumerator()</a>
    </div>
    <div>
      <a class="xref" href="Wintellect.PowerCollections.DictionaryBase-2.html#Wintellect_PowerCollections_DictionaryBase_2_System_Collections_IDictionary_IsFixedSize">DictionaryBase&lt;TKey, TValue&gt;.IDictionary.IsFixedSize</a>
    </div>
    <div>
      <a class="xref" href="Wintellect.PowerCollections.DictionaryBase-2.html#Wintellect_PowerCollections_DictionaryBase_2_System_Collections_IDictionary_IsReadOnly">DictionaryBase&lt;TKey, TValue&gt;.IDictionary.IsReadOnly</a>
    </div>
    <div>
      <a class="xref" href="Wintellect.PowerCollections.DictionaryBase-2.html#Wintellect_PowerCollections_DictionaryBase_2_System_Collections_IDictionary_Keys">DictionaryBase&lt;TKey, TValue&gt;.IDictionary.Keys</a>
    </div>
    <div>
      <a class="xref" href="Wintellect.PowerCollections.DictionaryBase-2.html#Wintellect_PowerCollections_DictionaryBase_2_System_Collections_IDictionary_Values">DictionaryBase&lt;TKey, TValue&gt;.IDictionary.Values</a>
    </div>
    <div>
      <a class="xref" href="Wintellect.PowerCollections.DictionaryBase-2.html#Wintellect_PowerCollections_DictionaryBase_2_System_Collections_IDictionary_Item_System_Object_">DictionaryBase&lt;TKey, TValue&gt;.IDictionary.Item[Object]</a>
    </div>
    <div>
      <a class="xref" href="Wintellect.PowerCollections.CollectionBase-1.html#Wintellect_PowerCollections_CollectionBase_1_ToString">CollectionBase&lt;KeyValuePair&lt;TKey, TValue&gt;&gt;.ToString()</a>
    </div>
    <div>
      <a class="xref" href="Wintellect.PowerCollections.CollectionBase-1.html#Wintellect_PowerCollections_CollectionBase_1_Add__0_">CollectionBase&lt;KeyValuePair&lt;TKey, TValue&gt;&gt;.Add(KeyValuePair&lt;TKey, TValue&gt;)</a>
    </div>
    <div>
      <a class="xref" href="Wintellect.PowerCollections.CollectionBase-1.html#Wintellect_PowerCollections_CollectionBase_1_Clear">CollectionBase&lt;KeyValuePair&lt;TKey, TValue&gt;&gt;.Clear()</a>
    </div>
    <div>
      <a class="xref" href="Wintellect.PowerCollections.CollectionBase-1.html#Wintellect_PowerCollections_CollectionBase_1_Remove__0_">CollectionBase&lt;KeyValuePair&lt;TKey, TValue&gt;&gt;.Remove(KeyValuePair&lt;TKey, TValue&gt;)</a>
    </div>
    <div>
      <a class="xref" href="Wintellect.PowerCollections.CollectionBase-1.html#Wintellect_PowerCollections_CollectionBase_1_Contains__0_">CollectionBase&lt;KeyValuePair&lt;TKey, TValue&gt;&gt;.Contains(KeyValuePair&lt;TKey, TValue&gt;)</a>
    </div>
    <div>
      <a class="xref" href="Wintellect.PowerCollections.CollectionBase-1.html#Wintellect_PowerCollections_CollectionBase_1_CopyTo__0___System_Int32_">CollectionBase&lt;KeyValuePair&lt;TKey, TValue&gt;&gt;.CopyTo(KeyValuePair&lt;TKey, TValue&gt;[], Int32)</a>
    </div>
    <div>
      <a class="xref" href="Wintellect.PowerCollections.CollectionBase-1.html#Wintellect_PowerCollections_CollectionBase_1_ToArray">CollectionBase&lt;KeyValuePair&lt;TKey, TValue&gt;&gt;.ToArray()</a>
    </div>
    <div>
      <a class="xref" href="Wintellect.PowerCollections.CollectionBase-1.html#Wintellect_PowerCollections_CollectionBase_1_Count">CollectionBase&lt;KeyValuePair&lt;TKey, TValue&gt;&gt;.Count</a>
    </div>
    <div>
      <a class="xref" href="Wintellect.PowerCollections.CollectionBase-1.html#Wintellect_PowerCollections_CollectionBase_1_System_Collections_Generic_ICollection_T__IsReadOnly">CollectionBase&lt;KeyValuePair&lt;TKey, TValue&gt;&gt;.ICollection&lt;KeyValuePair&lt;TKey, TValue&gt;&gt;.IsReadOnly</a>
    </div>
    <div>
      <a class="xref" href="Wintellect.PowerCollections.CollectionBase-1.html#Wintellect_PowerCollections_CollectionBase_1_AsReadOnly">CollectionBase&lt;KeyValuePair&lt;TKey, TValue&gt;&gt;.AsReadOnly()</a>
    </div>
    <div>
      <a class="xref" href="Wintellect.PowerCollections.CollectionBase-1.html#Wintellect_PowerCollections_CollectionBase_1_Exists_System_Predicate__0__">CollectionBase&lt;KeyValuePair&lt;TKey, TValue&gt;&gt;.Exists(Predicate&lt;KeyValuePair&lt;TKey, TValue&gt;&gt;)</a>
    </div>
    <div>
      <a class="xref" href="Wintellect.PowerCollections.CollectionBase-1.html#Wintellect_PowerCollections_CollectionBase_1_TrueForAll_System_Predicate__0__">CollectionBase&lt;KeyValuePair&lt;TKey, TValue&gt;&gt;.TrueForAll(Predicate&lt;KeyValuePair&lt;TKey, TValue&gt;&gt;)</a>
    </div>
    <div>
      <a class="xref" href="Wintellect.PowerCollections.CollectionBase-1.html#Wintellect_PowerCollections_CollectionBase_1_CountWhere_System_Predicate__0__">CollectionBase&lt;KeyValuePair&lt;TKey, TValue&gt;&gt;.CountWhere(Predicate&lt;KeyValuePair&lt;TKey, TValue&gt;&gt;)</a>
    </div>
    <div>
      <a class="xref" href="Wintellect.PowerCollections.CollectionBase-1.html#Wintellect_PowerCollections_CollectionBase_1_FindAll_System_Predicate__0__">CollectionBase&lt;KeyValuePair&lt;TKey, TValue&gt;&gt;.FindAll(Predicate&lt;KeyValuePair&lt;TKey, TValue&gt;&gt;)</a>
    </div>
    <div>
      <a class="xref" href="Wintellect.PowerCollections.CollectionBase-1.html#Wintellect_PowerCollections_CollectionBase_1_RemoveAll_System_Predicate__0__">CollectionBase&lt;KeyValuePair&lt;TKey, TValue&gt;&gt;.RemoveAll(Predicate&lt;KeyValuePair&lt;TKey, TValue&gt;&gt;)</a>
    </div>
    <div>
      <a class="xref" href="Wintellect.PowerCollections.CollectionBase-1.html#Wintellect_PowerCollections_CollectionBase_1_ForEach_System_Action__0__">CollectionBase&lt;KeyValuePair&lt;TKey, TValue&gt;&gt;.ForEach(Action&lt;KeyValuePair&lt;TKey, TValue&gt;&gt;)</a>
    </div>
    <div>
      <a class="xref" href="Wintellect.PowerCollections.CollectionBase-1.html#Wintellect_PowerCollections_CollectionBase_1_ConvertAll__1_System_Converter__0___0__">CollectionBase&lt;KeyValuePair&lt;TKey, TValue&gt;&gt;.ConvertAll&lt;TOutput&gt;(Converter&lt;KeyValuePair&lt;TKey, TValue&gt;, TOutput&gt;)</a>
    </div>
    <div>
      <a class="xref" href="Wintellect.PowerCollections.CollectionBase-1.html#Wintellect_PowerCollections_CollectionBase_1_GetEnumerator">CollectionBase&lt;KeyValuePair&lt;TKey, TValue&gt;&gt;.GetEnumerator()</a>
    </div>
    <div>
      <a class="xref" href="Wintellect.PowerCollections.CollectionBase-1.html#Wintellect_PowerCollections_CollectionBase_1_System_Collections_ICollection_CopyTo_System_Array_System_Int32_">CollectionBase&lt;KeyValuePair&lt;TKey, TValue&gt;&gt;.ICollection.CopyTo(Array, Int32)</a>
    </div>
    <div>
      <a class="xref" href="Wintellect.PowerCollections.CollectionBase-1.html#Wintellect_PowerCollections_CollectionBase_1_System_Collections_ICollection_IsSynchronized">CollectionBase&lt;KeyValuePair&lt;TKey, TValue&gt;&gt;.ICollection.IsSynchronized</a>
    </div>
    <div>
      <a class="xref" href="Wintellect.PowerCollections.CollectionBase-1.html#Wintellect_PowerCollections_CollectionBase_1_System_Collections_ICollection_SyncRoot">CollectionBase&lt;KeyValuePair&lt;TKey, TValue&gt;&gt;.ICollection.SyncRoot</a>
    </div>
    <div>
      <a class="xref" href="Wintellect.PowerCollections.CollectionBase-1.html#Wintellect_PowerCollections_CollectionBase_1_System_Collections_IEnumerable_GetEnumerator">CollectionBase&lt;KeyValuePair&lt;TKey, TValue&gt;&gt;.IEnumerable.GetEnumerator()</a>
    </div>
    <div>
      <span class="xref">System.Object.ToString()</span>
    </div>
    <div>
      <span class="xref">System.Object.Equals(System.Object)</span>
    </div>
    <div>
      <span class="xref">System.Object.Equals(System.Object, System.Object)</span>
    </div>
    <div>
      <span class="xref">System.Object.ReferenceEquals(System.Object, System.Object)</span>
    </div>
    <div>
      <span class="xref">System.Object.GetHashCode()</span>
    </div>
    <div>
      <span class="xref">System.Object.GetType()</span>
    </div>
    <div>
      <span class="xref">System.Object.MemberwiseClone()</span>
    </div>
  </div>
  <h6><strong>Namespace</strong>: <a class="xref" href="Wintellect.PowerCollections.html">Wintellect.PowerCollections</a></h6>
  <h6><strong>Assembly</strong>: cs.temp.dll.dll</h6>
  <h5 id="Wintellect_PowerCollections_OrderedDictionary_2_syntax">Syntax</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Serializable]
[Serializable]
public class OrderedDictionary&lt;TKey, TValue&gt; : DictionaryBase&lt;TKey, TValue&gt;, IDictionary&lt;TKey, TValue&gt;, ICollection&lt;KeyValuePair&lt;TKey, TValue&gt;&gt;, IEnumerable&lt;KeyValuePair&lt;TKey, TValue&gt;&gt;, IDictionary, ICollection, IEnumerable, ICloneable</code></pre>
  </div>
  <h5 class="typeParameters">Type Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="parametername">TKey</span></td>
        <td></td>
      </tr>
      <tr>
        <td><span class="parametername">TValue</span></td>
        <td></td>
      </tr>
    </tbody>
  </table>
  <h5 id="Wintellect_PowerCollections_OrderedDictionary_2_remarks"><strong>Remarks</strong></h5>
  <div class="markdown level0 remarks"><p>The keys are compared in one of three ways. If TKey implements IComparable&lt;TKey> or IComparable,
then the CompareTo method of that interface will be used to compare elements. Alternatively, a comparison
function can be passed in either as a delegate, or as an instance of IComparer&lt;TKey>.</p>
<p>OrderedDictionary is implemented as a balanced binary tree. Inserting, deleting, and looking up an
an element all are done in log(N) type, where N is the number of keys in the tree.</p>
<p><span class="xref">System.Collections.Generic.Dictionary`2</span> is similar, but uses hashing instead of comparison, and does not maintain
the keys in sorted order.</p>
</div>
  <h3 id="constructors">Constructors
  </h3>
  
  
  <a id="Wintellect_PowerCollections_OrderedDictionary_2__ctor_" data-uid="Wintellect.PowerCollections.OrderedDictionary`2.#ctor*"></a>
  <h4 id="Wintellect_PowerCollections_OrderedDictionary_2__ctor" data-uid="Wintellect.PowerCollections.OrderedDictionary`2.#ctor">OrderedDictionary()</h4>
  <div class="markdown level1 summary"><p>Creates a new OrderedDictionary. The TKey must implemented IComparable&lt;TKey&gt;
or IComparable.
The CompareTo method of this interface will be used to compare keys in this dictionary.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public OrderedDictionary()</code></pre>
  </div>
  <h5 class="exceptions">Exceptions</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Condition</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.InvalidOperationException</span></td>
        <td><p>TKey does not implement IComparable&lt;TKey&gt;.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Wintellect_PowerCollections_OrderedDictionary_2__ctor_" data-uid="Wintellect.PowerCollections.OrderedDictionary`2.#ctor*"></a>
  <h4 id="Wintellect_PowerCollections_OrderedDictionary_2__ctor" data-uid="Wintellect.PowerCollections.OrderedDictionary`2.#ctor">OrderedDictionary()</h4>
  <div class="markdown level1 summary"><p>Creates a new OrderedDictionary. The TKey must implemented IComparable&lt;TKey&gt;
or IComparable.
The CompareTo method of this interface will be used to compare keys in this dictionary.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public OrderedDictionary()</code></pre>
  </div>
  <h5 class="exceptions">Exceptions</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Condition</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.InvalidOperationException</span></td>
        <td><p>TKey does not implement IComparable&lt;TKey&gt;.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Wintellect_PowerCollections_OrderedDictionary_2__ctor_" data-uid="Wintellect.PowerCollections.OrderedDictionary`2.#ctor*"></a>
  <h4 id="Wintellect_PowerCollections_OrderedDictionary_2__ctor_System_Collections_Generic_IComparer__0__" data-uid="Wintellect.PowerCollections.OrderedDictionary`2.#ctor(System.Collections.Generic.IComparer{`0})">OrderedDictionary(IComparer&lt;TKey&gt;)</h4>
  <div class="markdown level1 summary"><p>Creates a new OrderedDictionary. The Compare method of the passed comparison object
will be used to compare keys in this dictionary.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public OrderedDictionary(IComparer&lt;TKey&gt; comparer)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Collections.Generic.IComparer</span>&lt;TKey&gt;</td>
        <td><span class="parametername">comparer</span></td>
        <td><p>An instance of IComparer&lt;TKey&gt; that will be used to compare keys.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="Wintellect_PowerCollections_OrderedDictionary_2__ctor_System_Collections_Generic_IComparer__0___remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>The GetHashCode and Equals methods of the provided IComparer&lt;TKey&gt; will never
be called, and need not be implemented.</p>
</div>
  
  
  <a id="Wintellect_PowerCollections_OrderedDictionary_2__ctor_" data-uid="Wintellect.PowerCollections.OrderedDictionary`2.#ctor*"></a>
  <h4 id="Wintellect_PowerCollections_OrderedDictionary_2__ctor_System_Collections_Generic_IComparer__0__" data-uid="Wintellect.PowerCollections.OrderedDictionary`2.#ctor(System.Collections.Generic.IComparer{`0})">OrderedDictionary(IComparer&lt;TKey&gt;)</h4>
  <div class="markdown level1 summary"><p>Creates a new OrderedDictionary. The Compare method of the passed comparison object
will be used to compare keys in this dictionary.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public OrderedDictionary(IComparer&lt;TKey&gt; comparer)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Collections.Generic.IComparer</span>&lt;TKey&gt;</td>
        <td><span class="parametername">comparer</span></td>
        <td><p>An instance of IComparer&lt;TKey&gt; that will be used to compare keys.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="Wintellect_PowerCollections_OrderedDictionary_2__ctor_System_Collections_Generic_IComparer__0___remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>The GetHashCode and Equals methods of the provided IComparer&lt;TKey&gt; will never
be called, and need not be implemented.</p>
</div>
  
  
  <a id="Wintellect_PowerCollections_OrderedDictionary_2__ctor_" data-uid="Wintellect.PowerCollections.OrderedDictionary`2.#ctor*"></a>
  <h4 id="Wintellect_PowerCollections_OrderedDictionary_2__ctor_System_Collections_Generic_IEnumerable_System_Collections_Generic_KeyValuePair__0__1___" data-uid="Wintellect.PowerCollections.OrderedDictionary`2.#ctor(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{`0,`1}})">OrderedDictionary(IEnumerable&lt;KeyValuePair&lt;TKey, TValue&gt;&gt;)</h4>
  <div class="markdown level1 summary"><p>Creates a new OrderedDictionary. The TKey must implemented IComparable&lt;TKey>
or IComparable. 
The CompareTo method of this interface will be used to compare keys in this dictionary.</p>
<p>A collection and keys and values (typically another dictionary) is used to initialized the 
contents of the dictionary.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public OrderedDictionary(IEnumerable&lt;KeyValuePair&lt;TKey, TValue&gt;&gt; keysAndValues)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Collections.Generic.IEnumerable</span>&lt;<span class="xref">System.Collections.Generic.KeyValuePair</span>&lt;TKey, TValue&gt;&gt;</td>
        <td><span class="parametername">keysAndValues</span></td>
        <td><p>A collection of keys and values whose contents are used to initialized the dictionary.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="exceptions">Exceptions</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Condition</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.InvalidOperationException</span></td>
        <td><p>TKey does not implement IComparable&lt;TKey&gt;.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Wintellect_PowerCollections_OrderedDictionary_2__ctor_" data-uid="Wintellect.PowerCollections.OrderedDictionary`2.#ctor*"></a>
  <h4 id="Wintellect_PowerCollections_OrderedDictionary_2__ctor_System_Collections_Generic_IEnumerable_System_Collections_Generic_KeyValuePair__0__1___" data-uid="Wintellect.PowerCollections.OrderedDictionary`2.#ctor(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{`0,`1}})">OrderedDictionary(IEnumerable&lt;KeyValuePair&lt;TKey, TValue&gt;&gt;)</h4>
  <div class="markdown level1 summary"><p>Creates a new OrderedDictionary. The TKey must implemented IComparable&lt;TKey>
or IComparable. 
The CompareTo method of this interface will be used to compare keys in this dictionary.</p>
<p>A collection and keys and values (typically another dictionary) is used to initialized the 
contents of the dictionary.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public OrderedDictionary(IEnumerable&lt;KeyValuePair&lt;TKey, TValue&gt;&gt; keysAndValues)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Collections.Generic.IEnumerable</span>&lt;<span class="xref">System.Collections.Generic.KeyValuePair</span>&lt;TKey, TValue&gt;&gt;</td>
        <td><span class="parametername">keysAndValues</span></td>
        <td><p>A collection of keys and values whose contents are used to initialized the dictionary.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="exceptions">Exceptions</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Condition</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.InvalidOperationException</span></td>
        <td><p>TKey does not implement IComparable&lt;TKey&gt;.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Wintellect_PowerCollections_OrderedDictionary_2__ctor_" data-uid="Wintellect.PowerCollections.OrderedDictionary`2.#ctor*"></a>
  <h4 id="Wintellect_PowerCollections_OrderedDictionary_2__ctor_System_Collections_Generic_IEnumerable_System_Collections_Generic_KeyValuePair__0__1___System_Collections_Generic_IComparer__0__" data-uid="Wintellect.PowerCollections.OrderedDictionary`2.#ctor(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{`0,`1}},System.Collections.Generic.IComparer{`0})">OrderedDictionary(IEnumerable&lt;KeyValuePair&lt;TKey, TValue&gt;&gt;, IComparer&lt;TKey&gt;)</h4>
  <div class="markdown level1 summary"><p>Creates a new OrderedDictionary. The Compare method of the passed comparison object
will be used to compare keys in this dictionary.</p>
<p>A collection and keys and values (typically another dictionary) is used to initialized the 
contents of the dictionary.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public OrderedDictionary(IEnumerable&lt;KeyValuePair&lt;TKey, TValue&gt;&gt; keysAndValues, IComparer&lt;TKey&gt; comparer)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Collections.Generic.IEnumerable</span>&lt;<span class="xref">System.Collections.Generic.KeyValuePair</span>&lt;TKey, TValue&gt;&gt;</td>
        <td><span class="parametername">keysAndValues</span></td>
        <td><p>A collection of keys and values whose contents are used to initialized the dictionary.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Collections.Generic.IComparer</span>&lt;TKey&gt;</td>
        <td><span class="parametername">comparer</span></td>
        <td><p>An instance of IComparer&lt;TKey&gt; that will be used to compare keys.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="Wintellect_PowerCollections_OrderedDictionary_2__ctor_System_Collections_Generic_IEnumerable_System_Collections_Generic_KeyValuePair__0__1___System_Collections_Generic_IComparer__0___remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>The GetHashCode and Equals methods of the provided IComparer&lt;TKey&gt; will never
be called, and need not be implemented.</p>
</div>
  
  
  <a id="Wintellect_PowerCollections_OrderedDictionary_2__ctor_" data-uid="Wintellect.PowerCollections.OrderedDictionary`2.#ctor*"></a>
  <h4 id="Wintellect_PowerCollections_OrderedDictionary_2__ctor_System_Collections_Generic_IEnumerable_System_Collections_Generic_KeyValuePair__0__1___System_Collections_Generic_IComparer__0__" data-uid="Wintellect.PowerCollections.OrderedDictionary`2.#ctor(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{`0,`1}},System.Collections.Generic.IComparer{`0})">OrderedDictionary(IEnumerable&lt;KeyValuePair&lt;TKey, TValue&gt;&gt;, IComparer&lt;TKey&gt;)</h4>
  <div class="markdown level1 summary"><p>Creates a new OrderedDictionary. The Compare method of the passed comparison object
will be used to compare keys in this dictionary.</p>
<p>A collection and keys and values (typically another dictionary) is used to initialized the 
contents of the dictionary.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public OrderedDictionary(IEnumerable&lt;KeyValuePair&lt;TKey, TValue&gt;&gt; keysAndValues, IComparer&lt;TKey&gt; comparer)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Collections.Generic.IEnumerable</span>&lt;<span class="xref">System.Collections.Generic.KeyValuePair</span>&lt;TKey, TValue&gt;&gt;</td>
        <td><span class="parametername">keysAndValues</span></td>
        <td><p>A collection of keys and values whose contents are used to initialized the dictionary.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Collections.Generic.IComparer</span>&lt;TKey&gt;</td>
        <td><span class="parametername">comparer</span></td>
        <td><p>An instance of IComparer&lt;TKey&gt; that will be used to compare keys.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="Wintellect_PowerCollections_OrderedDictionary_2__ctor_System_Collections_Generic_IEnumerable_System_Collections_Generic_KeyValuePair__0__1___System_Collections_Generic_IComparer__0___remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>The GetHashCode and Equals methods of the provided IComparer&lt;TKey&gt; will never
be called, and need not be implemented.</p>
</div>
  
  
  <a id="Wintellect_PowerCollections_OrderedDictionary_2__ctor_" data-uid="Wintellect.PowerCollections.OrderedDictionary`2.#ctor*"></a>
  <h4 id="Wintellect_PowerCollections_OrderedDictionary_2__ctor_System_Collections_Generic_IEnumerable_System_Collections_Generic_KeyValuePair__0__1___System_Comparison__0__" data-uid="Wintellect.PowerCollections.OrderedDictionary`2.#ctor(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{`0,`1}},System.Comparison{`0})">OrderedDictionary(IEnumerable&lt;KeyValuePair&lt;TKey, TValue&gt;&gt;, Comparison&lt;TKey&gt;)</h4>
  <div class="markdown level1 summary"><p>Creates a new OrderedDictionary. The passed delegate will be used to compare keys in this dictionary.</p>
<p>A collection and keys and values (typically another dictionary) is used to initialized the 
contents of the dictionary.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public OrderedDictionary(IEnumerable&lt;KeyValuePair&lt;TKey, TValue&gt;&gt; keysAndValues, Comparison&lt;TKey&gt; comparison)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Collections.Generic.IEnumerable</span>&lt;<span class="xref">System.Collections.Generic.KeyValuePair</span>&lt;TKey, TValue&gt;&gt;</td>
        <td><span class="parametername">keysAndValues</span></td>
        <td><p>A collection of keys and values whose contents are used to initialized the dictionary.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Comparison</span>&lt;TKey&gt;</td>
        <td><span class="parametername">comparison</span></td>
        <td><p>A delegate to a method that will be used to compare keys.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Wintellect_PowerCollections_OrderedDictionary_2__ctor_" data-uid="Wintellect.PowerCollections.OrderedDictionary`2.#ctor*"></a>
  <h4 id="Wintellect_PowerCollections_OrderedDictionary_2__ctor_System_Collections_Generic_IEnumerable_System_Collections_Generic_KeyValuePair__0__1___System_Comparison__0__" data-uid="Wintellect.PowerCollections.OrderedDictionary`2.#ctor(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{`0,`1}},System.Comparison{`0})">OrderedDictionary(IEnumerable&lt;KeyValuePair&lt;TKey, TValue&gt;&gt;, Comparison&lt;TKey&gt;)</h4>
  <div class="markdown level1 summary"><p>Creates a new OrderedDictionary. The passed delegate will be used to compare keys in this dictionary.</p>
<p>A collection and keys and values (typically another dictionary) is used to initialized the 
contents of the dictionary.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public OrderedDictionary(IEnumerable&lt;KeyValuePair&lt;TKey, TValue&gt;&gt; keysAndValues, Comparison&lt;TKey&gt; comparison)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Collections.Generic.IEnumerable</span>&lt;<span class="xref">System.Collections.Generic.KeyValuePair</span>&lt;TKey, TValue&gt;&gt;</td>
        <td><span class="parametername">keysAndValues</span></td>
        <td><p>A collection of keys and values whose contents are used to initialized the dictionary.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Comparison</span>&lt;TKey&gt;</td>
        <td><span class="parametername">comparison</span></td>
        <td><p>A delegate to a method that will be used to compare keys.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Wintellect_PowerCollections_OrderedDictionary_2__ctor_" data-uid="Wintellect.PowerCollections.OrderedDictionary`2.#ctor*"></a>
  <h4 id="Wintellect_PowerCollections_OrderedDictionary_2__ctor_System_Comparison__0__" data-uid="Wintellect.PowerCollections.OrderedDictionary`2.#ctor(System.Comparison{`0})">OrderedDictionary(Comparison&lt;TKey&gt;)</h4>
  <div class="markdown level1 summary"><p>Creates a new OrderedDictionary. The passed delegate will be used to compare keys in this dictionary.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public OrderedDictionary(Comparison&lt;TKey&gt; comparison)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Comparison</span>&lt;TKey&gt;</td>
        <td><span class="parametername">comparison</span></td>
        <td><p>A delegate to a method that will be used to compare keys.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Wintellect_PowerCollections_OrderedDictionary_2__ctor_" data-uid="Wintellect.PowerCollections.OrderedDictionary`2.#ctor*"></a>
  <h4 id="Wintellect_PowerCollections_OrderedDictionary_2__ctor_System_Comparison__0__" data-uid="Wintellect.PowerCollections.OrderedDictionary`2.#ctor(System.Comparison{`0})">OrderedDictionary(Comparison&lt;TKey&gt;)</h4>
  <div class="markdown level1 summary"><p>Creates a new OrderedDictionary. The passed delegate will be used to compare keys in this dictionary.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public OrderedDictionary(Comparison&lt;TKey&gt; comparison)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Comparison</span>&lt;TKey&gt;</td>
        <td><span class="parametername">comparison</span></td>
        <td><p>A delegate to a method that will be used to compare keys.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h3 id="properties">Properties
  </h3>
  
  
  <a id="Wintellect_PowerCollections_OrderedDictionary_2_Comparer_" data-uid="Wintellect.PowerCollections.OrderedDictionary`2.Comparer*"></a>
  <h4 id="Wintellect_PowerCollections_OrderedDictionary_2_Comparer" data-uid="Wintellect.PowerCollections.OrderedDictionary`2.Comparer">Comparer</h4>
  <div class="markdown level1 summary"><p>Returns the IComparer&lt;T&gt; used to compare keys in this dictionary.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public IComparer&lt;TKey&gt; Comparer { get; }</code></pre>
  </div>
  <h5 class="propertyValue">Property Value</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Collections.Generic.IComparer</span>&lt;TKey&gt;</td>
        <td><p>If the dictionary was created using a comparer, that comparer is returned. If the dictionary was
created using a comparison delegate, then a comparer equivalent to that delegate
is returned. Otherwise
the default comparer for TKey (Comparer&lt;TKey&gt;.Default) is returned.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Wintellect_PowerCollections_OrderedDictionary_2_Comparer_" data-uid="Wintellect.PowerCollections.OrderedDictionary`2.Comparer*"></a>
  <h4 id="Wintellect_PowerCollections_OrderedDictionary_2_Comparer" data-uid="Wintellect.PowerCollections.OrderedDictionary`2.Comparer">Comparer</h4>
  <div class="markdown level1 summary"><p>Returns the IComparer&lt;T&gt; used to compare keys in this dictionary.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public IComparer&lt;TKey&gt; Comparer { get; }</code></pre>
  </div>
  <h5 class="propertyValue">Property Value</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Collections.Generic.IComparer</span>&lt;TKey&gt;</td>
        <td><p>If the dictionary was created using a comparer, that comparer is returned. If the dictionary was
created using a comparison delegate, then a comparer equivalent to that delegate
is returned. Otherwise
the default comparer for TKey (Comparer&lt;TKey&gt;.Default) is returned.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Wintellect_PowerCollections_OrderedDictionary_2_Count_" data-uid="Wintellect.PowerCollections.OrderedDictionary`2.Count*"></a>
  <h4 id="Wintellect_PowerCollections_OrderedDictionary_2_Count" data-uid="Wintellect.PowerCollections.OrderedDictionary`2.Count">Count</h4>
  <div class="markdown level1 summary"><p>Returns the number of keys in the dictionary.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public sealed override int Count { get; }</code></pre>
  </div>
  <h5 class="propertyValue">Property Value</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Int32</span></td>
        <td><p>The number of keys in the dictionary.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="overrides">Overrides</h5>
  <div><span class="xref">Wintellect.PowerCollections.CollectionBase&lt;System.Collections.Generic.KeyValuePair&lt;TKey, TValue&gt;&gt;.Count</span></div>
  <h5 id="Wintellect_PowerCollections_OrderedDictionary_2_Count_remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>The size of the dictionary is returned in constant time..</p>
</div>
  
  
  <a id="Wintellect_PowerCollections_OrderedDictionary_2_Count_" data-uid="Wintellect.PowerCollections.OrderedDictionary`2.Count*"></a>
  <h4 id="Wintellect_PowerCollections_OrderedDictionary_2_Count" data-uid="Wintellect.PowerCollections.OrderedDictionary`2.Count">Count</h4>
  <div class="markdown level1 summary"><p>Returns the number of keys in the dictionary.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public sealed override int Count { get; }</code></pre>
  </div>
  <h5 class="propertyValue">Property Value</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Int32</span></td>
        <td><p>The number of keys in the dictionary.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="overrides">Overrides</h5>
  <div><span class="xref">Wintellect.PowerCollections.CollectionBase&lt;System.Collections.Generic.KeyValuePair&lt;TKey, TValue&gt;&gt;.Count</span></div>
  <h5 id="Wintellect_PowerCollections_OrderedDictionary_2_Count_remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>The size of the dictionary is returned in constant time..</p>
</div>
  
  
  <a id="Wintellect_PowerCollections_OrderedDictionary_2_Item_" data-uid="Wintellect.PowerCollections.OrderedDictionary`2.Item*"></a>
  <h4 id="Wintellect_PowerCollections_OrderedDictionary_2_Item__0_" data-uid="Wintellect.PowerCollections.OrderedDictionary`2.Item(`0)">Item[TKey]</h4>
  <div class="markdown level1 summary"><p>Gets or sets the value associated with a given key. When getting a value, if this
key is not found in the collection, then an ArgumentException is thrown. When setting
a value, the value replaces any existing value in the dictionary.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public sealed override TValue this[TKey key] { get; set; }</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">TKey</span></td>
        <td><span class="parametername">key</span></td>
        <td></td>
      </tr>
    </tbody>
  </table>
  <h5 class="propertyValue">Property Value</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">TValue</span></td>
        <td><p>The value associated with the key</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="overrides">Overrides</h5>
  <div><span class="xref">Wintellect.PowerCollections.DictionaryBase&lt;TKey, TValue&gt;.Item[TKey]</span></div>
  <h5 id="Wintellect_PowerCollections_OrderedDictionary_2_Item__0__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>The indexer takes time O(log N), where N is the number of entries in the dictionary.</p>
</div>
  <h5 class="exceptions">Exceptions</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Condition</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.ArgumentException</span></td>
        <td><p>A value is being retrieved, and the key is not present in the dictionary.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.ArgumentNullException</span></td>
        <td><p><code data-dev-comment-type="paramref" class="paramref">key</code> is null.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Wintellect_PowerCollections_OrderedDictionary_2_Item_" data-uid="Wintellect.PowerCollections.OrderedDictionary`2.Item*"></a>
  <h4 id="Wintellect_PowerCollections_OrderedDictionary_2_Item__0_" data-uid="Wintellect.PowerCollections.OrderedDictionary`2.Item(`0)">Item[TKey]</h4>
  <div class="markdown level1 summary"><p>Gets or sets the value associated with a given key. When getting a value, if this
key is not found in the collection, then an ArgumentException is thrown. When setting
a value, the value replaces any existing value in the dictionary.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public sealed override TValue this[TKey key] { get; set; }</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">TKey</span></td>
        <td><span class="parametername">key</span></td>
        <td></td>
      </tr>
    </tbody>
  </table>
  <h5 class="propertyValue">Property Value</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">TValue</span></td>
        <td><p>The value associated with the key</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="overrides">Overrides</h5>
  <div><span class="xref">Wintellect.PowerCollections.DictionaryBase&lt;TKey, TValue&gt;.Item[TKey]</span></div>
  <h5 id="Wintellect_PowerCollections_OrderedDictionary_2_Item__0__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>The indexer takes time O(log N), where N is the number of entries in the dictionary.</p>
</div>
  <h5 class="exceptions">Exceptions</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Condition</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.ArgumentException</span></td>
        <td><p>A value is being retrieved, and the key is not present in the dictionary.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.ArgumentNullException</span></td>
        <td><p><code data-dev-comment-type="paramref" class="paramref">key</code> is null.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h3 id="methods">Methods
  </h3>
  
  
  <a id="Wintellect_PowerCollections_OrderedDictionary_2_Add_" data-uid="Wintellect.PowerCollections.OrderedDictionary`2.Add*"></a>
  <h4 id="Wintellect_PowerCollections_OrderedDictionary_2_Add__0__1_" data-uid="Wintellect.PowerCollections.OrderedDictionary`2.Add(`0,`1)">Add(TKey, TValue)</h4>
  <div class="markdown level1 summary"><p>Adds a new key and value to the dictionary. If the dictionary already contains
a key equal to the passed key, then an ArgumentException is thrown</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public sealed override void Add(TKey key, TValue value)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">TKey</span></td>
        <td><span class="parametername">key</span></td>
        <td><p>The new key. &quot;null&quot; is a valid key value.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">TValue</span></td>
        <td><span class="parametername">value</span></td>
        <td><p>The new value to associated with that key.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="overrides">Overrides</h5>
  <div><span class="xref">Wintellect.PowerCollections.DictionaryBase&lt;TKey, TValue&gt;.Add(TKey, TValue)</span></div>
  <h5 id="Wintellect_PowerCollections_OrderedDictionary_2_Add__0__1__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>Equality between keys is determined by the comparison instance or delegate used
to create the dictionary.</p>
<p>Adding an key and value takes time O(log N), where N is the number of keys in the dictionary.</p>
</div>
  <h5 class="exceptions">Exceptions</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Condition</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.ArgumentException</span></td>
        <td><p>key is already present in the dictionary</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Wintellect_PowerCollections_OrderedDictionary_2_Add_" data-uid="Wintellect.PowerCollections.OrderedDictionary`2.Add*"></a>
  <h4 id="Wintellect_PowerCollections_OrderedDictionary_2_Add__0__1_" data-uid="Wintellect.PowerCollections.OrderedDictionary`2.Add(`0,`1)">Add(TKey, TValue)</h4>
  <div class="markdown level1 summary"><p>Adds a new key and value to the dictionary. If the dictionary already contains
a key equal to the passed key, then an ArgumentException is thrown</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public sealed override void Add(TKey key, TValue value)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">TKey</span></td>
        <td><span class="parametername">key</span></td>
        <td><p>The new key. &quot;null&quot; is a valid key value.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">TValue</span></td>
        <td><span class="parametername">value</span></td>
        <td><p>The new value to associated with that key.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="overrides">Overrides</h5>
  <div><span class="xref">Wintellect.PowerCollections.DictionaryBase&lt;TKey, TValue&gt;.Add(TKey, TValue)</span></div>
  <h5 id="Wintellect_PowerCollections_OrderedDictionary_2_Add__0__1__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>Equality between keys is determined by the comparison instance or delegate used
to create the dictionary.</p>
<p>Adding an key and value takes time O(log N), where N is the number of keys in the dictionary.</p>
</div>
  <h5 class="exceptions">Exceptions</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Condition</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.ArgumentException</span></td>
        <td><p>key is already present in the dictionary</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Wintellect_PowerCollections_OrderedDictionary_2_AddMany_" data-uid="Wintellect.PowerCollections.OrderedDictionary`2.AddMany*"></a>
  <h4 id="Wintellect_PowerCollections_OrderedDictionary_2_AddMany_System_Collections_Generic_IEnumerable_System_Collections_Generic_KeyValuePair__0__1___" data-uid="Wintellect.PowerCollections.OrderedDictionary`2.AddMany(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{`0,`1}})">AddMany(IEnumerable&lt;KeyValuePair&lt;TKey, TValue&gt;&gt;)</h4>
  <div class="markdown level1 summary"><p>Adds multiple key-value pairs to a dictionary. If a key exists in both the current instance and dictionaryToAdd,
then the value is updated with the value from <code data-dev-comment-type="paramref" class="paramref">keysAndValues&gt;&gt;</code> (no exception is thrown).
Since IDictionary&lt;TKey,TValue&gt; inherits from IEnumerable&lt;KeyValuePair&lt;TKey,TValue&gt;&gt;, this
method can be used to merge one dictionary into another.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public void AddMany(IEnumerable&lt;KeyValuePair&lt;TKey, TValue&gt;&gt; keysAndValues)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Collections.Generic.IEnumerable</span>&lt;<span class="xref">System.Collections.Generic.KeyValuePair</span>&lt;TKey, TValue&gt;&gt;</td>
        <td><span class="parametername">keysAndValues</span></td>
        <td><p>A collection of keys and values whose contents are added to the current dictionary.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="Wintellect_PowerCollections_OrderedDictionary_2_AddMany_System_Collections_Generic_IEnumerable_System_Collections_Generic_KeyValuePair__0__1____remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>AddMany takes time O(M log (N+M)), where M is the size of <code data-dev-comment-type="paramref" class="paramref">keysAndValues&gt;&gt;</code>, and N is the size of
this dictionary.</p>
</div>
  
  
  <a id="Wintellect_PowerCollections_OrderedDictionary_2_AddMany_" data-uid="Wintellect.PowerCollections.OrderedDictionary`2.AddMany*"></a>
  <h4 id="Wintellect_PowerCollections_OrderedDictionary_2_AddMany_System_Collections_Generic_IEnumerable_System_Collections_Generic_KeyValuePair__0__1___" data-uid="Wintellect.PowerCollections.OrderedDictionary`2.AddMany(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{`0,`1}})">AddMany(IEnumerable&lt;KeyValuePair&lt;TKey, TValue&gt;&gt;)</h4>
  <div class="markdown level1 summary"><p>Adds multiple key-value pairs to a dictionary. If a key exists in both the current instance and dictionaryToAdd,
then the value is updated with the value from <code data-dev-comment-type="paramref" class="paramref">keysAndValues&gt;&gt;</code> (no exception is thrown).
Since IDictionary&lt;TKey,TValue&gt; inherits from IEnumerable&lt;KeyValuePair&lt;TKey,TValue&gt;&gt;, this
method can be used to merge one dictionary into another.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public void AddMany(IEnumerable&lt;KeyValuePair&lt;TKey, TValue&gt;&gt; keysAndValues)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Collections.Generic.IEnumerable</span>&lt;<span class="xref">System.Collections.Generic.KeyValuePair</span>&lt;TKey, TValue&gt;&gt;</td>
        <td><span class="parametername">keysAndValues</span></td>
        <td><p>A collection of keys and values whose contents are added to the current dictionary.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="Wintellect_PowerCollections_OrderedDictionary_2_AddMany_System_Collections_Generic_IEnumerable_System_Collections_Generic_KeyValuePair__0__1____remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>AddMany takes time O(M log (N+M)), where M is the size of <code data-dev-comment-type="paramref" class="paramref">keysAndValues&gt;&gt;</code>, and N is the size of
this dictionary.</p>
</div>
  
  
  <a id="Wintellect_PowerCollections_OrderedDictionary_2_Clear_" data-uid="Wintellect.PowerCollections.OrderedDictionary`2.Clear*"></a>
  <h4 id="Wintellect_PowerCollections_OrderedDictionary_2_Clear" data-uid="Wintellect.PowerCollections.OrderedDictionary`2.Clear">Clear()</h4>
  <div class="markdown level1 summary"><p>Removes all keys and values from the dictionary.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public sealed override void Clear()</code></pre>
  </div>
  <h5 class="overrides">Overrides</h5>
  <div><span class="xref">Wintellect.PowerCollections.DictionaryBase&lt;TKey, TValue&gt;.Clear()</span></div>
  <h5 id="Wintellect_PowerCollections_OrderedDictionary_2_Clear_remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>Clearing the dictionary takes a constant amount of time, regardless of the number of keys in it.</p>
</div>
  
  
  <a id="Wintellect_PowerCollections_OrderedDictionary_2_Clear_" data-uid="Wintellect.PowerCollections.OrderedDictionary`2.Clear*"></a>
  <h4 id="Wintellect_PowerCollections_OrderedDictionary_2_Clear" data-uid="Wintellect.PowerCollections.OrderedDictionary`2.Clear">Clear()</h4>
  <div class="markdown level1 summary"><p>Removes all keys and values from the dictionary.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public sealed override void Clear()</code></pre>
  </div>
  <h5 class="overrides">Overrides</h5>
  <div><span class="xref">Wintellect.PowerCollections.DictionaryBase&lt;TKey, TValue&gt;.Clear()</span></div>
  <h5 id="Wintellect_PowerCollections_OrderedDictionary_2_Clear_remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>Clearing the dictionary takes a constant amount of time, regardless of the number of keys in it.</p>
</div>
  
  
  <a id="Wintellect_PowerCollections_OrderedDictionary_2_Clone_" data-uid="Wintellect.PowerCollections.OrderedDictionary`2.Clone*"></a>
  <h4 id="Wintellect_PowerCollections_OrderedDictionary_2_Clone" data-uid="Wintellect.PowerCollections.OrderedDictionary`2.Clone">Clone()</h4>
  <div class="markdown level1 summary"><p>Makes a shallow clone of this dictionary; i.e., if keys or values of the
dictionary are reference types, then they are not cloned. If TKey or TValue is a value type,
then each element is copied as if by simple assignment.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public OrderedDictionary&lt;TKey, TValue&gt; Clone()</code></pre>
  </div>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Wintellect.PowerCollections.OrderedDictionary-2.html">OrderedDictionary</a>&lt;TKey, TValue&gt;</td>
        <td><p>The cloned dictionary.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="Wintellect_PowerCollections_OrderedDictionary_2_Clone_remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>Cloning the dictionary takes time O(N), where N is the number of keys in the dictionary.</p>
</div>
  
  
  <a id="Wintellect_PowerCollections_OrderedDictionary_2_Clone_" data-uid="Wintellect.PowerCollections.OrderedDictionary`2.Clone*"></a>
  <h4 id="Wintellect_PowerCollections_OrderedDictionary_2_Clone" data-uid="Wintellect.PowerCollections.OrderedDictionary`2.Clone">Clone()</h4>
  <div class="markdown level1 summary"><p>Makes a shallow clone of this dictionary; i.e., if keys or values of the
dictionary are reference types, then they are not cloned. If TKey or TValue is a value type,
then each element is copied as if by simple assignment.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public OrderedDictionary&lt;TKey, TValue&gt; Clone()</code></pre>
  </div>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Wintellect.PowerCollections.OrderedDictionary-2.html">OrderedDictionary</a>&lt;TKey, TValue&gt;</td>
        <td><p>The cloned dictionary.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="Wintellect_PowerCollections_OrderedDictionary_2_Clone_remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>Cloning the dictionary takes time O(N), where N is the number of keys in the dictionary.</p>
</div>
  
  
  <a id="Wintellect_PowerCollections_OrderedDictionary_2_CloneContents_" data-uid="Wintellect.PowerCollections.OrderedDictionary`2.CloneContents*"></a>
  <h4 id="Wintellect_PowerCollections_OrderedDictionary_2_CloneContents" data-uid="Wintellect.PowerCollections.OrderedDictionary`2.CloneContents">CloneContents()</h4>
  <div class="markdown level1 summary"><p>Makes a deep clone of this dictionary. A new dictionary is created with a clone of
each entry of this dictionary, by calling ICloneable.Clone on each element. If TKey or TValue is
a value type, then each element is copied as if by simple assignment.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public OrderedDictionary&lt;TKey, TValue&gt; CloneContents()</code></pre>
  </div>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Wintellect.PowerCollections.OrderedDictionary-2.html">OrderedDictionary</a>&lt;TKey, TValue&gt;</td>
        <td><p>The cloned dictionary.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="Wintellect_PowerCollections_OrderedDictionary_2_CloneContents_remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>If TKey or TValue is a reference type, it must implement
    ICloneable. Otherwise, an InvalidOperationException is thrown.</p>
<p>Cloning the dictionary takes time O(N log N), where N is the number of keys in the dictionary.</p>
</div>
  <h5 class="exceptions">Exceptions</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Condition</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.InvalidOperationException</span></td>
        <td><p>TKey or TValue is a reference type that does not implement ICloneable.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Wintellect_PowerCollections_OrderedDictionary_2_CloneContents_" data-uid="Wintellect.PowerCollections.OrderedDictionary`2.CloneContents*"></a>
  <h4 id="Wintellect_PowerCollections_OrderedDictionary_2_CloneContents" data-uid="Wintellect.PowerCollections.OrderedDictionary`2.CloneContents">CloneContents()</h4>
  <div class="markdown level1 summary"><p>Makes a deep clone of this dictionary. A new dictionary is created with a clone of
each entry of this dictionary, by calling ICloneable.Clone on each element. If TKey or TValue is
a value type, then each element is copied as if by simple assignment.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public OrderedDictionary&lt;TKey, TValue&gt; CloneContents()</code></pre>
  </div>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Wintellect.PowerCollections.OrderedDictionary-2.html">OrderedDictionary</a>&lt;TKey, TValue&gt;</td>
        <td><p>The cloned dictionary.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="Wintellect_PowerCollections_OrderedDictionary_2_CloneContents_remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>If TKey or TValue is a reference type, it must implement
    ICloneable. Otherwise, an InvalidOperationException is thrown.</p>
<p>Cloning the dictionary takes time O(N log N), where N is the number of keys in the dictionary.</p>
</div>
  <h5 class="exceptions">Exceptions</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Condition</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.InvalidOperationException</span></td>
        <td><p>TKey or TValue is a reference type that does not implement ICloneable.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Wintellect_PowerCollections_OrderedDictionary_2_ContainsKey_" data-uid="Wintellect.PowerCollections.OrderedDictionary`2.ContainsKey*"></a>
  <h4 id="Wintellect_PowerCollections_OrderedDictionary_2_ContainsKey__0_" data-uid="Wintellect.PowerCollections.OrderedDictionary`2.ContainsKey(`0)">ContainsKey(TKey)</h4>
  <div class="markdown level1 summary"><p>Determines if this dictionary contains a key equal to <code data-dev-comment-type="paramref" class="paramref">key</code>. The dictionary
is not changed.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public sealed override bool ContainsKey(TKey key)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">TKey</span></td>
        <td><span class="parametername">key</span></td>
        <td><p>The key to search for.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Boolean</span></td>
        <td><p>True if the dictionary contains key. False if the dictionary does not contain key.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="overrides">Overrides</h5>
  <div><span class="xref">Wintellect.PowerCollections.DictionaryBase&lt;TKey, TValue&gt;.ContainsKey(TKey)</span></div>
  <h5 id="Wintellect_PowerCollections_OrderedDictionary_2_ContainsKey__0__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>Searching the dictionary for a key takes time O(log N), where N is the number of keys in the dictionary.</p>
</div>
  
  
  <a id="Wintellect_PowerCollections_OrderedDictionary_2_ContainsKey_" data-uid="Wintellect.PowerCollections.OrderedDictionary`2.ContainsKey*"></a>
  <h4 id="Wintellect_PowerCollections_OrderedDictionary_2_ContainsKey__0_" data-uid="Wintellect.PowerCollections.OrderedDictionary`2.ContainsKey(`0)">ContainsKey(TKey)</h4>
  <div class="markdown level1 summary"><p>Determines if this dictionary contains a key equal to <code data-dev-comment-type="paramref" class="paramref">key</code>. The dictionary
is not changed.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public sealed override bool ContainsKey(TKey key)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">TKey</span></td>
        <td><span class="parametername">key</span></td>
        <td><p>The key to search for.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Boolean</span></td>
        <td><p>True if the dictionary contains key. False if the dictionary does not contain key.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="overrides">Overrides</h5>
  <div><span class="xref">Wintellect.PowerCollections.DictionaryBase&lt;TKey, TValue&gt;.ContainsKey(TKey)</span></div>
  <h5 id="Wintellect_PowerCollections_OrderedDictionary_2_ContainsKey__0__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>Searching the dictionary for a key takes time O(log N), where N is the number of keys in the dictionary.</p>
</div>
  
  
  <a id="Wintellect_PowerCollections_OrderedDictionary_2_GetEnumerator_" data-uid="Wintellect.PowerCollections.OrderedDictionary`2.GetEnumerator*"></a>
  <h4 id="Wintellect_PowerCollections_OrderedDictionary_2_GetEnumerator" data-uid="Wintellect.PowerCollections.OrderedDictionary`2.GetEnumerator">GetEnumerator()</h4>
  <div class="markdown level1 summary"><p>Returns an enumerator that enumerates all the entries in the dictionary. Each entry is
returned as a KeyValuePair&lt;TKey,TValue&gt;.
The entries are enumerated in the sorted order of the keys.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public sealed override IEnumerator&lt;KeyValuePair&lt;TKey, TValue&gt;&gt; GetEnumerator()</code></pre>
  </div>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Collections.Generic.IEnumerator</span>&lt;<span class="xref">System.Collections.Generic.KeyValuePair</span>&lt;TKey, TValue&gt;&gt;</td>
        <td><p>An enumerator for enumerating all the elements in the OrderedDictionary.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="overrides">Overrides</h5>
  <div><span class="xref">Wintellect.PowerCollections.CollectionBase&lt;System.Collections.Generic.KeyValuePair&lt;TKey, TValue&gt;&gt;.GetEnumerator()</span></div>
  <h5 id="Wintellect_PowerCollections_OrderedDictionary_2_GetEnumerator_remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>Typically, this method is not called directly. Instead the &quot;foreach&quot; statement is used
to enumerate the elements of the dictionary, which uses this method implicitly.</p>
<p>If an element is added to or deleted from the dictionary while it is being enumerated, then 
the enumeration will end with an InvalidOperationException.</p>
<p>Enumeration all the entries in the dictionary takes time O(N log N), where N is the number
of entries in the dictionary.</p>
</div>
  
  
  <a id="Wintellect_PowerCollections_OrderedDictionary_2_GetEnumerator_" data-uid="Wintellect.PowerCollections.OrderedDictionary`2.GetEnumerator*"></a>
  <h4 id="Wintellect_PowerCollections_OrderedDictionary_2_GetEnumerator" data-uid="Wintellect.PowerCollections.OrderedDictionary`2.GetEnumerator">GetEnumerator()</h4>
  <div class="markdown level1 summary"><p>Returns an enumerator that enumerates all the entries in the dictionary. Each entry is
returned as a KeyValuePair&lt;TKey,TValue&gt;.
The entries are enumerated in the sorted order of the keys.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public sealed override IEnumerator&lt;KeyValuePair&lt;TKey, TValue&gt;&gt; GetEnumerator()</code></pre>
  </div>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Collections.Generic.IEnumerator</span>&lt;<span class="xref">System.Collections.Generic.KeyValuePair</span>&lt;TKey, TValue&gt;&gt;</td>
        <td><p>An enumerator for enumerating all the elements in the OrderedDictionary.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="overrides">Overrides</h5>
  <div><span class="xref">Wintellect.PowerCollections.CollectionBase&lt;System.Collections.Generic.KeyValuePair&lt;TKey, TValue&gt;&gt;.GetEnumerator()</span></div>
  <h5 id="Wintellect_PowerCollections_OrderedDictionary_2_GetEnumerator_remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>Typically, this method is not called directly. Instead the &quot;foreach&quot; statement is used
to enumerate the elements of the dictionary, which uses this method implicitly.</p>
<p>If an element is added to or deleted from the dictionary while it is being enumerated, then 
the enumeration will end with an InvalidOperationException.</p>
<p>Enumeration all the entries in the dictionary takes time O(N log N), where N is the number
of entries in the dictionary.</p>
</div>
  
  
  <a id="Wintellect_PowerCollections_OrderedDictionary_2_GetValueElseAdd_" data-uid="Wintellect.PowerCollections.OrderedDictionary`2.GetValueElseAdd*"></a>
  <h4 id="Wintellect_PowerCollections_OrderedDictionary_2_GetValueElseAdd__0__1__" data-uid="Wintellect.PowerCollections.OrderedDictionary`2.GetValueElseAdd(`0,`1@)">GetValueElseAdd(TKey, ref TValue)</h4>
  <div class="markdown level1 summary"><p>Finds a key in the dictionary. If the dictionary already contains
a key equal to the passed key, then the existing value is returned via value. If the dictionary
doesn't contain that key, then value is associated with that key.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public bool GetValueElseAdd(TKey key, ref TValue value)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">TKey</span></td>
        <td><span class="parametername">key</span></td>
        <td><p>The new key.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">TValue</span></td>
        <td><span class="parametername">value</span></td>
        <td><p>The new value to associated with that key, if the key isn't present. If the key was present,
returns the exist value associated with that key.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Boolean</span></td>
        <td><p>True if key was already present, false if key wasn't present (and a new value was added).</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="Wintellect_PowerCollections_OrderedDictionary_2_GetValueElseAdd__0__1___remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p> between keys is determined by the comparison instance or delegate used
    to create the dictionary.</p>
<p>This method takes time O(log N), where N is the number of keys in the dictionary. If a value is added, It is more efficient than
calling TryGetValue followed by Add, because the dictionary is not searched twice.</p>
</div>
  
  
  <a id="Wintellect_PowerCollections_OrderedDictionary_2_GetValueElseAdd_" data-uid="Wintellect.PowerCollections.OrderedDictionary`2.GetValueElseAdd*"></a>
  <h4 id="Wintellect_PowerCollections_OrderedDictionary_2_GetValueElseAdd__0__1__" data-uid="Wintellect.PowerCollections.OrderedDictionary`2.GetValueElseAdd(`0,`1@)">GetValueElseAdd(TKey, ref TValue)</h4>
  <div class="markdown level1 summary"><p>Finds a key in the dictionary. If the dictionary already contains
a key equal to the passed key, then the existing value is returned via value. If the dictionary
doesn't contain that key, then value is associated with that key.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public bool GetValueElseAdd(TKey key, ref TValue value)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">TKey</span></td>
        <td><span class="parametername">key</span></td>
        <td><p>The new key.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">TValue</span></td>
        <td><span class="parametername">value</span></td>
        <td><p>The new value to associated with that key, if the key isn't present. If the key was present,
returns the exist value associated with that key.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Boolean</span></td>
        <td><p>True if key was already present, false if key wasn't present (and a new value was added).</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="Wintellect_PowerCollections_OrderedDictionary_2_GetValueElseAdd__0__1___remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p> between keys is determined by the comparison instance or delegate used
    to create the dictionary.</p>
<p>This method takes time O(log N), where N is the number of keys in the dictionary. If a value is added, It is more efficient than
calling TryGetValue followed by Add, because the dictionary is not searched twice.</p>
</div>
  
  
  <a id="Wintellect_PowerCollections_OrderedDictionary_2_Range_" data-uid="Wintellect.PowerCollections.OrderedDictionary`2.Range*"></a>
  <h4 id="Wintellect_PowerCollections_OrderedDictionary_2_Range__0_System_Boolean__0_System_Boolean_" data-uid="Wintellect.PowerCollections.OrderedDictionary`2.Range(`0,System.Boolean,`0,System.Boolean)">Range(TKey, Boolean, TKey, Boolean)</h4>
  <div class="markdown level1 summary"><p>Returns a collection that can be used for enumerating some of the keys and values in the collection.
Only keys that are greater than <code data-dev-comment-type="paramref" class="paramref">from</code> and
less than <code data-dev-comment-type="paramref" class="paramref">to</code> are included. The keys are enumerated in sorted order.
Keys equal to the end points of the range can be included or excluded depending on the
<code data-dev-comment-type="paramref" class="paramref">fromInclusive</code> and <code data-dev-comment-type="paramref" class="paramref">toInclusive</code> parameters.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public OrderedDictionary&lt;TKey, TValue&gt;.View Range(TKey from, bool fromInclusive, TKey to, bool toInclusive)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">TKey</span></td>
        <td><span class="parametername">from</span></td>
        <td><p>The lower bound of the range.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Boolean</span></td>
        <td><span class="parametername">fromInclusive</span></td>
        <td><p>If true, the lower bound is inclusive--keys equal to the lower bound will
be included in the range. If false, the lower bound is exclusive--keys equal to the lower bound will not
be included in the range.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">TKey</span></td>
        <td><span class="parametername">to</span></td>
        <td><p>The upper bound of the range.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Boolean</span></td>
        <td><span class="parametername">toInclusive</span></td>
        <td><p>If true, the upper bound is inclusive--keys equal to the upper bound will
be included in the range. If false, the upper bound is exclusive--keys equal to the upper bound will not
be included in the range.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Wintellect.PowerCollections.OrderedDictionary-2.View.html">OrderedDictionary.View</a>&lt;&gt;</td>
        <td><p>An OrderedDictionary.View of key-value pairs in the given range.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="Wintellect_PowerCollections_OrderedDictionary_2_Range__0_System_Boolean__0_System_Boolean__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>If <code data-dev-comment-type="paramref" class="paramref">from</code> is greater than or equal to <code data-dev-comment-type="paramref" class="paramref">to</code>, the returned collection is empty. </p>
<p>The sorted order of the keys is determined by the comparison instance or delegate used
 to create the dictionary.</p>
<p>Typically, this property is used in conjunction with a foreach statement. For example:</p>
<pre><code> foreach(KeyValuePair&lt;TKey, TValue> pair in dictionary.Range(from, true, to, false)) {
    // process pair
 }</code></pre>
<p>Calling Range does not copy the data in the dictionary, and the operation takes constant time.</p>
</div>
  
  
  <a id="Wintellect_PowerCollections_OrderedDictionary_2_Range_" data-uid="Wintellect.PowerCollections.OrderedDictionary`2.Range*"></a>
  <h4 id="Wintellect_PowerCollections_OrderedDictionary_2_Range__0_System_Boolean__0_System_Boolean_" data-uid="Wintellect.PowerCollections.OrderedDictionary`2.Range(`0,System.Boolean,`0,System.Boolean)">Range(TKey, Boolean, TKey, Boolean)</h4>
  <div class="markdown level1 summary"><p>Returns a collection that can be used for enumerating some of the keys and values in the collection.
Only keys that are greater than <code data-dev-comment-type="paramref" class="paramref">from</code> and
less than <code data-dev-comment-type="paramref" class="paramref">to</code> are included. The keys are enumerated in sorted order.
Keys equal to the end points of the range can be included or excluded depending on the
<code data-dev-comment-type="paramref" class="paramref">fromInclusive</code> and <code data-dev-comment-type="paramref" class="paramref">toInclusive</code> parameters.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public OrderedDictionary&lt;TKey, TValue&gt;.View Range(TKey from, bool fromInclusive, TKey to, bool toInclusive)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">TKey</span></td>
        <td><span class="parametername">from</span></td>
        <td><p>The lower bound of the range.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Boolean</span></td>
        <td><span class="parametername">fromInclusive</span></td>
        <td><p>If true, the lower bound is inclusive--keys equal to the lower bound will
be included in the range. If false, the lower bound is exclusive--keys equal to the lower bound will not
be included in the range.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">TKey</span></td>
        <td><span class="parametername">to</span></td>
        <td><p>The upper bound of the range.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Boolean</span></td>
        <td><span class="parametername">toInclusive</span></td>
        <td><p>If true, the upper bound is inclusive--keys equal to the upper bound will
be included in the range. If false, the upper bound is exclusive--keys equal to the upper bound will not
be included in the range.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Wintellect.PowerCollections.OrderedDictionary-2.View.html">OrderedDictionary.View</a>&lt;&gt;</td>
        <td><p>An OrderedDictionary.View of key-value pairs in the given range.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="Wintellect_PowerCollections_OrderedDictionary_2_Range__0_System_Boolean__0_System_Boolean__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>If <code data-dev-comment-type="paramref" class="paramref">from</code> is greater than or equal to <code data-dev-comment-type="paramref" class="paramref">to</code>, the returned collection is empty. </p>
<p>The sorted order of the keys is determined by the comparison instance or delegate used
 to create the dictionary.</p>
<p>Typically, this property is used in conjunction with a foreach statement. For example:</p>
<pre><code> foreach(KeyValuePair&lt;TKey, TValue> pair in dictionary.Range(from, true, to, false)) {
    // process pair
 }</code></pre>
<p>Calling Range does not copy the data in the dictionary, and the operation takes constant time.</p>
</div>
  
  
  <a id="Wintellect_PowerCollections_OrderedDictionary_2_RangeFrom_" data-uid="Wintellect.PowerCollections.OrderedDictionary`2.RangeFrom*"></a>
  <h4 id="Wintellect_PowerCollections_OrderedDictionary_2_RangeFrom__0_System_Boolean_" data-uid="Wintellect.PowerCollections.OrderedDictionary`2.RangeFrom(`0,System.Boolean)">RangeFrom(TKey, Boolean)</h4>
  <div class="markdown level1 summary"><p>Returns a collection that can be used for enumerating some of the keys and values in the collection.
Only keys that are greater than (and optionally, equal to) <code data-dev-comment-type="paramref" class="paramref">from</code> are included.
The keys are enumerated in sorted order. Keys equal to <code data-dev-comment-type="paramref" class="paramref">from</code> can be included
or excluded depending on the <code data-dev-comment-type="paramref" class="paramref">fromInclusive</code> parameter.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public OrderedDictionary&lt;TKey, TValue&gt;.View RangeFrom(TKey from, bool fromInclusive)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">TKey</span></td>
        <td><span class="parametername">from</span></td>
        <td><p>The lower bound of the range.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Boolean</span></td>
        <td><span class="parametername">fromInclusive</span></td>
        <td><p>If true, the lower bound is inclusive--keys equal to the lower bound will
be included in the range. If false, the lower bound is exclusive--keys equal to the lower bound will not
be included in the range.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Wintellect.PowerCollections.OrderedDictionary-2.View.html">OrderedDictionary.View</a>&lt;&gt;</td>
        <td><p>An OrderedDictionary.View of key-value pairs in the given range.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="Wintellect_PowerCollections_OrderedDictionary_2_RangeFrom__0_System_Boolean__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>The sorted order of the keys is determined by the comparison instance or delegate used
 to create the dictionary.</p>
<p>Typically, this property is used in conjunction with a foreach statement. For example:</p>
<pre><code> foreach(KeyValuePair&lt;TKey, TValue> pair in dictionary.RangeFrom(from, true)) {
    // process pair
 }</code></pre>
<p>Calling RangeFrom does not copy of the data in the dictionary, and the operation takes constant time.</p>
</div>
  
  
  <a id="Wintellect_PowerCollections_OrderedDictionary_2_RangeFrom_" data-uid="Wintellect.PowerCollections.OrderedDictionary`2.RangeFrom*"></a>
  <h4 id="Wintellect_PowerCollections_OrderedDictionary_2_RangeFrom__0_System_Boolean_" data-uid="Wintellect.PowerCollections.OrderedDictionary`2.RangeFrom(`0,System.Boolean)">RangeFrom(TKey, Boolean)</h4>
  <div class="markdown level1 summary"><p>Returns a collection that can be used for enumerating some of the keys and values in the collection.
Only keys that are greater than (and optionally, equal to) <code data-dev-comment-type="paramref" class="paramref">from</code> are included.
The keys are enumerated in sorted order. Keys equal to <code data-dev-comment-type="paramref" class="paramref">from</code> can be included
or excluded depending on the <code data-dev-comment-type="paramref" class="paramref">fromInclusive</code> parameter.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public OrderedDictionary&lt;TKey, TValue&gt;.View RangeFrom(TKey from, bool fromInclusive)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">TKey</span></td>
        <td><span class="parametername">from</span></td>
        <td><p>The lower bound of the range.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Boolean</span></td>
        <td><span class="parametername">fromInclusive</span></td>
        <td><p>If true, the lower bound is inclusive--keys equal to the lower bound will
be included in the range. If false, the lower bound is exclusive--keys equal to the lower bound will not
be included in the range.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Wintellect.PowerCollections.OrderedDictionary-2.View.html">OrderedDictionary.View</a>&lt;&gt;</td>
        <td><p>An OrderedDictionary.View of key-value pairs in the given range.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="Wintellect_PowerCollections_OrderedDictionary_2_RangeFrom__0_System_Boolean__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>The sorted order of the keys is determined by the comparison instance or delegate used
 to create the dictionary.</p>
<p>Typically, this property is used in conjunction with a foreach statement. For example:</p>
<pre><code> foreach(KeyValuePair&lt;TKey, TValue> pair in dictionary.RangeFrom(from, true)) {
    // process pair
 }</code></pre>
<p>Calling RangeFrom does not copy of the data in the dictionary, and the operation takes constant time.</p>
</div>
  
  
  <a id="Wintellect_PowerCollections_OrderedDictionary_2_RangeTo_" data-uid="Wintellect.PowerCollections.OrderedDictionary`2.RangeTo*"></a>
  <h4 id="Wintellect_PowerCollections_OrderedDictionary_2_RangeTo__0_System_Boolean_" data-uid="Wintellect.PowerCollections.OrderedDictionary`2.RangeTo(`0,System.Boolean)">RangeTo(TKey, Boolean)</h4>
  <div class="markdown level1 summary"><p>Returns a collection that can be used for enumerating some of the keys and values in the collection.
Only items that are less than (and optionally, equal to) <code data-dev-comment-type="paramref" class="paramref">to</code> are included.
The items are enumerated in sorted order. Items equal to <code data-dev-comment-type="paramref" class="paramref">to</code> can be included
or excluded depending on the <code data-dev-comment-type="paramref" class="paramref">toInclusive</code> parameter.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public OrderedDictionary&lt;TKey, TValue&gt;.View RangeTo(TKey to, bool toInclusive)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">TKey</span></td>
        <td><span class="parametername">to</span></td>
        <td><p>The upper bound of the range.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Boolean</span></td>
        <td><span class="parametername">toInclusive</span></td>
        <td><p>If true, the upper bound is inclusive--keys equal to the upper bound will
be included in the range. If false, the upper bound is exclusive--keys equal to the upper bound will not
be included in the range.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Wintellect.PowerCollections.OrderedDictionary-2.View.html">OrderedDictionary.View</a>&lt;&gt;</td>
        <td><p>An OrderedDictionary.View of key-value pairs in the given range.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="Wintellect_PowerCollections_OrderedDictionary_2_RangeTo__0_System_Boolean__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>The sorted order of the keys is determined by the comparison instance or delegate used
 to create the dictionary.</p>
<p>Typically, this property is used in conjunction with a foreach statement. For example:</p>
<pre><code> foreach(KeyValuePair&lt;TKey, TValue> pair in dictionary.RangeFrom(from, false)) {
    // process pair
 }</code></pre>
<p>Calling RangeTo does not copy the data in the dictionary, and the operation takes constant time.</p>
</div>
  
  
  <a id="Wintellect_PowerCollections_OrderedDictionary_2_RangeTo_" data-uid="Wintellect.PowerCollections.OrderedDictionary`2.RangeTo*"></a>
  <h4 id="Wintellect_PowerCollections_OrderedDictionary_2_RangeTo__0_System_Boolean_" data-uid="Wintellect.PowerCollections.OrderedDictionary`2.RangeTo(`0,System.Boolean)">RangeTo(TKey, Boolean)</h4>
  <div class="markdown level1 summary"><p>Returns a collection that can be used for enumerating some of the keys and values in the collection.
Only items that are less than (and optionally, equal to) <code data-dev-comment-type="paramref" class="paramref">to</code> are included.
The items are enumerated in sorted order. Items equal to <code data-dev-comment-type="paramref" class="paramref">to</code> can be included
or excluded depending on the <code data-dev-comment-type="paramref" class="paramref">toInclusive</code> parameter.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public OrderedDictionary&lt;TKey, TValue&gt;.View RangeTo(TKey to, bool toInclusive)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">TKey</span></td>
        <td><span class="parametername">to</span></td>
        <td><p>The upper bound of the range.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Boolean</span></td>
        <td><span class="parametername">toInclusive</span></td>
        <td><p>If true, the upper bound is inclusive--keys equal to the upper bound will
be included in the range. If false, the upper bound is exclusive--keys equal to the upper bound will not
be included in the range.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Wintellect.PowerCollections.OrderedDictionary-2.View.html">OrderedDictionary.View</a>&lt;&gt;</td>
        <td><p>An OrderedDictionary.View of key-value pairs in the given range.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="Wintellect_PowerCollections_OrderedDictionary_2_RangeTo__0_System_Boolean__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>The sorted order of the keys is determined by the comparison instance or delegate used
 to create the dictionary.</p>
<p>Typically, this property is used in conjunction with a foreach statement. For example:</p>
<pre><code> foreach(KeyValuePair&lt;TKey, TValue> pair in dictionary.RangeFrom(from, false)) {
    // process pair
 }</code></pre>
<p>Calling RangeTo does not copy the data in the dictionary, and the operation takes constant time.</p>
</div>
  
  
  <a id="Wintellect_PowerCollections_OrderedDictionary_2_Remove_" data-uid="Wintellect.PowerCollections.OrderedDictionary`2.Remove*"></a>
  <h4 id="Wintellect_PowerCollections_OrderedDictionary_2_Remove__0_" data-uid="Wintellect.PowerCollections.OrderedDictionary`2.Remove(`0)">Remove(TKey)</h4>
  <div class="markdown level1 summary"><p>Removes the key (and associated value) from the collection that is equal to the passed in key. If
no key in the dictionary is equal to the passed key, false is returned and the
dictionary is unchanged.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public sealed override bool Remove(TKey key)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">TKey</span></td>
        <td><span class="parametername">key</span></td>
        <td><p>The key to remove.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Boolean</span></td>
        <td><p>True if the key was found and removed. False if the key was not found.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="overrides">Overrides</h5>
  <div><span class="xref">Wintellect.PowerCollections.DictionaryBase&lt;TKey, TValue&gt;.Remove(TKey)</span></div>
  <h5 id="Wintellect_PowerCollections_OrderedDictionary_2_Remove__0__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>Equality between keys is determined by the comparison instance or delegate used
to create the dictionary.</p>
</div>
  
  
  <a id="Wintellect_PowerCollections_OrderedDictionary_2_Remove_" data-uid="Wintellect.PowerCollections.OrderedDictionary`2.Remove*"></a>
  <h4 id="Wintellect_PowerCollections_OrderedDictionary_2_Remove__0_" data-uid="Wintellect.PowerCollections.OrderedDictionary`2.Remove(`0)">Remove(TKey)</h4>
  <div class="markdown level1 summary"><p>Removes the key (and associated value) from the collection that is equal to the passed in key. If
no key in the dictionary is equal to the passed key, false is returned and the
dictionary is unchanged.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public sealed override bool Remove(TKey key)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">TKey</span></td>
        <td><span class="parametername">key</span></td>
        <td><p>The key to remove.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Boolean</span></td>
        <td><p>True if the key was found and removed. False if the key was not found.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="overrides">Overrides</h5>
  <div><span class="xref">Wintellect.PowerCollections.DictionaryBase&lt;TKey, TValue&gt;.Remove(TKey)</span></div>
  <h5 id="Wintellect_PowerCollections_OrderedDictionary_2_Remove__0__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>Equality between keys is determined by the comparison instance or delegate used
to create the dictionary.</p>
</div>
  
  
  <a id="Wintellect_PowerCollections_OrderedDictionary_2_RemoveMany_" data-uid="Wintellect.PowerCollections.OrderedDictionary`2.RemoveMany*"></a>
  <h4 id="Wintellect_PowerCollections_OrderedDictionary_2_RemoveMany_System_Collections_Generic_IEnumerable__0__" data-uid="Wintellect.PowerCollections.OrderedDictionary`2.RemoveMany(System.Collections.Generic.IEnumerable{`0})">RemoveMany(IEnumerable&lt;TKey&gt;)</h4>
  <div class="markdown level1 summary"><p>Removes all the keys found in another collection (such as an array or List&lt;TKey&gt;). Each key in keyCollectionToRemove
is removed from the dictionary. Keys that are not present are ignored.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public int RemoveMany(IEnumerable&lt;TKey&gt; keyCollectionToRemove)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Collections.Generic.IEnumerable</span>&lt;TKey&gt;</td>
        <td><span class="parametername">keyCollectionToRemove</span></td>
        <td><p>A collection of keys to remove from the dictionary.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Int32</span></td>
        <td><p>The number of keys removed from the dictionary.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="Wintellect_PowerCollections_OrderedDictionary_2_RemoveMany_System_Collections_Generic_IEnumerable__0___remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>RemoveMany takes time O(M log N), where M is the size of keyCollectionToRemove, and N is this
size of this collection.</p>
</div>
  
  
  <a id="Wintellect_PowerCollections_OrderedDictionary_2_RemoveMany_" data-uid="Wintellect.PowerCollections.OrderedDictionary`2.RemoveMany*"></a>
  <h4 id="Wintellect_PowerCollections_OrderedDictionary_2_RemoveMany_System_Collections_Generic_IEnumerable__0__" data-uid="Wintellect.PowerCollections.OrderedDictionary`2.RemoveMany(System.Collections.Generic.IEnumerable{`0})">RemoveMany(IEnumerable&lt;TKey&gt;)</h4>
  <div class="markdown level1 summary"><p>Removes all the keys found in another collection (such as an array or List&lt;TKey&gt;). Each key in keyCollectionToRemove
is removed from the dictionary. Keys that are not present are ignored.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public int RemoveMany(IEnumerable&lt;TKey&gt; keyCollectionToRemove)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Collections.Generic.IEnumerable</span>&lt;TKey&gt;</td>
        <td><span class="parametername">keyCollectionToRemove</span></td>
        <td><p>A collection of keys to remove from the dictionary.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Int32</span></td>
        <td><p>The number of keys removed from the dictionary.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="Wintellect_PowerCollections_OrderedDictionary_2_RemoveMany_System_Collections_Generic_IEnumerable__0___remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>RemoveMany takes time O(M log N), where M is the size of keyCollectionToRemove, and N is this
size of this collection.</p>
</div>
  
  
  <a id="Wintellect_PowerCollections_OrderedDictionary_2_Replace_" data-uid="Wintellect.PowerCollections.OrderedDictionary`2.Replace*"></a>
  <h4 id="Wintellect_PowerCollections_OrderedDictionary_2_Replace__0__1_" data-uid="Wintellect.PowerCollections.OrderedDictionary`2.Replace(`0,`1)">Replace(TKey, TValue)</h4>
  <div class="markdown level1 summary"><p>Changes the value associated with a given key. If the dictionary does not contain
a key equal to the passed key, then an ArgumentException is thrown.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public void Replace(TKey key, TValue value)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">TKey</span></td>
        <td><span class="parametername">key</span></td>
        <td><p>The new key.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">TValue</span></td>
        <td><span class="parametername">value</span></td>
        <td><p>The new value to associated with that key.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="Wintellect_PowerCollections_OrderedDictionary_2_Replace__0__1__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>Unlike adding or removing an element, changing the value associated with a key
can be performed while an enumeration (foreach) on the the dictionary is in progress.</p>
<p>Equality between keys is determined by the comparison instance or delegate used
to create the dictionary.</p>
<p>Replace takes time O(log N), where N is the number of entries in the dictionary.</p>
</div>
  <h5 class="exceptions">Exceptions</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Condition</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Collections.Generic.KeyNotFoundException</span></td>
        <td><p>key is not present in the dictionary</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Wintellect_PowerCollections_OrderedDictionary_2_Replace_" data-uid="Wintellect.PowerCollections.OrderedDictionary`2.Replace*"></a>
  <h4 id="Wintellect_PowerCollections_OrderedDictionary_2_Replace__0__1_" data-uid="Wintellect.PowerCollections.OrderedDictionary`2.Replace(`0,`1)">Replace(TKey, TValue)</h4>
  <div class="markdown level1 summary"><p>Changes the value associated with a given key. If the dictionary does not contain
a key equal to the passed key, then an ArgumentException is thrown.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public void Replace(TKey key, TValue value)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">TKey</span></td>
        <td><span class="parametername">key</span></td>
        <td><p>The new key.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">TValue</span></td>
        <td><span class="parametername">value</span></td>
        <td><p>The new value to associated with that key.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="Wintellect_PowerCollections_OrderedDictionary_2_Replace__0__1__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>Unlike adding or removing an element, changing the value associated with a key
can be performed while an enumeration (foreach) on the the dictionary is in progress.</p>
<p>Equality between keys is determined by the comparison instance or delegate used
to create the dictionary.</p>
<p>Replace takes time O(log N), where N is the number of entries in the dictionary.</p>
</div>
  <h5 class="exceptions">Exceptions</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Condition</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Collections.Generic.KeyNotFoundException</span></td>
        <td><p>key is not present in the dictionary</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Wintellect_PowerCollections_OrderedDictionary_2_Reversed_" data-uid="Wintellect.PowerCollections.OrderedDictionary`2.Reversed*"></a>
  <h4 id="Wintellect_PowerCollections_OrderedDictionary_2_Reversed" data-uid="Wintellect.PowerCollections.OrderedDictionary`2.Reversed">Reversed()</h4>
  <div class="markdown level1 summary"><p>Returns a View collection that can be used for enumerating the keys and values in the collection in
reversed order.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public OrderedDictionary&lt;TKey, TValue&gt;.View Reversed()</code></pre>
  </div>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Wintellect.PowerCollections.OrderedDictionary-2.View.html">OrderedDictionary.View</a>&lt;&gt;</td>
        <td><p>An OrderedDictionary.View of key-value pairs in reverse order.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="Wintellect_PowerCollections_OrderedDictionary_2_Reversed_remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>Typically, this method is used in conjunction with a foreach statement. For example:
<pre><code> foreach(KeyValuePair&lt;TKey, TValue> pair in dictionary.Reversed()) {
    // process pair
 }</code></pre></p>
<p>If an entry is added to or deleted from the dictionary while the View is being enumerated, then 
the enumeration will end with an InvalidOperationException.</p>
<p>Calling Reverse does not copy the data in the dictionary, and the operation takes constant time.</p>
</div>
  
  
  <a id="Wintellect_PowerCollections_OrderedDictionary_2_Reversed_" data-uid="Wintellect.PowerCollections.OrderedDictionary`2.Reversed*"></a>
  <h4 id="Wintellect_PowerCollections_OrderedDictionary_2_Reversed" data-uid="Wintellect.PowerCollections.OrderedDictionary`2.Reversed">Reversed()</h4>
  <div class="markdown level1 summary"><p>Returns a View collection that can be used for enumerating the keys and values in the collection in
reversed order.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public OrderedDictionary&lt;TKey, TValue&gt;.View Reversed()</code></pre>
  </div>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Wintellect.PowerCollections.OrderedDictionary-2.View.html">OrderedDictionary.View</a>&lt;&gt;</td>
        <td><p>An OrderedDictionary.View of key-value pairs in reverse order.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="Wintellect_PowerCollections_OrderedDictionary_2_Reversed_remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>Typically, this method is used in conjunction with a foreach statement. For example:
<pre><code> foreach(KeyValuePair&lt;TKey, TValue> pair in dictionary.Reversed()) {
    // process pair
 }</code></pre></p>
<p>If an entry is added to or deleted from the dictionary while the View is being enumerated, then 
the enumeration will end with an InvalidOperationException.</p>
<p>Calling Reverse does not copy the data in the dictionary, and the operation takes constant time.</p>
</div>
  
  
  <a id="Wintellect_PowerCollections_OrderedDictionary_2_TryGetValue_" data-uid="Wintellect.PowerCollections.OrderedDictionary`2.TryGetValue*"></a>
  <h4 id="Wintellect_PowerCollections_OrderedDictionary_2_TryGetValue__0__1__" data-uid="Wintellect.PowerCollections.OrderedDictionary`2.TryGetValue(`0,`1@)">TryGetValue(TKey, out TValue)</h4>
  <div class="markdown level1 summary"><p>Determines if this dictionary contains a key equal to <code data-dev-comment-type="paramref" class="paramref">key</code>. If so, the value
associated with that key is returned through the value parameter.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public sealed override bool TryGetValue(TKey key, out TValue value)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">TKey</span></td>
        <td><span class="parametername">key</span></td>
        <td><p>The key to search for.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">TValue</span></td>
        <td><span class="parametername">value</span></td>
        <td><p>Returns the value associated with key, if true was returned.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Boolean</span></td>
        <td><p>True if the dictionary contains key. False if the dictionary does not contain key.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="overrides">Overrides</h5>
  <div><span class="xref">Wintellect.PowerCollections.DictionaryBase&lt;TKey, TValue&gt;.TryGetValue(TKey, TValue)</span></div>
  <h5 id="Wintellect_PowerCollections_OrderedDictionary_2_TryGetValue__0__1___remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>TryGetValue takes time O(log N), where N is the number of entries in the dictionary.</p>
</div>
  
  
  <a id="Wintellect_PowerCollections_OrderedDictionary_2_TryGetValue_" data-uid="Wintellect.PowerCollections.OrderedDictionary`2.TryGetValue*"></a>
  <h4 id="Wintellect_PowerCollections_OrderedDictionary_2_TryGetValue__0__1__" data-uid="Wintellect.PowerCollections.OrderedDictionary`2.TryGetValue(`0,`1@)">TryGetValue(TKey, out TValue)</h4>
  <div class="markdown level1 summary"><p>Determines if this dictionary contains a key equal to <code data-dev-comment-type="paramref" class="paramref">key</code>. If so, the value
associated with that key is returned through the value parameter.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public sealed override bool TryGetValue(TKey key, out TValue value)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">TKey</span></td>
        <td><span class="parametername">key</span></td>
        <td><p>The key to search for.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">TValue</span></td>
        <td><span class="parametername">value</span></td>
        <td><p>Returns the value associated with key, if true was returned.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Boolean</span></td>
        <td><p>True if the dictionary contains key. False if the dictionary does not contain key.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="overrides">Overrides</h5>
  <div><span class="xref">Wintellect.PowerCollections.DictionaryBase&lt;TKey, TValue&gt;.TryGetValue(TKey, TValue)</span></div>
  <h5 id="Wintellect_PowerCollections_OrderedDictionary_2_TryGetValue__0__1___remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>TryGetValue takes time O(log N), where N is the number of entries in the dictionary.</p>
</div>
  <h3 id="eii">Explicit Interface Implementations
  </h3>
  
  
  <a id="Wintellect_PowerCollections_OrderedDictionary_2_System_ICloneable_Clone_" data-uid="Wintellect.PowerCollections.OrderedDictionary`2.System#ICloneable#Clone*"></a>
  <h4 id="Wintellect_PowerCollections_OrderedDictionary_2_System_ICloneable_Clone" data-uid="Wintellect.PowerCollections.OrderedDictionary`2.System#ICloneable#Clone">ICloneable.Clone()</h4>
  <div class="markdown level1 summary"><p>Implements ICloneable.Clone. Makes a shallow clone of this dictionary; i.e., if keys or values are reference types, then they are not cloned.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">object ICloneable.Clone()</code></pre>
  </div>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Object</span></td>
        <td><p>The cloned dictionary.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Wintellect_PowerCollections_OrderedDictionary_2_System_ICloneable_Clone_" data-uid="Wintellect.PowerCollections.OrderedDictionary`2.System#ICloneable#Clone*"></a>
  <h4 id="Wintellect_PowerCollections_OrderedDictionary_2_System_ICloneable_Clone" data-uid="Wintellect.PowerCollections.OrderedDictionary`2.System#ICloneable#Clone">ICloneable.Clone()</h4>
  <div class="markdown level1 summary"><p>Implements ICloneable.Clone. Makes a shallow clone of this dictionary; i.e., if keys or values are reference types, then they are not cloned.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">object ICloneable.Clone()</code></pre>
  </div>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Object</span></td>
        <td><p>The cloned dictionary.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h3 id="implements">Implements</h3>
  <div>
      <span class="xref">System.Collections.Generic.IDictionary&lt;TKey, TValue&gt;</span>
  </div>
  <div>
      <span class="xref">System.Collections.Generic.ICollection&lt;T&gt;</span>
  </div>
  <div>
      <span class="xref">System.Collections.Generic.IEnumerable&lt;T&gt;</span>
  </div>
  <div>
      <span class="xref">System.Collections.IDictionary</span>
  </div>
  <div>
      <span class="xref">System.Collections.ICollection</span>
  </div>
  <div>
      <span class="xref">System.Collections.IEnumerable</span>
  </div>
  <div>
      <span class="xref">System.ICloneable</span>
  </div>
  <h3 id="seealso">See Also</h3>
  <div class="seealso">
      <div><span class="xref">System.Collections.Generic.Dictionary`2</span></div>
      <div><span class="xref">System.Collections.Generic.Dictionary`2</span></div>
  </div>
</article>
          </div>
          
          <div class="hidden-sm col-md-2" role="complementary">
            <div class="sideaffix">
              <div class="contribution">
                <ul class="nav">
                </ul>
              </div>
              <nav class="bs-docs-sidebar hidden-print hidden-xs hidden-sm affix" id="affix">
                <h5>In This Article</h5>
                <div></div>
              </nav>
            </div>
          </div>
        </div>
      </div>
      
      <footer>
        <div class="grad-bottom"></div>
        <div class="footer">
          <div class="container">
            <span class="pull-right">
              <a href="#top">Back to top</a>
            </span>
            
            <span>Generated by <strong>DocFX</strong></span>
          </div>
        </div>
      </footer>
    </div>
    
    <script type="text/javascript" src="../styles/docfx.vendor.js"></script>
    <script type="text/javascript" src="../styles/docfx.js"></script>
    <script type="text/javascript" src="../styles/main.js"></script>
  </body>
</html>
