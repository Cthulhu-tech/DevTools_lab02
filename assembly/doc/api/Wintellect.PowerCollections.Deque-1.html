<!DOCTYPE html>
<!--[if IE]><![endif]-->
<html>
  
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>Class Deque&lt;T&gt;
   </title>
    <meta name="viewport" content="width=device-width">
    <meta name="title" content="Class Deque&lt;T&gt;
   ">
    <meta name="generator" content="docfx 2.59.4.0">
    
    <link rel="shortcut icon" href="../favicon.ico">
    <link rel="stylesheet" href="../styles/docfx.vendor.css">
    <link rel="stylesheet" href="../styles/docfx.css">
    <link rel="stylesheet" href="../styles/main.css">
    <meta property="docfx:navrel" content="../toc">
    <meta property="docfx:tocrel" content="toc">
    
    
    
  </head>
  <body data-spy="scroll" data-target="#affix" data-offset="120">
    <div id="wrapper">
      <header>
        
        <nav id="autocollapse" class="navbar navbar-inverse ng-scope" role="navigation">
          <div class="container">
            <div class="navbar-header">
              <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#navbar">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
              </button>
              
              <a class="navbar-brand" href="../index.html">
                <img id="logo" class="svg" src="../logo.svg" alt="">
              </a>
            </div>
            <div class="collapse navbar-collapse" id="navbar">
              <form class="navbar-form navbar-right" role="search" id="search">
                <div class="form-group">
                  <input type="text" class="form-control" id="search-query" placeholder="Search" autocomplete="off">
                </div>
              </form>
                
                <ul class="nav level1 navbar-nav">
                      <li>
                          <a href=".././api/Wintellect.PowerCollections.html" title="Wintellect">Wintellect</a>
                      </li>
                </ul>    </div>
          </div>
        </nav>
        
        <div class="subnav navbar navbar-default">
          <div class="container hide-when-search" id="breadcrumb">
            <ul class="breadcrumb">
              <li></li>
            </ul>
          </div>
        </div>
      </header>
      <div role="main" class="container body-content hide-when-search">
        <div class="sidenav hide-when-search">
          <a class="btn toc-toggle collapse" data-toggle="collapse" href="#sidetoggle" aria-expanded="false" aria-controls="sidetoggle">Show / Hide Table of Contents</a>
          <div class="sidetoggle collapse" id="sidetoggle">
            <div>
              <div class="sidefilter">
                <form class="toc-filter">
                  <span class="glyphicon glyphicon-filter filter-icon"></span>
                  <input type="text" id="toc_filter_input" placeholder="Enter here to filter..." onkeypress="if(event.keyCode==13) {return false;}">
                </form>
              </div>
              <div class="sidetoc">
                <div class="toc" id="toc">
                  
                  <ul class="nav level1">
                    <li class="">
                      <span class="expand-stub"></span>
                      <a href="Wintellect.PowerCollections.html" title="Wintellect.PowerCollections" class="">Wintellect.PowerCollections</a>
                        
                        <ul class="nav level2">
                          <li class="">
                            <a href="Wintellect.PowerCollections.Algorithms.html" title="Algorithms" class="">Algorithms</a>
                          </li>
                          <li class="">
                            <a href="Wintellect.PowerCollections.Bag-1.html" title="Bag&lt;T&gt;" class="">Bag&lt;T&gt;</a>
                          </li>
                          <li class="">
                            <a href="Wintellect.PowerCollections.BigList-1.html" title="BigList&lt;T&gt;" class="">BigList&lt;T&gt;</a>
                          </li>
                          <li class="">
                            <a href="Wintellect.PowerCollections.BinaryPredicate-1.html" title="BinaryPredicate&lt;T&gt;" class="">BinaryPredicate&lt;T&gt;</a>
                          </li>
                          <li class="">
                            <a href="Wintellect.PowerCollections.BinaryPredicate-1.html" title="BinaryPredicate&lt;T&gt;" class="">BinaryPredicate&lt;T&gt;</a>
                          </li>
                          <li class="">
                            <a href="Wintellect.PowerCollections.CollectionBase-1.html" title="CollectionBase&lt;T&gt;" class="">CollectionBase&lt;T&gt;</a>
                          </li>
                          <li class="active">
                            <a href="Wintellect.PowerCollections.Deque-1.html" title="Deque&lt;T&gt;" class="active">Deque&lt;T&gt;</a>
                          </li>
                          <li class="">
                            <a href="Wintellect.PowerCollections.DictionaryBase-2.html" title="DictionaryBase&lt;TKey, TValue&gt;" class="">DictionaryBase&lt;TKey, TValue&gt;</a>
                          </li>
                          <li class="">
                            <a href="Wintellect.PowerCollections.ListBase-1.html" title="ListBase&lt;T&gt;" class="">ListBase&lt;T&gt;</a>
                          </li>
                          <li class="">
                            <a href="Wintellect.PowerCollections.MultiDictionary-2.html" title="MultiDictionary&lt;TKey, TValue&gt;" class="">MultiDictionary&lt;TKey, TValue&gt;</a>
                          </li>
                          <li class="">
                            <a href="Wintellect.PowerCollections.MultiDictionaryBase-2.html" title="MultiDictionaryBase&lt;TKey, TValue&gt;" class="">MultiDictionaryBase&lt;TKey, TValue&gt;</a>
                          </li>
                          <li class="">
                            <a href="Wintellect.PowerCollections.OrderedBag-1.html" title="OrderedBag&lt;T&gt;" class="">OrderedBag&lt;T&gt;</a>
                          </li>
                          <li class="">
                            <a href="Wintellect.PowerCollections.OrderedBag-1.View.html" title="OrderedBag&lt;T&gt;.View" class="">OrderedBag&lt;T&gt;.View</a>
                          </li>
                          <li class="">
                            <a href="Wintellect.PowerCollections.OrderedDictionary-2.html" title="OrderedDictionary&lt;TKey, TValue&gt;" class="">OrderedDictionary&lt;TKey, TValue&gt;</a>
                          </li>
                          <li class="">
                            <a href="Wintellect.PowerCollections.OrderedDictionary-2.View.html" title="OrderedDictionary&lt;TKey, TValue&gt;.View" class="">OrderedDictionary&lt;TKey, TValue&gt;.View</a>
                          </li>
                          <li class="">
                            <a href="Wintellect.PowerCollections.OrderedMultiDictionary-2.html" title="OrderedMultiDictionary&lt;TKey, TValue&gt;" class="">OrderedMultiDictionary&lt;TKey, TValue&gt;</a>
                          </li>
                          <li class="">
                            <a href="Wintellect.PowerCollections.OrderedMultiDictionary-2.View.html" title="OrderedMultiDictionary&lt;TKey, TValue&gt;.View" class="">OrderedMultiDictionary&lt;TKey, TValue&gt;.View</a>
                          </li>
                          <li class="">
                            <a href="Wintellect.PowerCollections.OrderedSet-1.html" title="OrderedSet&lt;T&gt;" class="">OrderedSet&lt;T&gt;</a>
                          </li>
                          <li class="">
                            <a href="Wintellect.PowerCollections.OrderedSet-1.View.html" title="OrderedSet&lt;T&gt;.View" class="">OrderedSet&lt;T&gt;.View</a>
                          </li>
                          <li class="">
                            <a href="Wintellect.PowerCollections.Pair-2.html" title="Pair&lt;TFirst, TSecond&gt;" class="">Pair&lt;TFirst, TSecond&gt;</a>
                          </li>
                          <li class="">
                            <a href="Wintellect.PowerCollections.ReadOnlyCollectionBase-1.html" title="ReadOnlyCollectionBase&lt;T&gt;" class="">ReadOnlyCollectionBase&lt;T&gt;</a>
                          </li>
                          <li class="">
                            <a href="Wintellect.PowerCollections.ReadOnlyDictionaryBase-2.html" title="ReadOnlyDictionaryBase&lt;TKey, TValue&gt;" class="">ReadOnlyDictionaryBase&lt;TKey, TValue&gt;</a>
                          </li>
                          <li class="">
                            <a href="Wintellect.PowerCollections.ReadOnlyListBase-1.html" title="ReadOnlyListBase&lt;T&gt;" class="">ReadOnlyListBase&lt;T&gt;</a>
                          </li>
                          <li class="">
                            <a href="Wintellect.PowerCollections.ReadOnlyMultiDictionaryBase-2.html" title="ReadOnlyMultiDictionaryBase&lt;TKey, TValue&gt;" class="">ReadOnlyMultiDictionaryBase&lt;TKey, TValue&gt;</a>
                          </li>
                          <li class="">
                            <a href="Wintellect.PowerCollections.Set-1.html" title="Set&lt;T&gt;" class="">Set&lt;T&gt;</a>
                          </li>
                          <li class="">
                            <a href="Wintellect.PowerCollections.Stack-1.html" title="Stack&lt;T&gt;" class="">Stack&lt;T&gt;</a>
                          </li>
                          <li class="">
                            <a href="Wintellect.PowerCollections.Triple-3.html" title="Triple&lt;TFirst, TSecond, TThird&gt;" class="">Triple&lt;TFirst, TSecond, TThird&gt;</a>
                          </li>
                        </ul>  </li>
                  </ul>        </div>
              </div>
            </div>
          </div>
        </div>
        <div class="article row grid-right">
          <div class="col-md-10">
            <article class="content wrap" id="_content" data-uid="Wintellect.PowerCollections.Deque`1">
  
  
  <h1 id="Wintellect_PowerCollections_Deque_1" data-uid="Wintellect.PowerCollections.Deque`1" class="text-break">Class Deque&lt;T&gt;
  </h1>
  <div class="markdown level0 summary"><p>The Deque class implements a type of list known as a Double Ended Queue. A Deque
is quite similar to a List, in that items have indices (starting at 0), and the item at any
index can be efficiently retrieved. The difference between a List and a Deque lies in the
efficiency of inserting elements at the beginning. In a List, items can be efficiently added
to the end, but inserting an item at the beginning of the List is slow, taking time 
proportional to the size of the List. In a Deque, items can be added to the beginning 
or end equally efficiently, regardless of the number of items in the Deque. As a trade-off
for this increased flexibility, Deque is somewhat slower than List (but still constant time) when
being indexed to get or retrieve elements. </p>
</div>
  <div class="markdown level0 conceptual"></div>
  <div class="inheritance">
    <h5>Inheritance</h5>
    <div class="level0"><span class="xref">System.Object</span></div>
    <div class="level1"><a class="xref" href="Wintellect.PowerCollections.CollectionBase-1.html">CollectionBase</a>&lt;T&gt;</div>
    <div class="level2"><a class="xref" href="Wintellect.PowerCollections.ListBase-1.html">ListBase</a>&lt;T&gt;</div>
    <div class="level3"><span class="xref">Deque&lt;T&gt;</span></div>
  </div>
  <div class="implements">
    <h5>Implements</h5>
    <div><span class="xref">System.Collections.Generic.IList</span>&lt;T&gt;</div>
    <div><span class="xref">System.Collections.Generic.ICollection</span>&lt;T&gt;</div>
    <div><span class="xref">System.Collections.Generic.IEnumerable</span>&lt;T&gt;</div>
    <div><span class="xref">System.Collections.IList</span></div>
    <div><span class="xref">System.Collections.ICollection</span></div>
    <div><span class="xref">System.Collections.IEnumerable</span></div>
    <div><span class="xref">System.ICloneable</span></div>
  </div>
  <div class="inheritedMembers">
    <h5>Inherited Members</h5>
    <div>
      <a class="xref" href="Wintellect.PowerCollections.ListBase-1.html#Wintellect_PowerCollections_ListBase_1_Contains__0_">ListBase&lt;T&gt;.Contains(T)</a>
    </div>
    <div>
      <a class="xref" href="Wintellect.PowerCollections.ListBase-1.html#Wintellect_PowerCollections_ListBase_1_Remove__0_">ListBase&lt;T&gt;.Remove(T)</a>
    </div>
    <div>
      <a class="xref" href="Wintellect.PowerCollections.ListBase-1.html#Wintellect_PowerCollections_ListBase_1_CopyTo__0___">ListBase&lt;T&gt;.CopyTo(T[])</a>
    </div>
    <div>
      <a class="xref" href="Wintellect.PowerCollections.ListBase-1.html#Wintellect_PowerCollections_ListBase_1_CopyTo_System_Int32__0___System_Int32_System_Int32_">ListBase&lt;T&gt;.CopyTo(Int32, T[], Int32, Int32)</a>
    </div>
    <div>
      <a class="xref" href="Wintellect.PowerCollections.ListBase-1.html#Wintellect_PowerCollections_ListBase_1_AsReadOnly">ListBase&lt;T&gt;.AsReadOnly()</a>
    </div>
    <div>
      <a class="xref" href="Wintellect.PowerCollections.ListBase-1.html#Wintellect_PowerCollections_ListBase_1_Find_System_Predicate__0__">ListBase&lt;T&gt;.Find(Predicate&lt;T&gt;)</a>
    </div>
    <div>
      <a class="xref" href="Wintellect.PowerCollections.ListBase-1.html#Wintellect_PowerCollections_ListBase_1_TryFind_System_Predicate__0___0__">ListBase&lt;T&gt;.TryFind(Predicate&lt;T&gt;, T)</a>
    </div>
    <div>
      <a class="xref" href="Wintellect.PowerCollections.ListBase-1.html#Wintellect_PowerCollections_ListBase_1_FindLast_System_Predicate__0__">ListBase&lt;T&gt;.FindLast(Predicate&lt;T&gt;)</a>
    </div>
    <div>
      <a class="xref" href="Wintellect.PowerCollections.ListBase-1.html#Wintellect_PowerCollections_ListBase_1_TryFindLast_System_Predicate__0___0__">ListBase&lt;T&gt;.TryFindLast(Predicate&lt;T&gt;, T)</a>
    </div>
    <div>
      <a class="xref" href="Wintellect.PowerCollections.ListBase-1.html#Wintellect_PowerCollections_ListBase_1_FindIndex_System_Predicate__0__">ListBase&lt;T&gt;.FindIndex(Predicate&lt;T&gt;)</a>
    </div>
    <div>
      <a class="xref" href="Wintellect.PowerCollections.ListBase-1.html#Wintellect_PowerCollections_ListBase_1_FindIndex_System_Int32_System_Predicate__0__">ListBase&lt;T&gt;.FindIndex(Int32, Predicate&lt;T&gt;)</a>
    </div>
    <div>
      <a class="xref" href="Wintellect.PowerCollections.ListBase-1.html#Wintellect_PowerCollections_ListBase_1_FindIndex_System_Int32_System_Int32_System_Predicate__0__">ListBase&lt;T&gt;.FindIndex(Int32, Int32, Predicate&lt;T&gt;)</a>
    </div>
    <div>
      <a class="xref" href="Wintellect.PowerCollections.ListBase-1.html#Wintellect_PowerCollections_ListBase_1_FindLastIndex_System_Predicate__0__">ListBase&lt;T&gt;.FindLastIndex(Predicate&lt;T&gt;)</a>
    </div>
    <div>
      <a class="xref" href="Wintellect.PowerCollections.ListBase-1.html#Wintellect_PowerCollections_ListBase_1_FindLastIndex_System_Int32_System_Predicate__0__">ListBase&lt;T&gt;.FindLastIndex(Int32, Predicate&lt;T&gt;)</a>
    </div>
    <div>
      <a class="xref" href="Wintellect.PowerCollections.ListBase-1.html#Wintellect_PowerCollections_ListBase_1_FindLastIndex_System_Int32_System_Int32_System_Predicate__0__">ListBase&lt;T&gt;.FindLastIndex(Int32, Int32, Predicate&lt;T&gt;)</a>
    </div>
    <div>
      <a class="xref" href="Wintellect.PowerCollections.ListBase-1.html#Wintellect_PowerCollections_ListBase_1_IndexOf__0_">ListBase&lt;T&gt;.IndexOf(T)</a>
    </div>
    <div>
      <a class="xref" href="Wintellect.PowerCollections.ListBase-1.html#Wintellect_PowerCollections_ListBase_1_IndexOf__0_System_Int32_">ListBase&lt;T&gt;.IndexOf(T, Int32)</a>
    </div>
    <div>
      <a class="xref" href="Wintellect.PowerCollections.ListBase-1.html#Wintellect_PowerCollections_ListBase_1_IndexOf__0_System_Int32_System_Int32_">ListBase&lt;T&gt;.IndexOf(T, Int32, Int32)</a>
    </div>
    <div>
      <a class="xref" href="Wintellect.PowerCollections.ListBase-1.html#Wintellect_PowerCollections_ListBase_1_LastIndexOf__0_">ListBase&lt;T&gt;.LastIndexOf(T)</a>
    </div>
    <div>
      <a class="xref" href="Wintellect.PowerCollections.ListBase-1.html#Wintellect_PowerCollections_ListBase_1_LastIndexOf__0_System_Int32_">ListBase&lt;T&gt;.LastIndexOf(T, Int32)</a>
    </div>
    <div>
      <a class="xref" href="Wintellect.PowerCollections.ListBase-1.html#Wintellect_PowerCollections_ListBase_1_LastIndexOf__0_System_Int32_System_Int32_">ListBase&lt;T&gt;.LastIndexOf(T, Int32, Int32)</a>
    </div>
    <div>
      <a class="xref" href="Wintellect.PowerCollections.ListBase-1.html#Wintellect_PowerCollections_ListBase_1_Range_System_Int32_System_Int32_">ListBase&lt;T&gt;.Range(Int32, Int32)</a>
    </div>
    <div>
      <a class="xref" href="Wintellect.PowerCollections.ListBase-1.html#Wintellect_PowerCollections_ListBase_1_System_Collections_IList_Add_System_Object_">ListBase&lt;T&gt;.IList.Add(Object)</a>
    </div>
    <div>
      <a class="xref" href="Wintellect.PowerCollections.ListBase-1.html#Wintellect_PowerCollections_ListBase_1_System_Collections_IList_Clear">ListBase&lt;T&gt;.IList.Clear()</a>
    </div>
    <div>
      <a class="xref" href="Wintellect.PowerCollections.ListBase-1.html#Wintellect_PowerCollections_ListBase_1_System_Collections_IList_Contains_System_Object_">ListBase&lt;T&gt;.IList.Contains(Object)</a>
    </div>
    <div>
      <a class="xref" href="Wintellect.PowerCollections.ListBase-1.html#Wintellect_PowerCollections_ListBase_1_System_Collections_IList_IndexOf_System_Object_">ListBase&lt;T&gt;.IList.IndexOf(Object)</a>
    </div>
    <div>
      <a class="xref" href="Wintellect.PowerCollections.ListBase-1.html#Wintellect_PowerCollections_ListBase_1_System_Collections_IList_Insert_System_Int32_System_Object_">ListBase&lt;T&gt;.IList.Insert(Int32, Object)</a>
    </div>
    <div>
      <a class="xref" href="Wintellect.PowerCollections.ListBase-1.html#Wintellect_PowerCollections_ListBase_1_System_Collections_IList_IsFixedSize">ListBase&lt;T&gt;.IList.IsFixedSize</a>
    </div>
    <div>
      <a class="xref" href="Wintellect.PowerCollections.ListBase-1.html#Wintellect_PowerCollections_ListBase_1_System_Collections_IList_IsReadOnly">ListBase&lt;T&gt;.IList.IsReadOnly</a>
    </div>
    <div>
      <a class="xref" href="Wintellect.PowerCollections.ListBase-1.html#Wintellect_PowerCollections_ListBase_1_System_Collections_IList_Remove_System_Object_">ListBase&lt;T&gt;.IList.Remove(Object)</a>
    </div>
    <div>
      <a class="xref" href="Wintellect.PowerCollections.ListBase-1.html#Wintellect_PowerCollections_ListBase_1_System_Collections_IList_RemoveAt_System_Int32_">ListBase&lt;T&gt;.IList.RemoveAt(Int32)</a>
    </div>
    <div>
      <a class="xref" href="Wintellect.PowerCollections.ListBase-1.html#Wintellect_PowerCollections_ListBase_1_System_Collections_IList_Item_System_Int32_">ListBase&lt;T&gt;.IList.Item[Int32]</a>
    </div>
    <div>
      <a class="xref" href="Wintellect.PowerCollections.CollectionBase-1.html#Wintellect_PowerCollections_CollectionBase_1_ToString">CollectionBase&lt;T&gt;.ToString()</a>
    </div>
    <div>
      <a class="xref" href="Wintellect.PowerCollections.CollectionBase-1.html#Wintellect_PowerCollections_CollectionBase_1_ToArray">CollectionBase&lt;T&gt;.ToArray()</a>
    </div>
    <div>
      <a class="xref" href="Wintellect.PowerCollections.CollectionBase-1.html#Wintellect_PowerCollections_CollectionBase_1_System_Collections_Generic_ICollection_T__IsReadOnly">CollectionBase&lt;T&gt;.ICollection&lt;T&gt;.IsReadOnly</a>
    </div>
    <div>
      <a class="xref" href="Wintellect.PowerCollections.CollectionBase-1.html#Wintellect_PowerCollections_CollectionBase_1_Exists_System_Predicate__0__">CollectionBase&lt;T&gt;.Exists(Predicate&lt;T&gt;)</a>
    </div>
    <div>
      <a class="xref" href="Wintellect.PowerCollections.CollectionBase-1.html#Wintellect_PowerCollections_CollectionBase_1_TrueForAll_System_Predicate__0__">CollectionBase&lt;T&gt;.TrueForAll(Predicate&lt;T&gt;)</a>
    </div>
    <div>
      <a class="xref" href="Wintellect.PowerCollections.CollectionBase-1.html#Wintellect_PowerCollections_CollectionBase_1_CountWhere_System_Predicate__0__">CollectionBase&lt;T&gt;.CountWhere(Predicate&lt;T&gt;)</a>
    </div>
    <div>
      <a class="xref" href="Wintellect.PowerCollections.CollectionBase-1.html#Wintellect_PowerCollections_CollectionBase_1_FindAll_System_Predicate__0__">CollectionBase&lt;T&gt;.FindAll(Predicate&lt;T&gt;)</a>
    </div>
    <div>
      <a class="xref" href="Wintellect.PowerCollections.CollectionBase-1.html#Wintellect_PowerCollections_CollectionBase_1_RemoveAll_System_Predicate__0__">CollectionBase&lt;T&gt;.RemoveAll(Predicate&lt;T&gt;)</a>
    </div>
    <div>
      <a class="xref" href="Wintellect.PowerCollections.CollectionBase-1.html#Wintellect_PowerCollections_CollectionBase_1_ForEach_System_Action__0__">CollectionBase&lt;T&gt;.ForEach(Action&lt;T&gt;)</a>
    </div>
    <div>
      <a class="xref" href="Wintellect.PowerCollections.CollectionBase-1.html#Wintellect_PowerCollections_CollectionBase_1_ConvertAll__1_System_Converter__0___0__">CollectionBase&lt;T&gt;.ConvertAll&lt;TOutput&gt;(Converter&lt;T, TOutput&gt;)</a>
    </div>
    <div>
      <a class="xref" href="Wintellect.PowerCollections.CollectionBase-1.html#Wintellect_PowerCollections_CollectionBase_1_System_Collections_ICollection_CopyTo_System_Array_System_Int32_">CollectionBase&lt;T&gt;.ICollection.CopyTo(Array, Int32)</a>
    </div>
    <div>
      <a class="xref" href="Wintellect.PowerCollections.CollectionBase-1.html#Wintellect_PowerCollections_CollectionBase_1_System_Collections_ICollection_IsSynchronized">CollectionBase&lt;T&gt;.ICollection.IsSynchronized</a>
    </div>
    <div>
      <a class="xref" href="Wintellect.PowerCollections.CollectionBase-1.html#Wintellect_PowerCollections_CollectionBase_1_System_Collections_ICollection_SyncRoot">CollectionBase&lt;T&gt;.ICollection.SyncRoot</a>
    </div>
    <div>
      <a class="xref" href="Wintellect.PowerCollections.CollectionBase-1.html#Wintellect_PowerCollections_CollectionBase_1_System_Collections_IEnumerable_GetEnumerator">CollectionBase&lt;T&gt;.IEnumerable.GetEnumerator()</a>
    </div>
    <div>
      <span class="xref">System.Object.Equals(System.Object)</span>
    </div>
    <div>
      <span class="xref">System.Object.Equals(System.Object, System.Object)</span>
    </div>
    <div>
      <span class="xref">System.Object.ReferenceEquals(System.Object, System.Object)</span>
    </div>
    <div>
      <span class="xref">System.Object.GetHashCode()</span>
    </div>
    <div>
      <span class="xref">System.Object.GetType()</span>
    </div>
    <div>
      <span class="xref">System.Object.MemberwiseClone()</span>
    </div>
  </div>
  <h6><strong>Namespace</strong>: <a class="xref" href="Wintellect.PowerCollections.html">Wintellect.PowerCollections</a></h6>
  <h6><strong>Assembly</strong>: cs.temp.dll.dll</h6>
  <h5 id="Wintellect_PowerCollections_Deque_1_syntax">Syntax</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">[Serializable]
[Serializable]
public class Deque&lt;T&gt; : ListBase&lt;T&gt;, IList&lt;T&gt;, ICollection&lt;T&gt;, IEnumerable&lt;T&gt;, IList, ICollection, IEnumerable, ICloneable</code></pre>
  </div>
  <h5 class="typeParameters">Type Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="parametername">T</span></td>
        <td><p>The type of items stored in the Deque.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="Wintellect_PowerCollections_Deque_1_remarks"><strong>Remarks</strong></h5>
  <div class="markdown level0 remarks"><p>The Deque class can also be used as a more flexible alternative to the Queue 
and Stack classes. Deque is as efficient as Queue and Stack for adding or removing items, 
but is more flexible: it allows access
to all items in the queue, and allows adding or removing from either end.</p>
<p>Deque is implemented as a ring buffer, which is grown as necessary. The size
of the buffer is doubled whenever the existing capacity is too small to hold all the
elements.</p>
</div>
  <h3 id="constructors">Constructors
  </h3>
  
  
  <a id="Wintellect_PowerCollections_Deque_1__ctor_" data-uid="Wintellect.PowerCollections.Deque`1.#ctor*"></a>
  <h4 id="Wintellect_PowerCollections_Deque_1__ctor" data-uid="Wintellect.PowerCollections.Deque`1.#ctor">Deque()</h4>
  <div class="markdown level1 summary"><p>Create a new Deque that is initially empty.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public Deque()</code></pre>
  </div>
  
  
  <a id="Wintellect_PowerCollections_Deque_1__ctor_" data-uid="Wintellect.PowerCollections.Deque`1.#ctor*"></a>
  <h4 id="Wintellect_PowerCollections_Deque_1__ctor" data-uid="Wintellect.PowerCollections.Deque`1.#ctor">Deque()</h4>
  <div class="markdown level1 summary"><p>Create a new Deque that is initially empty.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public Deque()</code></pre>
  </div>
  
  
  <a id="Wintellect_PowerCollections_Deque_1__ctor_" data-uid="Wintellect.PowerCollections.Deque`1.#ctor*"></a>
  <h4 id="Wintellect_PowerCollections_Deque_1__ctor_System_Collections_Generic_IEnumerable__0__" data-uid="Wintellect.PowerCollections.Deque`1.#ctor(System.Collections.Generic.IEnumerable{`0})">Deque(IEnumerable&lt;T&gt;)</h4>
  <div class="markdown level1 summary"><p>Create a new Deque initialized with the items from the passed collection,
in order.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public Deque(IEnumerable&lt;T&gt; collection)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Collections.Generic.IEnumerable</span>&lt;T&gt;</td>
        <td><span class="parametername">collection</span></td>
        <td><p>A collection of items to initialize the Deque with.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Wintellect_PowerCollections_Deque_1__ctor_" data-uid="Wintellect.PowerCollections.Deque`1.#ctor*"></a>
  <h4 id="Wintellect_PowerCollections_Deque_1__ctor_System_Collections_Generic_IEnumerable__0__" data-uid="Wintellect.PowerCollections.Deque`1.#ctor(System.Collections.Generic.IEnumerable{`0})">Deque(IEnumerable&lt;T&gt;)</h4>
  <div class="markdown level1 summary"><p>Create a new Deque initialized with the items from the passed collection,
in order.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public Deque(IEnumerable&lt;T&gt; collection)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Collections.Generic.IEnumerable</span>&lt;T&gt;</td>
        <td><span class="parametername">collection</span></td>
        <td><p>A collection of items to initialize the Deque with.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h3 id="properties">Properties
  </h3>
  
  
  <a id="Wintellect_PowerCollections_Deque_1_Capacity_" data-uid="Wintellect.PowerCollections.Deque`1.Capacity*"></a>
  <h4 id="Wintellect_PowerCollections_Deque_1_Capacity" data-uid="Wintellect.PowerCollections.Deque`1.Capacity">Capacity</h4>
  <div class="markdown level1 summary"><p>Gets or sets the capacity of the Deque. The Capacity is the number of
items that this Deque can hold without expanding its internal buffer. Since
Deque will automatically expand its buffer when necessary, in almost all cases
it is unnecessary to worry about the capacity. However, if it is known that a
Deque will contain exactly 1000 items eventually, it can slightly improve
efficiency to set the capacity to 1000 up front, so that the Deque does not
have to expand automatically.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public int Capacity { get; set; }</code></pre>
  </div>
  <h5 class="propertyValue">Property Value</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Int32</span></td>
        <td><p>The number of items that this Deque can hold without expanding its
internal buffer.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="exceptions">Exceptions</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Condition</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.ArgumentOutOfRangeException</span></td>
        <td><p>The capacity is being set
to less than Count, or to too large a value.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Wintellect_PowerCollections_Deque_1_Capacity_" data-uid="Wintellect.PowerCollections.Deque`1.Capacity*"></a>
  <h4 id="Wintellect_PowerCollections_Deque_1_Capacity" data-uid="Wintellect.PowerCollections.Deque`1.Capacity">Capacity</h4>
  <div class="markdown level1 summary"><p>Gets or sets the capacity of the Deque. The Capacity is the number of
items that this Deque can hold without expanding its internal buffer. Since
Deque will automatically expand its buffer when necessary, in almost all cases
it is unnecessary to worry about the capacity. However, if it is known that a
Deque will contain exactly 1000 items eventually, it can slightly improve
efficiency to set the capacity to 1000 up front, so that the Deque does not
have to expand automatically.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public int Capacity { get; set; }</code></pre>
  </div>
  <h5 class="propertyValue">Property Value</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Int32</span></td>
        <td><p>The number of items that this Deque can hold without expanding its
internal buffer.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="exceptions">Exceptions</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Condition</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.ArgumentOutOfRangeException</span></td>
        <td><p>The capacity is being set
to less than Count, or to too large a value.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Wintellect_PowerCollections_Deque_1_Count_" data-uid="Wintellect.PowerCollections.Deque`1.Count*"></a>
  <h4 id="Wintellect_PowerCollections_Deque_1_Count" data-uid="Wintellect.PowerCollections.Deque`1.Count">Count</h4>
  <div class="markdown level1 summary"><p>Gets the number of items currently stored in the Deque. The last item
in the Deque has index Count-1.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public sealed override int Count { get; }</code></pre>
  </div>
  <h5 class="propertyValue">Property Value</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Int32</span></td>
        <td><p>The number of items stored in this Deque.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="overrides">Overrides</h5>
  <div><span class="xref">Wintellect.PowerCollections.ListBase&lt;T&gt;.Count</span></div>
  <h5 id="Wintellect_PowerCollections_Deque_1_Count_remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>Getting the count of items in the Deque takes a small constant
amount of time.</p>
</div>
  
  
  <a id="Wintellect_PowerCollections_Deque_1_Count_" data-uid="Wintellect.PowerCollections.Deque`1.Count*"></a>
  <h4 id="Wintellect_PowerCollections_Deque_1_Count" data-uid="Wintellect.PowerCollections.Deque`1.Count">Count</h4>
  <div class="markdown level1 summary"><p>Gets the number of items currently stored in the Deque. The last item
in the Deque has index Count-1.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public sealed override int Count { get; }</code></pre>
  </div>
  <h5 class="propertyValue">Property Value</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Int32</span></td>
        <td><p>The number of items stored in this Deque.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="overrides">Overrides</h5>
  <div><span class="xref">Wintellect.PowerCollections.ListBase&lt;T&gt;.Count</span></div>
  <h5 id="Wintellect_PowerCollections_Deque_1_Count_remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>Getting the count of items in the Deque takes a small constant
amount of time.</p>
</div>
  
  
  <a id="Wintellect_PowerCollections_Deque_1_Item_" data-uid="Wintellect.PowerCollections.Deque`1.Item*"></a>
  <h4 id="Wintellect_PowerCollections_Deque_1_Item_System_Int32_" data-uid="Wintellect.PowerCollections.Deque`1.Item(System.Int32)">Item[Int32]</h4>
  <div class="markdown level1 summary"><p>Gets or sets an item at a particular index in the Deque.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public sealed override T this[int index] { get; set; }</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Int32</span></td>
        <td><span class="parametername">index</span></td>
        <td><p>The index of the item to retrieve or change. The front item has index 0, and
the back item has index Count-1.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="propertyValue">Property Value</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">T</span></td>
        <td><p>The value at the indicated index.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="overrides">Overrides</h5>
  <div><span class="xref">Wintellect.PowerCollections.ListBase&lt;T&gt;.Item[System.Int32]</span></div>
  <h5 id="Wintellect_PowerCollections_Deque_1_Item_System_Int32__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>Getting or setting the item at a particular index takes a small constant amount
of time, no matter what index is used.</p>
</div>
  <h5 class="exceptions">Exceptions</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Condition</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.ArgumentOutOfRangeException</span></td>
        <td><p>The index is less than zero or greater than or equal
to Count.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Wintellect_PowerCollections_Deque_1_Item_" data-uid="Wintellect.PowerCollections.Deque`1.Item*"></a>
  <h4 id="Wintellect_PowerCollections_Deque_1_Item_System_Int32_" data-uid="Wintellect.PowerCollections.Deque`1.Item(System.Int32)">Item[Int32]</h4>
  <div class="markdown level1 summary"><p>Gets or sets an item at a particular index in the Deque.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public sealed override T this[int index] { get; set; }</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Int32</span></td>
        <td><span class="parametername">index</span></td>
        <td><p>The index of the item to retrieve or change. The front item has index 0, and
the back item has index Count-1.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="propertyValue">Property Value</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">T</span></td>
        <td><p>The value at the indicated index.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="overrides">Overrides</h5>
  <div><span class="xref">Wintellect.PowerCollections.ListBase&lt;T&gt;.Item[System.Int32]</span></div>
  <h5 id="Wintellect_PowerCollections_Deque_1_Item_System_Int32__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>Getting or setting the item at a particular index takes a small constant amount
of time, no matter what index is used.</p>
</div>
  <h5 class="exceptions">Exceptions</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Condition</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.ArgumentOutOfRangeException</span></td>
        <td><p>The index is less than zero or greater than or equal
to Count.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h3 id="methods">Methods
  </h3>
  
  
  <a id="Wintellect_PowerCollections_Deque_1_Add_" data-uid="Wintellect.PowerCollections.Deque`1.Add*"></a>
  <h4 id="Wintellect_PowerCollections_Deque_1_Add__0_" data-uid="Wintellect.PowerCollections.Deque`1.Add(`0)">Add(T)</h4>
  <div class="markdown level1 summary"><p>Adds an item to the back of the Deque. The indices of all existing items
in the Deque are unchanged. This method is
equivalent to <code>AddToBack(item)</code>.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public sealed override void Add(T item)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">T</span></td>
        <td><span class="parametername">item</span></td>
        <td><p>The item to add.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="overrides">Overrides</h5>
  <div><span class="xref">Wintellect.PowerCollections.ListBase&lt;T&gt;.Add(T)</span></div>
  <h5 id="Wintellect_PowerCollections_Deque_1_Add__0__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>Adding an item to the back of the Deque takes
a small constant amount of time, regardless of how many items are in the Deque.</p>
</div>
  
  
  <a id="Wintellect_PowerCollections_Deque_1_Add_" data-uid="Wintellect.PowerCollections.Deque`1.Add*"></a>
  <h4 id="Wintellect_PowerCollections_Deque_1_Add__0_" data-uid="Wintellect.PowerCollections.Deque`1.Add(`0)">Add(T)</h4>
  <div class="markdown level1 summary"><p>Adds an item to the back of the Deque. The indices of all existing items
in the Deque are unchanged. This method is
equivalent to <code>AddToBack(item)</code>.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public sealed override void Add(T item)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">T</span></td>
        <td><span class="parametername">item</span></td>
        <td><p>The item to add.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="overrides">Overrides</h5>
  <div><span class="xref">Wintellect.PowerCollections.ListBase&lt;T&gt;.Add(T)</span></div>
  <h5 id="Wintellect_PowerCollections_Deque_1_Add__0__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>Adding an item to the back of the Deque takes
a small constant amount of time, regardless of how many items are in the Deque.</p>
</div>
  
  
  <a id="Wintellect_PowerCollections_Deque_1_AddManyToBack_" data-uid="Wintellect.PowerCollections.Deque`1.AddManyToBack*"></a>
  <h4 id="Wintellect_PowerCollections_Deque_1_AddManyToBack_System_Collections_Generic_IEnumerable__0__" data-uid="Wintellect.PowerCollections.Deque`1.AddManyToBack(System.Collections.Generic.IEnumerable{`0})">AddManyToBack(IEnumerable&lt;T&gt;)</h4>
  <div class="markdown level1 summary"><p>Adds a collection of items to the back of the Deque. The indices of all existing items
in the Deque are unchanged. The last item in the added collection becomes the
last item in the Deque.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public void AddManyToBack(IEnumerable&lt;T&gt; collection)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Collections.Generic.IEnumerable</span>&lt;T&gt;</td>
        <td><span class="parametername">collection</span></td>
        <td><p>The collection of item to add.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="Wintellect_PowerCollections_Deque_1_AddManyToBack_System_Collections_Generic_IEnumerable__0___remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>This method takes time O(M), where M is the number of items in the
<code data-dev-comment-type="paramref" class="paramref">collection</code>.</p>
</div>
  
  
  <a id="Wintellect_PowerCollections_Deque_1_AddManyToBack_" data-uid="Wintellect.PowerCollections.Deque`1.AddManyToBack*"></a>
  <h4 id="Wintellect_PowerCollections_Deque_1_AddManyToBack_System_Collections_Generic_IEnumerable__0__" data-uid="Wintellect.PowerCollections.Deque`1.AddManyToBack(System.Collections.Generic.IEnumerable{`0})">AddManyToBack(IEnumerable&lt;T&gt;)</h4>
  <div class="markdown level1 summary"><p>Adds a collection of items to the back of the Deque. The indices of all existing items
in the Deque are unchanged. The last item in the added collection becomes the
last item in the Deque.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public void AddManyToBack(IEnumerable&lt;T&gt; collection)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Collections.Generic.IEnumerable</span>&lt;T&gt;</td>
        <td><span class="parametername">collection</span></td>
        <td><p>The collection of item to add.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="Wintellect_PowerCollections_Deque_1_AddManyToBack_System_Collections_Generic_IEnumerable__0___remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>This method takes time O(M), where M is the number of items in the
<code data-dev-comment-type="paramref" class="paramref">collection</code>.</p>
</div>
  
  
  <a id="Wintellect_PowerCollections_Deque_1_AddManyToFront_" data-uid="Wintellect.PowerCollections.Deque`1.AddManyToFront*"></a>
  <h4 id="Wintellect_PowerCollections_Deque_1_AddManyToFront_System_Collections_Generic_IEnumerable__0__" data-uid="Wintellect.PowerCollections.Deque`1.AddManyToFront(System.Collections.Generic.IEnumerable{`0})">AddManyToFront(IEnumerable&lt;T&gt;)</h4>
  <div class="markdown level1 summary"><p>Adds a collection of items to the front of the Deque. The indices of all existing items
in the Deque are increased by the number of items inserted. The first item in the added collection becomes the
first item in the Deque.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public void AddManyToFront(IEnumerable&lt;T&gt; collection)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Collections.Generic.IEnumerable</span>&lt;T&gt;</td>
        <td><span class="parametername">collection</span></td>
        <td><p>The collection of items to add.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="Wintellect_PowerCollections_Deque_1_AddManyToFront_System_Collections_Generic_IEnumerable__0___remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>This method takes time O(M), where M is the number of items in the
<code data-dev-comment-type="paramref" class="paramref">collection</code>.</p>
</div>
  
  
  <a id="Wintellect_PowerCollections_Deque_1_AddManyToFront_" data-uid="Wintellect.PowerCollections.Deque`1.AddManyToFront*"></a>
  <h4 id="Wintellect_PowerCollections_Deque_1_AddManyToFront_System_Collections_Generic_IEnumerable__0__" data-uid="Wintellect.PowerCollections.Deque`1.AddManyToFront(System.Collections.Generic.IEnumerable{`0})">AddManyToFront(IEnumerable&lt;T&gt;)</h4>
  <div class="markdown level1 summary"><p>Adds a collection of items to the front of the Deque. The indices of all existing items
in the Deque are increased by the number of items inserted. The first item in the added collection becomes the
first item in the Deque.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public void AddManyToFront(IEnumerable&lt;T&gt; collection)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Collections.Generic.IEnumerable</span>&lt;T&gt;</td>
        <td><span class="parametername">collection</span></td>
        <td><p>The collection of items to add.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="Wintellect_PowerCollections_Deque_1_AddManyToFront_System_Collections_Generic_IEnumerable__0___remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>This method takes time O(M), where M is the number of items in the
<code data-dev-comment-type="paramref" class="paramref">collection</code>.</p>
</div>
  
  
  <a id="Wintellect_PowerCollections_Deque_1_AddToBack_" data-uid="Wintellect.PowerCollections.Deque`1.AddToBack*"></a>
  <h4 id="Wintellect_PowerCollections_Deque_1_AddToBack__0_" data-uid="Wintellect.PowerCollections.Deque`1.AddToBack(`0)">AddToBack(T)</h4>
  <div class="markdown level1 summary"><p>Adds an item to the back of the Deque. The indices of all existing items
in the Deque are unchanged. This method is
equivalent to <code>Insert(Count, item)</code> but is a little more
efficient.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public void AddToBack(T item)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">T</span></td>
        <td><span class="parametername">item</span></td>
        <td><p>The item to add.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="Wintellect_PowerCollections_Deque_1_AddToBack__0__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>Adding an item to the back of the Deque takes
a small constant amount of time, regardless of how many items are in the Deque.</p>
</div>
  
  
  <a id="Wintellect_PowerCollections_Deque_1_AddToBack_" data-uid="Wintellect.PowerCollections.Deque`1.AddToBack*"></a>
  <h4 id="Wintellect_PowerCollections_Deque_1_AddToBack__0_" data-uid="Wintellect.PowerCollections.Deque`1.AddToBack(`0)">AddToBack(T)</h4>
  <div class="markdown level1 summary"><p>Adds an item to the back of the Deque. The indices of all existing items
in the Deque are unchanged. This method is
equivalent to <code>Insert(Count, item)</code> but is a little more
efficient.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public void AddToBack(T item)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">T</span></td>
        <td><span class="parametername">item</span></td>
        <td><p>The item to add.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="Wintellect_PowerCollections_Deque_1_AddToBack__0__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>Adding an item to the back of the Deque takes
a small constant amount of time, regardless of how many items are in the Deque.</p>
</div>
  
  
  <a id="Wintellect_PowerCollections_Deque_1_AddToFront_" data-uid="Wintellect.PowerCollections.Deque`1.AddToFront*"></a>
  <h4 id="Wintellect_PowerCollections_Deque_1_AddToFront__0_" data-uid="Wintellect.PowerCollections.Deque`1.AddToFront(`0)">AddToFront(T)</h4>
  <div class="markdown level1 summary"><p>Adds an item to the front of the Deque. The indices of all existing items
in the Deque are increased by 1. This method is
equivalent to <code>Insert(0, item)</code> but is a little more
efficient.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public void AddToFront(T item)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">T</span></td>
        <td><span class="parametername">item</span></td>
        <td><p>The item to add.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="Wintellect_PowerCollections_Deque_1_AddToFront__0__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>Adding an item to the front of the Deque takes
a small constant amount of time, regardless of how many items are in the Deque.</p>
</div>
  
  
  <a id="Wintellect_PowerCollections_Deque_1_AddToFront_" data-uid="Wintellect.PowerCollections.Deque`1.AddToFront*"></a>
  <h4 id="Wintellect_PowerCollections_Deque_1_AddToFront__0_" data-uid="Wintellect.PowerCollections.Deque`1.AddToFront(`0)">AddToFront(T)</h4>
  <div class="markdown level1 summary"><p>Adds an item to the front of the Deque. The indices of all existing items
in the Deque are increased by 1. This method is
equivalent to <code>Insert(0, item)</code> but is a little more
efficient.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public void AddToFront(T item)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">T</span></td>
        <td><span class="parametername">item</span></td>
        <td><p>The item to add.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="Wintellect_PowerCollections_Deque_1_AddToFront__0__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>Adding an item to the front of the Deque takes
a small constant amount of time, regardless of how many items are in the Deque.</p>
</div>
  
  
  <a id="Wintellect_PowerCollections_Deque_1_Clear_" data-uid="Wintellect.PowerCollections.Deque`1.Clear*"></a>
  <h4 id="Wintellect_PowerCollections_Deque_1_Clear" data-uid="Wintellect.PowerCollections.Deque`1.Clear">Clear()</h4>
  <div class="markdown level1 summary"><p>Removes all items from the Deque.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public sealed override void Clear()</code></pre>
  </div>
  <h5 class="overrides">Overrides</h5>
  <div><span class="xref">Wintellect.PowerCollections.ListBase&lt;T&gt;.Clear()</span></div>
  <h5 id="Wintellect_PowerCollections_Deque_1_Clear_remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>Clearing the Deque takes a small constant amount of time, regardless of
how many items are currently in the Deque.</p>
</div>
  
  
  <a id="Wintellect_PowerCollections_Deque_1_Clear_" data-uid="Wintellect.PowerCollections.Deque`1.Clear*"></a>
  <h4 id="Wintellect_PowerCollections_Deque_1_Clear" data-uid="Wintellect.PowerCollections.Deque`1.Clear">Clear()</h4>
  <div class="markdown level1 summary"><p>Removes all items from the Deque.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public sealed override void Clear()</code></pre>
  </div>
  <h5 class="overrides">Overrides</h5>
  <div><span class="xref">Wintellect.PowerCollections.ListBase&lt;T&gt;.Clear()</span></div>
  <h5 id="Wintellect_PowerCollections_Deque_1_Clear_remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>Clearing the Deque takes a small constant amount of time, regardless of
how many items are currently in the Deque.</p>
</div>
  
  
  <a id="Wintellect_PowerCollections_Deque_1_Clone_" data-uid="Wintellect.PowerCollections.Deque`1.Clone*"></a>
  <h4 id="Wintellect_PowerCollections_Deque_1_Clone" data-uid="Wintellect.PowerCollections.Deque`1.Clone">Clone()</h4>
  <div class="markdown level1 summary"><p>Creates a new Deque that is a copy of this one.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public Deque&lt;T&gt; Clone()</code></pre>
  </div>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Wintellect.PowerCollections.Deque-1.html">Deque</a>&lt;T&gt;</td>
        <td><p>A copy of the current deque.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="Wintellect_PowerCollections_Deque_1_Clone_remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>Copying a Deque takes O(N) time, where N is the number of items in this Deque..</p>
</div>
  
  
  <a id="Wintellect_PowerCollections_Deque_1_Clone_" data-uid="Wintellect.PowerCollections.Deque`1.Clone*"></a>
  <h4 id="Wintellect_PowerCollections_Deque_1_Clone" data-uid="Wintellect.PowerCollections.Deque`1.Clone">Clone()</h4>
  <div class="markdown level1 summary"><p>Creates a new Deque that is a copy of this one.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public Deque&lt;T&gt; Clone()</code></pre>
  </div>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Wintellect.PowerCollections.Deque-1.html">Deque</a>&lt;T&gt;</td>
        <td><p>A copy of the current deque.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="Wintellect_PowerCollections_Deque_1_Clone_remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>Copying a Deque takes O(N) time, where N is the number of items in this Deque..</p>
</div>
  
  
  <a id="Wintellect_PowerCollections_Deque_1_CloneContents_" data-uid="Wintellect.PowerCollections.Deque`1.CloneContents*"></a>
  <h4 id="Wintellect_PowerCollections_Deque_1_CloneContents" data-uid="Wintellect.PowerCollections.Deque`1.CloneContents">CloneContents()</h4>
  <div class="markdown level1 summary"><p>Makes a deep clone of this Deque. A new Deque is created with a clone of
each element of this set, by calling ICloneable.Clone on each element. If T is
a value type, then each element is copied as if by simple assignment.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public Deque&lt;T&gt; CloneContents()</code></pre>
  </div>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Wintellect.PowerCollections.Deque-1.html">Deque</a>&lt;T&gt;</td>
        <td><p>The cloned Deque.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="Wintellect_PowerCollections_Deque_1_CloneContents_remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>If T is a reference type, it must implement
    ICloneable. Otherwise, an InvalidOperationException is thrown.</p>
<p>Cloning the Deque takes time O(N), where N is the number of items in the Deque.</p>
</div>
  <h5 class="exceptions">Exceptions</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Condition</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.InvalidOperationException</span></td>
        <td><p>T is a reference type that does not implement ICloneable.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Wintellect_PowerCollections_Deque_1_CloneContents_" data-uid="Wintellect.PowerCollections.Deque`1.CloneContents*"></a>
  <h4 id="Wintellect_PowerCollections_Deque_1_CloneContents" data-uid="Wintellect.PowerCollections.Deque`1.CloneContents">CloneContents()</h4>
  <div class="markdown level1 summary"><p>Makes a deep clone of this Deque. A new Deque is created with a clone of
each element of this set, by calling ICloneable.Clone on each element. If T is
a value type, then each element is copied as if by simple assignment.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public Deque&lt;T&gt; CloneContents()</code></pre>
  </div>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><a class="xref" href="Wintellect.PowerCollections.Deque-1.html">Deque</a>&lt;T&gt;</td>
        <td><p>The cloned Deque.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="Wintellect_PowerCollections_Deque_1_CloneContents_remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>If T is a reference type, it must implement
    ICloneable. Otherwise, an InvalidOperationException is thrown.</p>
<p>Cloning the Deque takes time O(N), where N is the number of items in the Deque.</p>
</div>
  <h5 class="exceptions">Exceptions</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Condition</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.InvalidOperationException</span></td>
        <td><p>T is a reference type that does not implement ICloneable.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Wintellect_PowerCollections_Deque_1_CopyTo_" data-uid="Wintellect.PowerCollections.Deque`1.CopyTo*"></a>
  <h4 id="Wintellect_PowerCollections_Deque_1_CopyTo__0___System_Int32_" data-uid="Wintellect.PowerCollections.Deque`1.CopyTo(`0[],System.Int32)">CopyTo(T[], Int32)</h4>
  <div class="markdown level1 summary"><p>Copies all the items in the Deque into an array.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public sealed override void CopyTo(T[] array, int arrayIndex)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td>T[]</td>
        <td><span class="parametername">array</span></td>
        <td><p>Array to copy to.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Int32</span></td>
        <td><span class="parametername">arrayIndex</span></td>
        <td><p>Starting index in <code data-dev-comment-type="paramref" class="paramref">array</code> to copy to.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="overrides">Overrides</h5>
  <div><span class="xref">Wintellect.PowerCollections.CollectionBase&lt;T&gt;.CopyTo(T[], System.Int32)</span></div>
  
  
  <a id="Wintellect_PowerCollections_Deque_1_CopyTo_" data-uid="Wintellect.PowerCollections.Deque`1.CopyTo*"></a>
  <h4 id="Wintellect_PowerCollections_Deque_1_CopyTo__0___System_Int32_" data-uid="Wintellect.PowerCollections.Deque`1.CopyTo(`0[],System.Int32)">CopyTo(T[], Int32)</h4>
  <div class="markdown level1 summary"><p>Copies all the items in the Deque into an array.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public sealed override void CopyTo(T[] array, int arrayIndex)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td>T[]</td>
        <td><span class="parametername">array</span></td>
        <td><p>Array to copy to.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Int32</span></td>
        <td><span class="parametername">arrayIndex</span></td>
        <td><p>Starting index in <code data-dev-comment-type="paramref" class="paramref">array</code> to copy to.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="overrides">Overrides</h5>
  <div><span class="xref">Wintellect.PowerCollections.CollectionBase&lt;T&gt;.CopyTo(T[], System.Int32)</span></div>
  
  
  <a id="Wintellect_PowerCollections_Deque_1_GetAtBack_" data-uid="Wintellect.PowerCollections.Deque`1.GetAtBack*"></a>
  <h4 id="Wintellect_PowerCollections_Deque_1_GetAtBack" data-uid="Wintellect.PowerCollections.Deque`1.GetAtBack">GetAtBack()</h4>
  <div class="markdown level1 summary"><p>Retreives the item currently at the back of the Deque. The Deque is
unchanged. This method is
equivalent to <code>deque[deque.Count - 1]</code> (except that a different exception is thrown).</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public T GetAtBack()</code></pre>
  </div>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">T</span></td>
        <td><p>The item at the back of the Deque.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="Wintellect_PowerCollections_Deque_1_GetAtBack_remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>Retreiving the item at the back of the Deque takes
a small constant amount of time, regardless of how many items are in the Deque.</p>
</div>
  <h5 class="exceptions">Exceptions</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Condition</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.InvalidOperationException</span></td>
        <td><p>The Deque is empty.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Wintellect_PowerCollections_Deque_1_GetAtBack_" data-uid="Wintellect.PowerCollections.Deque`1.GetAtBack*"></a>
  <h4 id="Wintellect_PowerCollections_Deque_1_GetAtBack" data-uid="Wintellect.PowerCollections.Deque`1.GetAtBack">GetAtBack()</h4>
  <div class="markdown level1 summary"><p>Retreives the item currently at the back of the Deque. The Deque is
unchanged. This method is
equivalent to <code>deque[deque.Count - 1]</code> (except that a different exception is thrown).</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public T GetAtBack()</code></pre>
  </div>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">T</span></td>
        <td><p>The item at the back of the Deque.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="Wintellect_PowerCollections_Deque_1_GetAtBack_remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>Retreiving the item at the back of the Deque takes
a small constant amount of time, regardless of how many items are in the Deque.</p>
</div>
  <h5 class="exceptions">Exceptions</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Condition</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.InvalidOperationException</span></td>
        <td><p>The Deque is empty.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Wintellect_PowerCollections_Deque_1_GetAtFront_" data-uid="Wintellect.PowerCollections.Deque`1.GetAtFront*"></a>
  <h4 id="Wintellect_PowerCollections_Deque_1_GetAtFront" data-uid="Wintellect.PowerCollections.Deque`1.GetAtFront">GetAtFront()</h4>
  <div class="markdown level1 summary"><p>Retreives the item currently at the front of the Deque. The Deque is
unchanged. This method is
equivalent to <code>deque[0]</code> (except that a different exception is thrown).</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public T GetAtFront()</code></pre>
  </div>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">T</span></td>
        <td><p>The item at the front of the Deque.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="Wintellect_PowerCollections_Deque_1_GetAtFront_remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>Retreiving the item at the front of the Deque takes
a small constant amount of time, regardless of how many items are in the Deque.</p>
</div>
  <h5 class="exceptions">Exceptions</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Condition</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.InvalidOperationException</span></td>
        <td><p>The Deque is empty.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Wintellect_PowerCollections_Deque_1_GetAtFront_" data-uid="Wintellect.PowerCollections.Deque`1.GetAtFront*"></a>
  <h4 id="Wintellect_PowerCollections_Deque_1_GetAtFront" data-uid="Wintellect.PowerCollections.Deque`1.GetAtFront">GetAtFront()</h4>
  <div class="markdown level1 summary"><p>Retreives the item currently at the front of the Deque. The Deque is
unchanged. This method is
equivalent to <code>deque[0]</code> (except that a different exception is thrown).</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public T GetAtFront()</code></pre>
  </div>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">T</span></td>
        <td><p>The item at the front of the Deque.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="Wintellect_PowerCollections_Deque_1_GetAtFront_remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>Retreiving the item at the front of the Deque takes
a small constant amount of time, regardless of how many items are in the Deque.</p>
</div>
  <h5 class="exceptions">Exceptions</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Condition</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.InvalidOperationException</span></td>
        <td><p>The Deque is empty.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Wintellect_PowerCollections_Deque_1_GetEnumerator_" data-uid="Wintellect.PowerCollections.Deque`1.GetEnumerator*"></a>
  <h4 id="Wintellect_PowerCollections_Deque_1_GetEnumerator" data-uid="Wintellect.PowerCollections.Deque`1.GetEnumerator">GetEnumerator()</h4>
  <div class="markdown level1 summary"><p>Enumerates all of the items in the list, in order. The item at index 0
is enumerated first, then the item at index 1, and so on. If the items
are added to or removed from the Deque during enumeration, the
enumeration ends with an InvalidOperationException.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public sealed override IEnumerator&lt;T&gt; GetEnumerator()</code></pre>
  </div>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Collections.Generic.IEnumerator</span>&lt;T&gt;</td>
        <td><p>An IEnumerator&lt;T&gt; that enumerates all the
items in the list.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="overrides">Overrides</h5>
  <div><span class="xref">Wintellect.PowerCollections.ListBase&lt;T&gt;.GetEnumerator()</span></div>
  <h5 class="exceptions">Exceptions</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Condition</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.InvalidOperationException</span></td>
        <td><p>The Deque has an item added or deleted during the enumeration.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Wintellect_PowerCollections_Deque_1_GetEnumerator_" data-uid="Wintellect.PowerCollections.Deque`1.GetEnumerator*"></a>
  <h4 id="Wintellect_PowerCollections_Deque_1_GetEnumerator" data-uid="Wintellect.PowerCollections.Deque`1.GetEnumerator">GetEnumerator()</h4>
  <div class="markdown level1 summary"><p>Enumerates all of the items in the list, in order. The item at index 0
is enumerated first, then the item at index 1, and so on. If the items
are added to or removed from the Deque during enumeration, the
enumeration ends with an InvalidOperationException.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public sealed override IEnumerator&lt;T&gt; GetEnumerator()</code></pre>
  </div>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Collections.Generic.IEnumerator</span>&lt;T&gt;</td>
        <td><p>An IEnumerator&lt;T&gt; that enumerates all the
items in the list.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="overrides">Overrides</h5>
  <div><span class="xref">Wintellect.PowerCollections.ListBase&lt;T&gt;.GetEnumerator()</span></div>
  <h5 class="exceptions">Exceptions</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Condition</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.InvalidOperationException</span></td>
        <td><p>The Deque has an item added or deleted during the enumeration.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Wintellect_PowerCollections_Deque_1_Insert_" data-uid="Wintellect.PowerCollections.Deque`1.Insert*"></a>
  <h4 id="Wintellect_PowerCollections_Deque_1_Insert_System_Int32__0_" data-uid="Wintellect.PowerCollections.Deque`1.Insert(System.Int32,`0)">Insert(Int32, T)</h4>
  <div class="markdown level1 summary"><p>Inserts a new item at the given index in the Deque. All items at indexes
equal to or greater than <code data-dev-comment-type="paramref" class="paramref">index</code> move up one index
in the Deque.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public sealed override void Insert(int index, T item)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Int32</span></td>
        <td><span class="parametername">index</span></td>
        <td><p>The index in the Deque to insert the item at. After the
insertion, the inserted item is located at this index. The
front item in the Deque has index 0.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">T</span></td>
        <td><span class="parametername">item</span></td>
        <td><p>The item to insert at the given index.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="overrides">Overrides</h5>
  <div><span class="xref">Wintellect.PowerCollections.ListBase&lt;T&gt;.Insert(System.Int32, T)</span></div>
  <h5 id="Wintellect_PowerCollections_Deque_1_Insert_System_Int32__0__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>The amount of time to insert an item in the Deque is proportional
to the distance of index from the closest end of the Deque:
O(Min(<code data-dev-comment-type="paramref" class="paramref">index</code>, Count - <code data-dev-comment-type="paramref" class="paramref">index</code>)).
Thus, inserting an item at the front or end of the Deque is always fast; the middle of
of the Deque is the slowest place to insert.</p>
</div>
  <h5 class="exceptions">Exceptions</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Condition</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.ArgumentOutOfRangeException</span></td>
        <td><p><code data-dev-comment-type="paramref" class="paramref">index</code> is
less than zero or greater than Count.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Wintellect_PowerCollections_Deque_1_Insert_" data-uid="Wintellect.PowerCollections.Deque`1.Insert*"></a>
  <h4 id="Wintellect_PowerCollections_Deque_1_Insert_System_Int32__0_" data-uid="Wintellect.PowerCollections.Deque`1.Insert(System.Int32,`0)">Insert(Int32, T)</h4>
  <div class="markdown level1 summary"><p>Inserts a new item at the given index in the Deque. All items at indexes
equal to or greater than <code data-dev-comment-type="paramref" class="paramref">index</code> move up one index
in the Deque.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public sealed override void Insert(int index, T item)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Int32</span></td>
        <td><span class="parametername">index</span></td>
        <td><p>The index in the Deque to insert the item at. After the
insertion, the inserted item is located at this index. The
front item in the Deque has index 0.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">T</span></td>
        <td><span class="parametername">item</span></td>
        <td><p>The item to insert at the given index.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="overrides">Overrides</h5>
  <div><span class="xref">Wintellect.PowerCollections.ListBase&lt;T&gt;.Insert(System.Int32, T)</span></div>
  <h5 id="Wintellect_PowerCollections_Deque_1_Insert_System_Int32__0__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>The amount of time to insert an item in the Deque is proportional
to the distance of index from the closest end of the Deque:
O(Min(<code data-dev-comment-type="paramref" class="paramref">index</code>, Count - <code data-dev-comment-type="paramref" class="paramref">index</code>)).
Thus, inserting an item at the front or end of the Deque is always fast; the middle of
of the Deque is the slowest place to insert.</p>
</div>
  <h5 class="exceptions">Exceptions</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Condition</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.ArgumentOutOfRangeException</span></td>
        <td><p><code data-dev-comment-type="paramref" class="paramref">index</code> is
less than zero or greater than Count.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Wintellect_PowerCollections_Deque_1_InsertRange_" data-uid="Wintellect.PowerCollections.Deque`1.InsertRange*"></a>
  <h4 id="Wintellect_PowerCollections_Deque_1_InsertRange_System_Int32_System_Collections_Generic_IEnumerable__0__" data-uid="Wintellect.PowerCollections.Deque`1.InsertRange(System.Int32,System.Collections.Generic.IEnumerable{`0})">InsertRange(Int32, IEnumerable&lt;T&gt;)</h4>
  <div class="markdown level1 summary"><p>Inserts a collection of items at the given index in the Deque. All items at indexes
equal to or greater than <code data-dev-comment-type="paramref" class="paramref">index</code> increase their indices in the Deque
by the number of items inserted.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public void InsertRange(int index, IEnumerable&lt;T&gt; collection)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Int32</span></td>
        <td><span class="parametername">index</span></td>
        <td><p>The index in the Deque to insert the collection at. After the
insertion, the first item of the inserted collection is located at this index. The
front item in the Deque has index 0.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Collections.Generic.IEnumerable</span>&lt;T&gt;</td>
        <td><span class="parametername">collection</span></td>
        <td><p>The collection of items to insert at the given index.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="Wintellect_PowerCollections_Deque_1_InsertRange_System_Int32_System_Collections_Generic_IEnumerable__0___remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>The amount of time to insert a collection in the Deque is proportional
to the distance of index from the closest end of the Deque, plus the number of items
inserted (M):
O(M + Min(<code data-dev-comment-type="paramref" class="paramref">index</code>, Count - <code data-dev-comment-type="paramref" class="paramref">index</code>)).</p>
</div>
  <h5 class="exceptions">Exceptions</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Condition</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.ArgumentOutOfRangeException</span></td>
        <td><p><code data-dev-comment-type="paramref" class="paramref">index</code> is
less than zero or greater than Count.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Wintellect_PowerCollections_Deque_1_InsertRange_" data-uid="Wintellect.PowerCollections.Deque`1.InsertRange*"></a>
  <h4 id="Wintellect_PowerCollections_Deque_1_InsertRange_System_Int32_System_Collections_Generic_IEnumerable__0__" data-uid="Wintellect.PowerCollections.Deque`1.InsertRange(System.Int32,System.Collections.Generic.IEnumerable{`0})">InsertRange(Int32, IEnumerable&lt;T&gt;)</h4>
  <div class="markdown level1 summary"><p>Inserts a collection of items at the given index in the Deque. All items at indexes
equal to or greater than <code data-dev-comment-type="paramref" class="paramref">index</code> increase their indices in the Deque
by the number of items inserted.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public void InsertRange(int index, IEnumerable&lt;T&gt; collection)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Int32</span></td>
        <td><span class="parametername">index</span></td>
        <td><p>The index in the Deque to insert the collection at. After the
insertion, the first item of the inserted collection is located at this index. The
front item in the Deque has index 0.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Collections.Generic.IEnumerable</span>&lt;T&gt;</td>
        <td><span class="parametername">collection</span></td>
        <td><p>The collection of items to insert at the given index.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="Wintellect_PowerCollections_Deque_1_InsertRange_System_Int32_System_Collections_Generic_IEnumerable__0___remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>The amount of time to insert a collection in the Deque is proportional
to the distance of index from the closest end of the Deque, plus the number of items
inserted (M):
O(M + Min(<code data-dev-comment-type="paramref" class="paramref">index</code>, Count - <code data-dev-comment-type="paramref" class="paramref">index</code>)).</p>
</div>
  <h5 class="exceptions">Exceptions</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Condition</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.ArgumentOutOfRangeException</span></td>
        <td><p><code data-dev-comment-type="paramref" class="paramref">index</code> is
less than zero or greater than Count.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Wintellect_PowerCollections_Deque_1_RemoveAt_" data-uid="Wintellect.PowerCollections.Deque`1.RemoveAt*"></a>
  <h4 id="Wintellect_PowerCollections_Deque_1_RemoveAt_System_Int32_" data-uid="Wintellect.PowerCollections.Deque`1.RemoveAt(System.Int32)">RemoveAt(Int32)</h4>
  <div class="markdown level1 summary"><p>Removes the item at the given index in the Deque. All items at indexes
greater than <code data-dev-comment-type="paramref" class="paramref">index</code> move down one index
in the Deque.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public sealed override void RemoveAt(int index)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Int32</span></td>
        <td><span class="parametername">index</span></td>
        <td><p>The index in the list to remove the item at. The
first item in the list has index 0.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="overrides">Overrides</h5>
  <div><span class="xref">Wintellect.PowerCollections.ListBase&lt;T&gt;.RemoveAt(System.Int32)</span></div>
  <h5 id="Wintellect_PowerCollections_Deque_1_RemoveAt_System_Int32__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>The amount of time to delete an item in the Deque is proportional
to the distance of index from the closest end of the Deque:
O(Min(<code data-dev-comment-type="paramref" class="paramref">index</code>, Count - 1 - <code data-dev-comment-type="paramref" class="paramref">index</code>)).
Thus, deleting an item at the front or end of the Deque is always fast; the middle of
of the Deque is the slowest place to delete.</p>
</div>
  <h5 class="exceptions">Exceptions</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Condition</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.ArgumentOutOfRangeException</span></td>
        <td><p><code data-dev-comment-type="paramref" class="paramref">index</code> is
less than zero or greater than or equal to Count.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Wintellect_PowerCollections_Deque_1_RemoveAt_" data-uid="Wintellect.PowerCollections.Deque`1.RemoveAt*"></a>
  <h4 id="Wintellect_PowerCollections_Deque_1_RemoveAt_System_Int32_" data-uid="Wintellect.PowerCollections.Deque`1.RemoveAt(System.Int32)">RemoveAt(Int32)</h4>
  <div class="markdown level1 summary"><p>Removes the item at the given index in the Deque. All items at indexes
greater than <code data-dev-comment-type="paramref" class="paramref">index</code> move down one index
in the Deque.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public sealed override void RemoveAt(int index)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Int32</span></td>
        <td><span class="parametername">index</span></td>
        <td><p>The index in the list to remove the item at. The
first item in the list has index 0.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 class="overrides">Overrides</h5>
  <div><span class="xref">Wintellect.PowerCollections.ListBase&lt;T&gt;.RemoveAt(System.Int32)</span></div>
  <h5 id="Wintellect_PowerCollections_Deque_1_RemoveAt_System_Int32__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>The amount of time to delete an item in the Deque is proportional
to the distance of index from the closest end of the Deque:
O(Min(<code data-dev-comment-type="paramref" class="paramref">index</code>, Count - 1 - <code data-dev-comment-type="paramref" class="paramref">index</code>)).
Thus, deleting an item at the front or end of the Deque is always fast; the middle of
of the Deque is the slowest place to delete.</p>
</div>
  <h5 class="exceptions">Exceptions</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Condition</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.ArgumentOutOfRangeException</span></td>
        <td><p><code data-dev-comment-type="paramref" class="paramref">index</code> is
less than zero or greater than or equal to Count.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Wintellect_PowerCollections_Deque_1_RemoveFromBack_" data-uid="Wintellect.PowerCollections.Deque`1.RemoveFromBack*"></a>
  <h4 id="Wintellect_PowerCollections_Deque_1_RemoveFromBack" data-uid="Wintellect.PowerCollections.Deque`1.RemoveFromBack">RemoveFromBack()</h4>
  <div class="markdown level1 summary"><p>Removes an item from the back of the Deque. The indices of all existing items
in the Deque are unchanged. This method is
equivalent to <code>RemoveAt(Count-1)</code> but is a little more
efficient.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public T RemoveFromBack()</code></pre>
  </div>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">T</span></td>
        <td></td>
      </tr>
    </tbody>
  </table>
  <h5 id="Wintellect_PowerCollections_Deque_1_RemoveFromBack_remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>Removing an item from the back of the Deque takes
a small constant amount of time, regardless of how many items are in the Deque.</p>
</div>
  <h5 class="exceptions">Exceptions</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Condition</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.InvalidOperationException</span></td>
        <td><p>The Deque is empty.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Wintellect_PowerCollections_Deque_1_RemoveFromBack_" data-uid="Wintellect.PowerCollections.Deque`1.RemoveFromBack*"></a>
  <h4 id="Wintellect_PowerCollections_Deque_1_RemoveFromBack" data-uid="Wintellect.PowerCollections.Deque`1.RemoveFromBack">RemoveFromBack()</h4>
  <div class="markdown level1 summary"><p>Removes an item from the back of the Deque. The indices of all existing items
in the Deque are unchanged. This method is
equivalent to <code>RemoveAt(Count-1)</code> but is a little more
efficient.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public T RemoveFromBack()</code></pre>
  </div>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">T</span></td>
        <td></td>
      </tr>
    </tbody>
  </table>
  <h5 id="Wintellect_PowerCollections_Deque_1_RemoveFromBack_remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>Removing an item from the back of the Deque takes
a small constant amount of time, regardless of how many items are in the Deque.</p>
</div>
  <h5 class="exceptions">Exceptions</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Condition</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.InvalidOperationException</span></td>
        <td><p>The Deque is empty.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Wintellect_PowerCollections_Deque_1_RemoveFromFront_" data-uid="Wintellect.PowerCollections.Deque`1.RemoveFromFront*"></a>
  <h4 id="Wintellect_PowerCollections_Deque_1_RemoveFromFront" data-uid="Wintellect.PowerCollections.Deque`1.RemoveFromFront">RemoveFromFront()</h4>
  <div class="markdown level1 summary"><p>Removes an item from the front of the Deque. The indices of all existing items
in the Deque are decreased by 1. This method is
equivalent to <code>RemoveAt(0)</code> but is a little more
efficient.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public T RemoveFromFront()</code></pre>
  </div>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">T</span></td>
        <td><p>The item that was removed.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="Wintellect_PowerCollections_Deque_1_RemoveFromFront_remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>Removing an item from the front of the Deque takes
a small constant amount of time, regardless of how many items are in the Deque.</p>
</div>
  <h5 class="exceptions">Exceptions</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Condition</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.InvalidOperationException</span></td>
        <td><p>The Deque is empty.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Wintellect_PowerCollections_Deque_1_RemoveFromFront_" data-uid="Wintellect.PowerCollections.Deque`1.RemoveFromFront*"></a>
  <h4 id="Wintellect_PowerCollections_Deque_1_RemoveFromFront" data-uid="Wintellect.PowerCollections.Deque`1.RemoveFromFront">RemoveFromFront()</h4>
  <div class="markdown level1 summary"><p>Removes an item from the front of the Deque. The indices of all existing items
in the Deque are decreased by 1. This method is
equivalent to <code>RemoveAt(0)</code> but is a little more
efficient.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public T RemoveFromFront()</code></pre>
  </div>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">T</span></td>
        <td><p>The item that was removed.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="Wintellect_PowerCollections_Deque_1_RemoveFromFront_remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>Removing an item from the front of the Deque takes
a small constant amount of time, regardless of how many items are in the Deque.</p>
</div>
  <h5 class="exceptions">Exceptions</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Condition</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.InvalidOperationException</span></td>
        <td><p>The Deque is empty.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Wintellect_PowerCollections_Deque_1_RemoveRange_" data-uid="Wintellect.PowerCollections.Deque`1.RemoveRange*"></a>
  <h4 id="Wintellect_PowerCollections_Deque_1_RemoveRange_System_Int32_System_Int32_" data-uid="Wintellect.PowerCollections.Deque`1.RemoveRange(System.Int32,System.Int32)">RemoveRange(Int32, Int32)</h4>
  <div class="markdown level1 summary"><p>Removes a range of items at the given index in the Deque. All items at indexes
greater than <code data-dev-comment-type="paramref" class="paramref">index</code> move down <code data-dev-comment-type="paramref" class="paramref">count</code> indices
in the Deque.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public void RemoveRange(int index, int count)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Int32</span></td>
        <td><span class="parametername">index</span></td>
        <td><p>The index in the list to remove the range at. The
first item in the list has index 0.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Int32</span></td>
        <td><span class="parametername">count</span></td>
        <td><p>The number of items to remove.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="Wintellect_PowerCollections_Deque_1_RemoveRange_System_Int32_System_Int32__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>The amount of time to delete <code data-dev-comment-type="paramref" class="paramref">count</code> items in the Deque is proportional
to the distance to the closest end of the Deque:
O(Min(<code data-dev-comment-type="paramref" class="paramref">index</code>, Count - <code data-dev-comment-type="paramref" class="paramref">index</code> - <code data-dev-comment-type="paramref" class="paramref">count</code>)).</p>
</div>
  <h5 class="exceptions">Exceptions</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Condition</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.ArgumentOutOfRangeException</span></td>
        <td><p><code data-dev-comment-type="paramref" class="paramref">index</code> is
less than zero or greater than or equal to Count, or <code data-dev-comment-type="paramref" class="paramref">count</code> is less than zero
or too large.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Wintellect_PowerCollections_Deque_1_RemoveRange_" data-uid="Wintellect.PowerCollections.Deque`1.RemoveRange*"></a>
  <h4 id="Wintellect_PowerCollections_Deque_1_RemoveRange_System_Int32_System_Int32_" data-uid="Wintellect.PowerCollections.Deque`1.RemoveRange(System.Int32,System.Int32)">RemoveRange(Int32, Int32)</h4>
  <div class="markdown level1 summary"><p>Removes a range of items at the given index in the Deque. All items at indexes
greater than <code data-dev-comment-type="paramref" class="paramref">index</code> move down <code data-dev-comment-type="paramref" class="paramref">count</code> indices
in the Deque.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public void RemoveRange(int index, int count)</code></pre>
  </div>
  <h5 class="parameters">Parameters</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Name</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Int32</span></td>
        <td><span class="parametername">index</span></td>
        <td><p>The index in the list to remove the range at. The
first item in the list has index 0.</p>
</td>
      </tr>
      <tr>
        <td><span class="xref">System.Int32</span></td>
        <td><span class="parametername">count</span></td>
        <td><p>The number of items to remove.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="Wintellect_PowerCollections_Deque_1_RemoveRange_System_Int32_System_Int32__remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>The amount of time to delete <code data-dev-comment-type="paramref" class="paramref">count</code> items in the Deque is proportional
to the distance to the closest end of the Deque:
O(Min(<code data-dev-comment-type="paramref" class="paramref">index</code>, Count - <code data-dev-comment-type="paramref" class="paramref">index</code> - <code data-dev-comment-type="paramref" class="paramref">count</code>)).</p>
</div>
  <h5 class="exceptions">Exceptions</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Condition</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.ArgumentOutOfRangeException</span></td>
        <td><p><code data-dev-comment-type="paramref" class="paramref">index</code> is
less than zero or greater than or equal to Count, or <code data-dev-comment-type="paramref" class="paramref">count</code> is less than zero
or too large.</p>
</td>
      </tr>
    </tbody>
  </table>
  
  
  <a id="Wintellect_PowerCollections_Deque_1_TrimToSize_" data-uid="Wintellect.PowerCollections.Deque`1.TrimToSize*"></a>
  <h4 id="Wintellect_PowerCollections_Deque_1_TrimToSize" data-uid="Wintellect.PowerCollections.Deque`1.TrimToSize">TrimToSize()</h4>
  <div class="markdown level1 summary"><p>Trims the amount of memory used by the Deque by changing
the Capacity to be equal to Count. If no more items will be added
to the Deque, calling TrimToSize will reduce the amount of memory
used by the Deque.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public void TrimToSize()</code></pre>
  </div>
  
  
  <a id="Wintellect_PowerCollections_Deque_1_TrimToSize_" data-uid="Wintellect.PowerCollections.Deque`1.TrimToSize*"></a>
  <h4 id="Wintellect_PowerCollections_Deque_1_TrimToSize" data-uid="Wintellect.PowerCollections.Deque`1.TrimToSize">TrimToSize()</h4>
  <div class="markdown level1 summary"><p>Trims the amount of memory used by the Deque by changing
the Capacity to be equal to Count. If no more items will be added
to the Deque, calling TrimToSize will reduce the amount of memory
used by the Deque.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public void TrimToSize()</code></pre>
  </div>
  <h3 id="eii">Explicit Interface Implementations
  </h3>
  
  
  <a id="Wintellect_PowerCollections_Deque_1_System_ICloneable_Clone_" data-uid="Wintellect.PowerCollections.Deque`1.System#ICloneable#Clone*"></a>
  <h4 id="Wintellect_PowerCollections_Deque_1_System_ICloneable_Clone" data-uid="Wintellect.PowerCollections.Deque`1.System#ICloneable#Clone">ICloneable.Clone()</h4>
  <div class="markdown level1 summary"><p>Creates a new Deque that is a copy of this one.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">object ICloneable.Clone()</code></pre>
  </div>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Object</span></td>
        <td><p>A copy of the current deque.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="Wintellect_PowerCollections_Deque_1_System_ICloneable_Clone_remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>Copying a Deque takes O(N) time, where N is the number of items in this Deque..</p>
</div>
  
  
  <a id="Wintellect_PowerCollections_Deque_1_System_ICloneable_Clone_" data-uid="Wintellect.PowerCollections.Deque`1.System#ICloneable#Clone*"></a>
  <h4 id="Wintellect_PowerCollections_Deque_1_System_ICloneable_Clone" data-uid="Wintellect.PowerCollections.Deque`1.System#ICloneable#Clone">ICloneable.Clone()</h4>
  <div class="markdown level1 summary"><p>Creates a new Deque that is a copy of this one.</p>
</div>
  <div class="markdown level1 conceptual"></div>
  <h5 class="decalaration">Declaration</h5>
  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">object ICloneable.Clone()</code></pre>
  </div>
  <h5 class="returns">Returns</h5>
  <table class="table table-bordered table-striped table-condensed">
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><span class="xref">System.Object</span></td>
        <td><p>A copy of the current deque.</p>
</td>
      </tr>
    </tbody>
  </table>
  <h5 id="Wintellect_PowerCollections_Deque_1_System_ICloneable_Clone_remarks">Remarks</h5>
  <div class="markdown level1 remarks"><p>Copying a Deque takes O(N) time, where N is the number of items in this Deque..</p>
</div>
  <h3 id="implements">Implements</h3>
  <div>
      <span class="xref">System.Collections.Generic.IList&lt;T&gt;</span>
  </div>
  <div>
      <span class="xref">System.Collections.Generic.ICollection&lt;T&gt;</span>
  </div>
  <div>
      <span class="xref">System.Collections.Generic.IEnumerable&lt;T&gt;</span>
  </div>
  <div>
      <span class="xref">System.Collections.IList</span>
  </div>
  <div>
      <span class="xref">System.Collections.ICollection</span>
  </div>
  <div>
      <span class="xref">System.Collections.IEnumerable</span>
  </div>
  <div>
      <span class="xref">System.ICloneable</span>
  </div>
</article>
          </div>
          
          <div class="hidden-sm col-md-2" role="complementary">
            <div class="sideaffix">
              <div class="contribution">
                <ul class="nav">
                </ul>
              </div>
              <nav class="bs-docs-sidebar hidden-print hidden-xs hidden-sm affix" id="affix">
                <h5>In This Article</h5>
                <div></div>
              </nav>
            </div>
          </div>
        </div>
      </div>
      
      <footer>
        <div class="grad-bottom"></div>
        <div class="footer">
          <div class="container">
            <span class="pull-right">
              <a href="#top">Back to top</a>
            </span>
            
            <span>Generated by <strong>DocFX</strong></span>
          </div>
        </div>
      </footer>
    </div>
    
    <script type="text/javascript" src="../styles/docfx.vendor.js"></script>
    <script type="text/javascript" src="../styles/docfx.js"></script>
    <script type="text/javascript" src="../styles/main.js"></script>
  </body>
</html>
